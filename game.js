

window.addEventListener("load", initGame, false);
var c;
var d;
var e;

    ccc=1;
    ddd=1;
    eee=1;

var firsty =false;

function whatMapp(map){

	if(map=="room1map"){
		return  [111,111,111,111,111,886,000,000,000,000,000,000,000,111,111,111,111,111,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,111,111,111,111,111,111,
                 111,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 111,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 111,000,000,000,111,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 111,111,111,111,000,000,000,000,000,000,000,000,000,111,111,111,111,111,111,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,333,333,333,333,333,333,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,111,111,000,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,111,000,000,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,000,000,000,000,111,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,111,666,111,111,111,000,000,000,000,000,111,000,000,000,000,333,333,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,888,666,222,222,222,222,444,888,000,000,000,000,000,000,000,000,333,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,000,000,000,000,000,999,111,111,222,222,000,000,000,000,000,000,000,000,000,000,000,333,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,000,000,000,000,000,999,999,111,222,222,000,000,000,000,000,000,111,111,000,000,000,333,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,111,555,000,000,000,000,000,111,111,111,000,555,000,000,000,000,111,111,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,555,000,000,000,000,111,111,000,000,000,000,000,000,000,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,555,000,000,000,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,885,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000];

}else if(map=="room1mapL2"){
		return  [111,111,111,111,111,000,000,000,000,000,000,000,000,111,111,111,111,111,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 111,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 111,000,000,000,000,000,000,000,000,000,000,000,111,111,111,111,111,111,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 111,000,000,000,111,000,000,000,000,000,000,000,111,333,333,333,333,333,111,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 111,111,111,111,000,000,000,000,000,000,000,000,333,333,333,333,333,333,333,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,333,333,333,333,333,333,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,111,111,111,111,111,000,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,111,000,000,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,000,000,000,000,111,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,111,666,111,111,111,000,000,000,000,000,111,000,000,000,000,333,333,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,888,666,222,222,222,222,444,888,000,000,000,000,000,000,000,000,333,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,000,000,000,000,000,999,111,111,222,222,000,000,000,000,000,000,000,000,000,000,000,333,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,000,000,000,000,000,999,999,111,222,222,000,000,000,000,000,000,111,111,000,000,000,333,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,111,555,000,000,000,000,000,111,111,111,000,555,000,000,000,000,111,111,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,555,000,000,000,000,111,111,000,000,000,000,000,000,000,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,555,000,000,000,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000];

                 ///Same as before, but difference in obstacles when in level 222

                 //   THERE NEEDS TO BE AN IN BETWEEN..>> under player >> for blocks under animation tiles
                                            ////   with transparency to show this tiles behind (on rounded edges)
                                                  /// otherwise the animation effect would be static on this edges

                                                  // c - d >>> ccc - ddd
}else if(map=="room1mapOver"){
	return [111,111,111,111,111,000,000,000,000,000,000,000,000,111,111,111,111,111,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 111,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 111,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 111,000,000,000,111,000,000,000,000,000,000,000,000,777,777,777,777,777,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 111,111,111,111,000,000,000,000,000,000,000,000,000,333,333,333,333,333,333,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,333,333,333,333,333,333,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,111,111,000,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,111,000,000,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,000,000,000,000,111,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,111,666,333,333,333,000,000,000,000,000,111,000,000,000,000,777,777,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,888,666,222,222,222,222,ddd,888,000,000,000,777,777,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,000,000,000,000,000,999,111,111,222,222,000,000,000,000,000,000,777,777,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,000,000,000,000,000,999,999,111,777,777,000,000,000,000,000,000,111,111,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000, 
                 000,000,111,111,000,000,000,000,000,111,111,111,000,ccc,000,000,000,000,111,111,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,ccc,000,000,000,000,111,111,000,000,000,000,000,000,000,111,000,000,000,000,000,000,111,000,000,000,000,000,000, 
                 000,000,111,111,000,000,000,000,000,000,000,000,000,ccc,000,000,000,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000, 
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000, 
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000, 
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000, 
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000, 
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000, 
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000, 
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000, 
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000, 
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000, 
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000, 
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,111,000,000,000,000,000,000];



}else if(map=="room2map"){
	return [111,111,111,111,111,000,000,000,000,000,000,000,000,111,111,111,111,111,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 111,000,000,000,000,000,000,000,000,000,000,000,000,111,111,111,111,111,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 111,000,000,000,000,000,000,000,000,888,222,000,000,111,111,111,111,111,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 111,000,000,000,111,000,000,000,000,222,222,000,000,111,111,111,111,111,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 111,111,111,111,000,000,000,000,000,000,000,000,000,111,111,111,111,111,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,886,000,000,000,000,000,000,111,111,111,111,111,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,111,111,111,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,000,000,000,111,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,000,000,000,111,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,000,000,000,000,111,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,000,222,222,222,000,000,000,000,000,000,000,555,000,000,000,000,111,111,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,000,222,222,222,000,000,000,000,000,000,000,555,000,000,000,000,111,111,000,000,000,000,000,000,000,111,000,000,000,000,000,000,
                 000,000,000,222,222,222,000,000,000,000,000,000,000,555,000,000,000,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 000,000,000,222,222,222,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 000,000,111,111,222,222,000,000,000,000,000,000,000,111,111,000,111,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 000,000,111,111,222,222,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 000,000,111,111,222,222,000,000,000,000,000,000,000,111,111,000,111,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,999,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000];

}else if(map== "room2mapOver"){
	return [111,111,111,111,111,000,000,000,000,000,000,000,000,111,111,111,111,111,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 111,000,000,000,000,000,000,000,000,000,000,000,000,111,111,111,111,111,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 111,000,000,000,000,000,000,000,000,888,222,000,000,111,111,111,111,111,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 111,000,000,000,111,000,000,000,000,222,222,000,000,111,111,111,111,111,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 111,111,111,111,000,000,000,000,000,000,000,000,000,111,111,111,111,111,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,885,000,000,000,000,000,000,111,111,111,111,111,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,111,111,111,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,000,000,000,111,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,000,000,000,111,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,000,000,000,000,111,000,000,000,000,777,777,000,000,000,000,000,000,000,000,000,000,
                 000,000,111,111,000,000,000,000,000,000,000,000,000,000,000,000,000,000,777,777,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,777,777,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,111,111,000,000,000,000,000,000,000,000,000,000,000,000,000,000, 
                 000,000,000,222,222,222,000,999,000,000,000,000,000,ccc,000,000,000,000,111,111,000,000,000,000,000,000,000,000,000,000,000,000,000,000,
                 000,000,000,222,222,222,000,999,000,000,000,000,000,ccc,000,000,000,000,111,111,000,000,000,000,000,000,000,111,000,000,000,000,000,000, 
                 000,000,000,222,222,222,000,000,000,000,000,000,000,ccc,000,000,000,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000, 
                 000,000,000,222,222,222,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000, 
                 000,000,111,111,222,222,000,000,000,000,000,000,000,111,111,000,111,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000, 
                 000,000,111,111,222,222,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000, 
                 000,000,111,111,222,222,000,000,000,000,000,000,000,111,111,000,111,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000, 
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000, 
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000, 
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000, 
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,000,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000, 
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000, 
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000, 
                 000,000,111,111,000,000,000,000,000,000,000,000,000,111,111,000,111,111,111,111,000,000,000,000,000,000,111,111,000,000,000,000,000,000];
	}
}


var canvasBg = document.getElementById("canvasBg"),
    ctxBg = canvasBg.getContext("2d"),
    canvasPlayer = document.getElementById("canvasPlayer"),
    ctxPlayer = canvasPlayer.getContext("2d"),
    canvasOverlay = document.getElementById("canvasOverlay"),
    ctxOverlay = canvasOverlay.getContext("2d"),
    canvasEntities = document.getElementById("canvasEntities"),
    ctxEntities = canvasEntities.getContext("2d"),
    canvasPause = document.getElementById("canvasPause"),
    ctxPause = canvasPause.getContext("2d"),
    canvasMenu = document.getElementById("canvasMenu"),
    ctxMenu = canvasMenu.getContext("2d"),
    canvasMenuOver = document.getElementById("canvasMenuOver"),
    ctxMenuOver = canvasMenuOver.getContext("2d"),
    canvasMenuOverOver = document.getElementById("canvasMenuOver"),
    ctxMenuOverOver = canvasMenuOverOver.getContext("2d"),
    canvasOverOverlay = document.getElementById("canvasOverOverlay"),
    ctxOverOverlay = canvasOverOverlay.getContext("2d");

///// esto aca arriba HA de ser reducido


var mapObsL1;

var mapObsL2;

var canvasWidth = 0;
var canvasHeight = 0;


var shiftX=0;
var shiftY=0;


var keysPressed = []; 
var keyDown={isDown:false, whatKey:null};



var imgPlayer = new Image();
    imgPlayer.src = "images/hero.png";    //////   HERO.PNG


var itemSprite = new Image();
    itemSprite.src = "images/sprite2.png";
    
var imgSpriteTile0 = new Image();
    imgSpriteTile0.src = "images/map-tiles2.png";

var menuSprite = new Image();
    menuSprite.src = "images/sprite3.png";

var edge = new Image();
    edge.src = "images/edge.png";


var tileDiameter; 

if(window.innerWidth>1000){
    tileDiameter = 46;  // window.innerWidth/40; || 30;     >>>> cambiar segun tamanho de pantalla
}else{
    tileDiameter = 40; 
}

var obstacles = [];
var areas= [];



var animScroll=35;
///
// AREA SCROLL
// PAUSE SCROLL
var animCount = 0;


///  PLAYER COORDINATES
var currentRoom;
var currentArea;
var currentLevel;

var nextRoom;


// DOORS
var doorID;   

var blockedDoorIndex =[];

var inDoorCrash={crash:false, id:0};

var  inArea={inIt:false, whatArea:currentArea};



var    isPlaying = false;

var    requestAnimFrame =  window.requestAnimationFrame ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame ||
                        window.oRequestAnimationFrame ||
                        window.msRequestAnimationFrame ||

                        function(callback) {
                            window.setTimeout(callback, 1000 / 1);
                        };

window.cancelAnimFrame = (function () {
    return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function (callback) {
        window.clearTimeout(callback);
    };
})();

var paused = false;

var pauseType;
var pausedRoomChangeLoop=false;
var pauseCount= 0;



var players=[];

var newPlayerCreation = new Array();
///// what controller triggered the playerCreation
newPlayerCreation[0] = "player1"; 
///////  what value was in what that controller pressed
newPlayerCreation[1] = "WASCHO";

players.push(newPlayerCreation);

var items = [];

var itemSelectPressed=false;
var itemSelectPressedCounter=0;


var menuCursor="nada";

var menuTrack=0;
var itemRow=0;
var gunRow=0;

var menuAnimCount=0;
 

var bullets = [0,0,0,0,0,0,0,0,0,0];  //// each weapon in its corresponding index


//should be in Funtion => GAME
function initGame() {


    /////  for stupid display types (ex, when the hegth's bigger than the width) use:
    /// window.innerWidth; >>>> window.innerHeight / 6  o lo que sea   <<<   matiene aspect ratio

    //// better to keep display at hard pixels and change a few times depending ongeneral screen-size, maintaining aspect ratio and adding black
///////          this mainly because canvas goes fckng slow when on bigger-than screen, and the speed variation at diff sizes is insane 
    //////                                                                                                  (still need to adjust to it)

    canvasBg.width =1000;
    canvasBg.height = 600;
    canvasBgTop.width =1000;
    canvasBgTop.height = 600;
    canvasEntities.width =1000;
    canvasEntities.height = 600;
    canvasPlayer.width =1000;
    canvasPlayer.height = 600;
    canvasOverlay.width =1000;
    canvasOverlay.height = 600;
    canvasOverOverlay.width =1000;
    canvasOverOverlay.height = 600;
    canvasPause.width =1000;
    canvasPause.height = 600;
    canvasMenu.width =1000;
    canvasMenu.height = 600;
    canvasMenuOver.width =1000;
    canvasMenuOver.height = 600;
    canvasMenuOverOver.width =1000;
    canvasMenuOverOver.height = 600;


    if(canvasBg.width<window.innerWidth){
        document.getElementById("container").style.margin= "0 "+(window.innerWidth-canvasBg.width)/2+"px";
    }else{
        document.getElementById("container").style.margin= "0";
    }
    // CSS margin won't work





    document.addEventListener("keydown", function(e) {

        checkKey(e, true); 

         if(checkKey(e, true, true)==37||checkKey(e, true, true)==38||checkKey(e, true, true)==39||checkKey(e, true, true)==40){
            player1.speed=10;  /////////    8 =>   currentSpeed <<<   should vary throughout the game
        }

    }, false);



    document.addEventListener("keyup", function(e) {

        keysPressed = [];
        keyDown.isDown=false; 

        //player1.direction = "nowhere"; ///  ALGO ME TIENE QUE DETENER, NO EL LEVANTAR UNA TECLA, si no no puedo correr y disparar al mismo tiempo
        if(checkKey(e, true, true)==37||checkKey(e, true, true)==38||checkKey(e, true, true)==39||checkKey(e, true, true)==40){

        ///ONLY IF ARROWS!!!
        friction(); /// this should stop player when key up
        }

        if(checkKey(e, true, true)==50){

            player1.shooting=false;
        }


    },false);



    begin();

}





//diff keys for diff players
function checkKey(e, value, checkArrows) {


    if(checkArrows){
        return e.keyCode;
    }else{

    keyDown.isDown=true;
    // e = e || event; 
    keysPressed[e.keyCode] = e.type;


    if (keysPressed[38]) { 
        
        //player1 should change to "Da player"
        player1.direction = "up";
        player1.facing = "up";

        if(paused){
            
            menuCursor = "up";

            requestAnimFrame(pause);
        }                 
    }


    if (keysPressed[40]) {  /////////////////////////////// YES, WORKS        
        player1.direction = "down";  /// to know it can do another one.. 
        player1.facing = "down";


        if(paused){
           
            menuCursor = "down";



       
    
    if(menuTrack==0){
            
            if(typeof player1.items[1]!="undefined"&&itemRow!=player1.items.length-2){

                itemRow+=1;
                //console.log("row"+menuRow);
                menuItemAlreadyPainted=false;


                
                  
                
            }else if(itemRow==player1.items.length-2){

                itemRow=0;
                menuItemAlreadyPainted=false;
                
            }
             selecto();
    }else if(menuTrack==1){
            
            if(typeof player1.guns[1]!="undefined"&&gunRow!=player1.guns.length-2){
                //alert(menuRow);
                gunRow+=1;
                //console.log("row"+menuRow);
                menuGunAlreadyPainted=false;

                  
                
            }else if(gunRow==player1.guns.length-2){

                gunRow=0;
                menuGunAlreadyPainted=false;
                
            }
             selecto();
    }

    menuH_items.draw();

    clearCtx(ctxEntities);
    for(var i=0; i< items.length; i++){
       items[i].draw();
    }
/////////
///////////////////////////////////////////////////////


        }  
    }

    if (keysPressed[39]) {  
        
        ///////////////////////////////////
        ////////////////                            DONT LET THE CURSOR THING HAPPEN, IF I HAVENT GOT THE ARRAYS!@

        player1.direction = "right";  /// to know it can do another one..
        player1.facing = "right";


        if(paused){
            menuCursor = "right";

            if(menuTrack==0){
                menuTrack=1;
                 selecto();
                menuH_guns.draw();
            }else if(menuTrack==1){
                menuTrack=0;
                 selecto();
                menuH_items.draw();
            }
        }
    }
    if (keysPressed[37]) {  /////////////////////////////// YES, WORKS
        player1.direction = "left";  /// to know it can do another one..   
        player1.facing = "left";

        if(paused){
            menuCursor = "left";

            if(menuTrack==0){
                menuTrack=1;
                 selecto();
                menuH_guns.draw();
            }else if(menuTrack==1){
                menuTrack=0;
                 selecto();
                menuH_items.draw();
            }
        }       
    }
    if (keysPressed[40]&&keysPressed[39]) {  /////////////////////////////// YES, WORKS
        player1.direction = "right-down";  /// to know it can do another one..      
           
    }
    if (keysPressed[40]&&keysPressed[37]) {  /////////////////////////////// YES, WORKS
        player1.direction = "left-down";  /// to know it can do another one..  

    }



//// probando, check, check, 1, 2, lifebar
    if (keysPressed[71]) {  /////////////////////////////// YES, WORKS
        
        player1.life-=3;
        if(player1.life<=0){
            alert("MUERTE");
        }
    }




    if (keysPressed[32]) {  /////////////////////////////// YES, WORKS
        player1.direction="nada";
        if(!paused){
            paused=true;
            selecto();
            pause();

            ////also : pause IS BEING SENT TO OUTSIDE FUNCTION SO AS TO RECOURSE IT WHILE notPlaying & WHILE STILL LISTENING TO KEYS 
            ////                                                                            which trigger different parts of pause(function)
           
        }else{
            paused=false;
            pause();
        }

    }


    //openDoor
    if(keysPressed[49]){

        keyDown.whatKey=49;

       
        //if(inDoorCrash.crash==true){

        //console.log(obstacles.length);
    if(inDoorCrash.crash==true){
        //console.log(inDoorCrash.id);
        doorOpen(inDoorCrash.id);
    }
/// now loop through all obstacles { loop through all doors >>>  if(door.id==inDoorCrash.id){ if(door.leftX == obstacle.leftX){ delete both}} }


    }


    if(keysPressed[50]){
         player1.shooting=true;
    }






    dirMemory.push(player1.direction);

    //MAKE VAR TO REMEMBER LAST DIRECTION 

    /// ROOM of ice >>> pushes you in your last direction >> recursively, a bit less everytime until fade << momentum

    e.preventDefault();

}

}//END check spacebar


 function selecto(){


    ////  MAKE SO WHEN A GUNTYPE FIRSTPICK >> GOES AND SELECT IT AND DRAWS IT IN MENU AS CURRENT


    //console.log("????"+menuTrack);


        if(menuTrack==0){

            //if not true already..
            
                menuH_items.isSelected=true;


                ///loop row =>> loop player1.items...
                for(var i=0; i<player1.items.length-1; i++){
                    if(itemRow==i){
                        player1.itemSelected=i+1;
                        menuH_items.rowSelec=i;
                       
                    }
                }

            menuH_items.draw();

        /// ELSE if menuTrack ==1 .... gunSelectPressed
        }else if(menuTrack==1){

            /// IF menuTrack==0

            //if not true already..
            
                menuH_guns.isSelected=true;

                for(var i=0; i<player1.guns.length-1; i++){
                    if(gunRow==i){
                        //console.log("A VER A VER "+player1.guns[i+1].itemNumber);
                        player1.gunSelected=player1.guns[i+1].itemNumber;
                        for(var j=0; j<bullets.length; j++){
                            if(player1.guns[i+1].itemNumber==j){
                                player1.guns[i+1].bullets=bullets[j];

                                // console.log("BULL "+player1.guns[i+1].bullets);
                                // depending on weapon, first pick could come with a few bullets...
                            }
                        }
                        menuH_guns.rowSelec=i;
                    }
                }


           
            //alert("yapo");
            /// ELSE if menuTrack ==1 .... gunSelectPressed
            menuH_guns.draw();
        }else if(menuTrack==2){

        }
       //alert(menuH_items.rowSelec);
    }
function clearCtx(ctx) {
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
}

function randomRange (min, max) {
    return Math.floor(Math.random() * (max + 1 - min)) + min;
}


function friction(){

        player1.speed=0;
        player1.direction="nada";
        //console.log(player1.speed);
        // if(player1.speed>0){
        //     //decrease speed until fully stopped
        //     friction();
        // }
        // no funciona, hay que ponerlo en player update (if not keyDown), pero las paredes se van a la mierda
}



///array para loopear >>> si number = id >> ese cambiar a lo que tiene que ser



function begin() {
    ///


    currentRoom= "room-1";
    currentArea="default";
    currentLevel=1;

    roomDraw(currentRoom, currentArea, 0, tileDiameter, 0, 0, "first", currentLevel);


    isPlaying = true;
    requestAnimFrame(loop);

    
    for (var i = 0; i < players.length; i++) {
      
        if(players[i][0]=="player1"){
            player1 = new Player(players[i][1]);

        }

    }   
    //CAN BE DONE PROGRAMATICALLY TOO

  //player1 = new Player(); /////////////  if (hitPlayer){  hitPlayer||player1 =  new Player(player1)
    // doors.push(
    //     new Door(325, 325, 25, 25, "inDoor")
    // );


    //should be in room  object?



    ///(srcX, y, drawX, yy, w, h, item, gun, ammo, life, selec,caught, branch)


    items.push( new Item(570,605,  150,tileDiameter*3, tileDiameter, tileDiameter, "item", 0, false, false, null, "room-1"), new Item(580,605, 200,200, tileDiameter, tileDiameter,"item", 2, false, false, null, "room-1"), new Item(600,605, 250,900, tileDiameter, tileDiameter,"item", 1, false, false, null, "room-2"), new Item(600,605, 330,360, tileDiameter, tileDiameter,"item", 1, false, false, null, "room-1"), new Item(600,605, 350,200, tileDiameter, tileDiameter,"item", 1, false, false, null, "room-1") );

    items.push( new Item(570,605,  150,250, tileDiameter, tileDiameter,"gun", 0, false, false, null, "room-1"), new Item(570,605, 200,250, tileDiameter, tileDiameter,"gun", 0, false, false, null, "room-1"), new Item(600,605, 250,250, tileDiameter, tileDiameter, "gun", 1, false, false, null, "room-1"));


    items.push( new Item(660,605,  550,150, tileDiameter, tileDiameter,"ammo", 1, false, false, null, "room-1"), new Item(660,605,  580,150, tileDiameter, tileDiameter,"ammo", 1, false, false, null, "room-1"));


menuH_items = new menuH(itemSprite, 700, 600, 30, 30, 200, 100, "item", false);
menuH_guns = new menuH(itemSprite, 700, 600, 30, 30, 230, 100, "gun", false);

}



//UPDATE everything
function update() {

    clearCtx(ctxBg);
    clearCtx(ctxPlayer);
    clearCtx(ctxOverlay);
    clearCtx(ctxOverOverlay);
    clearCtx(ctxEntities);

    //DONDE SEA QUE HALLA player1 >>> CAMBIAR POR 
    //for (var i = 0; i < players.length; i++) {
      
     //   if(players[i][0 == 1
    for (var i = 0; i < players.length; i++) {
        if(players[i][0] == "player1"){
            player1.update();
        }else{
            //player2.update();
        }
    }
   // player1.update();
    /// if ==2                            (if only) not exclusive
    /// player2.update()
    

//////////////////////////////////////////      ANIMATION TILES !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////      ANIMATION TILES !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////      ANIMATION TILES !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////      ANIMATION TILES !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    ///

    // if(!inArea){
    //     animScroll+=35;

    //     if(animScroll>=105){
    //         animScroll=0;
    //     }
    // }

     //console.log(player1.playerType);

    ////  Sample of being pushed unvoluntarily and still having walls stop you, yay! (enemy power weapon) >>>  for STUN FX simply block key-listening
        // if(player1.moving){
        //    player1.drawX +=player1.speed;
        //    player1.direction ="right";
        // }

    for(var i=0; i< items.length; i++){
        items[i].update();
    }
    roomDraw(currentRoom, currentArea, 0, tileDiameter, shiftX, shiftY, "not-first");

}



// & Re-DRAW
function draw() {
    for (var i = 0; i < players.length; i++) {
        if(players[i][0] == "player1"){
            player1.draw();
        }else{
            //player2.draw();
        }
    }
    for(var i=0; i< items.length; i++){
        items[i].draw();
    }
 

}



//master controls
function loop() {
    if (isPlaying) {
        update();
        draw();
        requestAnimFrame(loop);
    }

}


var daVar;  
function roomChangeLoop() {
        
      
    pausedRoomChangeLoop=true;    

    if (paused) {


        // <3 <6 < 9   --> will depend on game/computer SPEED

        /// ONE OR THE OTHER, not together >>> colours vs drop black
        /////
        ///// from roomChangeLoop() have roomChangeLoop(ARGUMENT) to determine if its a "door-pause" or a "game||menu-pause"

        if(pauseType=="normalFlash"){

                if(pauseCount<3){
                    pauseCount+=1;
                    currentArea="areaFuck";
                    roomDraw(currentRoom, currentArea, 0, tileDiameter, 0, 0, "not-first", currentLevel);
                   
                    requestAnimFrame(roomChangeLoop);
                }else if(pauseCount>=3&&pauseCount<6){
                    pauseCount+=1;
                    currentArea="areaFuck2";
                    roomDraw(currentRoom, currentArea, 0, tileDiameter, 0, 0, "not-first", currentLevel);
                    requestAnimFrame(roomChangeLoop);
                }else if(pauseCount>=6&&pauseCount<9){
                    pauseCount+=1;
                    currentArea="areaFuck3";
                    roomDraw(currentRoom, currentArea, 0, tileDiameter, 0, 0, "not-first", currentLevel);
                    requestAnimFrame(roomChangeLoop);

                }else{
           
                    paused=false;
                    isPlaying=true;
                    pauseCount=0;
                    currentArea="default";

                    obstacles = [];
                    areas = [];

                    clearCtx(ctxBg);
                    clearCtx(ctxOverlay);

                    //////HERE LOAD BLACK SCREEN... MAKE VAR=true, and when back in the loop, at the beginning theres an if/else
                                        // asking for this VAR  >> if true >>> do this animation backwards, from black to screen

                    roomDraw(nextRoom, currentArea, 0, tileDiameter, 0, 0, "first", currentLevel);

                    currentRoom=nextRoom;
                    ///AREA?

                    // whatPlayer?
                    for (var i = 0; i < players.length; i++) {
                        if(players[i][0] == "player1"){
                            player1.drawX=100;/////////////////////////    depends on room >>> REDRAW  OUTSIDE FUNCTION
                            player1.drawY=300;
                        }else{
                            // player2.drawX=100;
                            // player2.drawY=300;
                        }
                    }  



                requestAnimFrame(loop);
            }   

        }else if(pauseType=="transitionBlack"){////////////////////////////////////////////////////////////////////////////////////

            clearCtx(ctxPlayer);


            var firstCol= false;
            var roomToMap;
            var memberShiftY;

            /// HERE, before areas = []; gets emptied out,  we set  -300VAR according to how far from the top of the screen the door is
            for (var k = 0; k < areas.length; k++) {
                    
                //console.log("GOING TO "+doorID);
                if(areas[k].doorID==doorID){
                	/// first grab this door
                    if(!firstCol){

	                    if(nextRoom=="room-1"){
	                    	roomToMap = whatMapp("room1map");
	                    }else if(nextRoom=="room-2"){
	                    	roomToMap = whatMapp("room2map");;
	                    }

	                   	for(var e = 0; e<roomToMap.length; e++){ /////////  room2map >>> 1map, 3 map >>> SEGUN DONDE VAYA
	                   		if(roomToMap[e]==doorID){
	                   			//console.log("row kinda like  .."+((e/roomNumberTilesX)*tileDiameter));
	                   			console.log("WHERE "+(e/roomNumberTilesX)*tileDiameter);
	                   			if((e/roomNumberTilesX)*tileDiameter>window.outerHeight/2){



	                   				//  keep teleporting pads away from extreme edges.. SOLVED...


	                   				/// NOT ONLY CHECK HOW FAR DOWN IS THE DOOR, 
	                   				/// BUT ALSO THE PLAYER!!!!!!!!!!!!!!
	                   				////   IF THE PLAYER (- SHIFTS) IS ALREADY AROUND THERE.. THEN daVar HAS TO NOTE THAT AND NOT SHIFT UNNECESARILY EVERY TIME.....

	                   				///// ALSO, TO COME BACK, HAS TO MAKE THE OPOSITE QUESTION
	                   				///////// (e/roomNumberTilesX)*tileDiameter>window.outerHeight/2
	                   				/// BUT IF LOWER?? THAN PLAYER.DRAWY?? 
	                   				/// IF (e/roomNumberTilesX)*tileDiameter-player1.drawY <0)
	                   				///// is the door over the player>> && UNDER the screen height? 
	                   				/// then scroll up negative(positive)daVar.. or daVar = 0 if over player, but lower screen-height


	                   				if(nextRoom == "room-1"){
	                   					daVar = (window.outerHeight/3)-(e/roomNumberTilesX)*tileDiameter;
	                   					    ///////////  this is forced for the moment
	                   					////   right now we are only looking at a shift DOWN, but when coming back from down to UP?
	                   					/// need to remember too  (or keep room shifting at a minimum... more than one stage same room.. etc)

	                   				}else if(nextRoom == "room-2"){
	                   				
	                   						daVar = (window.outerHeight/3)-(e/roomNumberTilesX)*tileDiameter;
	                   					
	                   				////	  Its fine... its just about keeping the items in place...
	                   					
	                   					
	                   				}
	                   				/// Teleport en la misma piesa funciona bien..
	                   				/// de una a otra y de vuelta hay que ajustar esta daVar, pues la mantiene
	                   				///siendo que si la puerta queda de vuelta hacia arriba, no hace el srol de vuelta

	                   				////  Algo asi como lo que estoy forzando con el if/else que envuelve a daVar....


	                   				//console.log(daVar);
	                   				
	                   			}else{
	                   				//console.log("ese'0;");
	                   				daVar =0;	
	                   			}
	                   			
	                   			

	                   		}/// if room-N-map == doorID

	                   	}///for room-N-map



                    	//console.log("DVAR "+daVar);
                    	firstCol=true;// so gets only first
                    }
                    	
                }/// if areas == doorID

            }///for areas




             //alert(window.innerHeight);
             if(pauseCount<(window.innerHeight/2)){   ///<(canvasHeight/2)
                ctxOverOverlay.fillStyle = "#000000";
                ctxOverOverlay.fillRect(0, pauseCount-9, canvasWidth-50, 40);   

                
                
                pauseCount+=40;
                requestAnimFrame(roomChangeLoop);

            }else{

                //clearCtx(ctxMenu);

                paused=false;
                isPlaying=true;
                pauseCount=0;
                //currentArea="default";

                obstacles = [];
                areas = [];
                doors = [];

                clearCtx(ctxBg);
                clearCtx(ctxOverlay);
                //alert(nextRoom); 

                
                console.log("shifty "+Math.abs(shiftY));
                memberShiftY = Math.abs(shiftY);


                console.log("PLAYER Y "+(player1.drawY-shiftY));

                roomDraw(nextRoom, currentArea, 0, tileDiameter, 0,0-shiftY+daVar,"first", currentLevel); 

                
                                          ///  SO WHATEVER THE NUMBER HERE >> 300  <<< depending on how far from top or bottom is the door
                                                    ///                               when checking its player1.drawY=areas[k].row
                                                ////            >>>> how tall/wide is the screen? then we will know how much under it is
                                                ////                         and so we set this "300" VAR automatically from that offset
                currentRoom=nextRoom;
                
               // alert(currentArea);

	        ///where to reDrawPlayer?
	            var colRow=false;

                for (var k = 0; k < areas.length; k++) {
                    
                        //alert(doorID);
                    if(areas[k].doorID==doorID){//// AREAS hv to keep track of what ROW/COLUMN they are in, to calculate new shiftX,Y
                           

                            ///set player position when new room is Drawn
                               
                        player1.drawX=areas[k].column-10+shiftX;  
                        player1.drawY=areas[k].row-10+shiftY;
                                
                                
                        blockedDoorIndex.push(k);
                        areas[k].isBlocked="blocked"
                                //alert(blockedDoorIndex[0]);  


                                // console.log("X "+areas[k].column);
                                // console.log("Y "+areas[k].row);
                                //     if(!colRow){
                        if(!colRow){
                            shiftY=daVar;////////////////////     REPLICATED HERE  >>> 300 VAR
                        }
                                   
               //////////////      Now I just have to calculate >>> after draggin the screen and moving back a bit without draggin back
                ///////                                   character will appear at the right place minus/plus that little non-drag
                ///
                //                                          HAVE TO COMPENSATE FOR IT!!

                                //////////////////// way to do this is to keep track of player position and compare againt shift
                                ////////  if at any point the shift remains the same but the player position has changed > or <
                                ////////////// 
                                ////////         then up here on player1.drawX, minus or plus accordingly   

                                ////   ALSO HAVE TO LOOP ALL ITEMS AND ADJUST TOO    
       
                    }
    
                }


              /// HERE ATTENTION,  when taking same door twice.. they go way up  (items[k].centerY see what I mean)

              /// gotta keep track of all the shifts in whichever room

              /// This ITEM KEEPS GOING UP FOR SOME REASON!!!


                for(var k =0; k<items.length; k++){
                      ///// OJO WHAT ROOM!! currentRoom
                    	///alert(daVar);
                  
                  //console.log("old shiftY="+Math.abs(shiftY));
                  ///ok, so that shiftY is being reset to zero, because of something to do with FirstDraw.. or whatever
                  // point is, need to remember it before it goes to zero, to minus it to the items...
                  if(!firsty){
                  		items[k].drawY -=Math.abs(daVar);
                        items[k].centerY -=Math.abs(daVar);  
                        	firsty=true;
                  }else{
                  	items[k].drawY -=Math.abs(daVar)-Math.abs(memberShiftY);
                        items[k].centerY -=Math.abs(daVar)-Math.abs(memberShiftY); 
                  }
                    		


            ///por ahi va, mierda.... UN LEVEL....  SOLO UNO!!!! no mas calcular mierdas de shiftY,X

            ////  esto tambien facilitaria el acordar de los obstaculos, puesto que solo seran dibujados la primera vez
            ////  NO MAMES!

                                     
                }  
                ////   ALSO HAVE TO LOOP ALL ITEMS AND ADJUST TOO   

                ///   por ahi va..... ahora tengo que ajustar tambien  
                ///  ....   bien, igual que el player, tiene que ajustar nomas..

                ////  ALSO, LINE 1117 >>> the 4 obstacles on the screen edges.. need to be readjusted
                ///////////           minusing, plusing it accordingly
                /// otherwise if the door is loewr than the screen (meaning forcing a shift)
                /// the obstacle would be drawn on what would be then the top of the screen, but not really the top of the map

                //////  
                ///  I mean, this is only a problem when wanting to teleport far away... as long as doors are kept aligned from one room to the next...
                ///   it should be fine.... by the time I want to teleport I hsould have a GAME" anyway... and if it is that important to have that feature, for STORY purposes... etc.... then, I'll figure it out then. 
                //   

                pausedRoomChangeLoop=false;
                requestAnimationFrame(loop);
                
            }/// ELSe

        }/// transition black /////////////////////////////////////////////////////////////////////////////////////////
    }
}
        



function changeRoom(whatRoom, whatDoorId, newShiftX, newShiftY){ ///////////////////   WHAT AREA!

        clearCtx(ctxPlayer);

        //block buttons so can't pause and go through door at the same time!!!!!!!!!!!!!
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        isPlaying = false;

        //////////// this 2-4 doen here will dpend on what door(to other room, diff from obstacle door -> Array) you went through
        nextRoom =whatRoom;
        doorID=whatDoorId;

       // currentArea="areaFuck";
        //roomDraw(currentRoom, currentArea, 0, 25, 0, 0);

        /// Set shiftX, Y where it was on last stage
        //alert(newShiftY);

        //// only do this  IF player1.drawY > window.innerWidth/2){}
        shiftX=newShiftX;

        shiftY=newShiftY;                    //////////  now, this shift has to be dependent on where this  PARTICULAR tile is located!!!

        //////////   
       // console.log("ahora "+shiftY);

        paused=true;
        pauseType="transitionBlack";
        roomChangeLoop();
}



function doorOpen(id){
   
   inDoorCrash.crash=false;
   //alert(inDoorCrash.id);

    player1.direction="a donde ira";

        for(var i=0; i < obstacles.length; i++){

            if(inDoorCrash.id==5&&obstacles[i].doorID==5){
                ccc=0;
                //alert(obstacles[i].isDoor);
                obstacles.splice(i,1);         ///////   INSTEAD OF THIS, OBSTACLES WILL HAVE IDS
                //alert(obstacles[i].isDoor);
                
            }else if(inDoorCrash.id==4&&obstacles[i].doorID==4){         ////////////////// rather, jut keep track using var in doorRile
                ddd=2; /// area
                obstacles.splice(i,1);

   ///// now how do i remember and reinsert??   Maybe try with delete. and solving the undefined problem at obstacle-hit-detection
            }
           
        }


    //                 ///// SLICE & REMEMBER IN A DIFF ARRAY

    //                 ///   THEN SPLICE  or DELETE?


}



function pause(){///////parameter which player
    menuH_items.draw();
    menuH_guns.draw();


    if(paused){
        /////////// items are KEPT as their respective types, then each type looped, 
        //                  becoming highlighted when pressing down and keeping track of which one you are at  >> if highlighted 
       //// then when press "A" >> becomes selected

        isPlaying = false;

        //menuAnimCount++;
        //requestAnimFrame(pause);                ///messes up player1.speed (or game speed)

    }else{
        if(!itemSelectPressed){
           // clearCtx(ctxMenuOver);    
        }

        isPlaying = true;
        //cancelAnimFrame(pause);          ///doesn't work? 
        requestAnimFrame(loop);
    }
    //console.log(count);
}


//Menu Highlighter
function menuH(img, srcX, srcY, w, h, x, y, type, selec) {
    this.image=img;
    this.srcX=srcX;
    this.srcY=srcY;
    this.width = w;
    this.height = h;
    this.drawX = x;
    this.drawY = y;
    this.is = type;
    this.isSelected= selec;
}



menuH.prototype.draw = function(){

    clearCtx(ctxMenuOver);





    if(paused){

            if(menuTrack==0){

                        if(player1.items[1]!=null&&player1.items[1]!="undefined"){
                            ctxMenuOver.drawImage(menuSprite, 48, 0, menuH_items.width, menuH_items.height, menuH_items.drawX, menuH_items.drawY, menuH_items.width, menuH_items.height);                                                
                        }
            }else if(menuTrack==1){
                     
                     if(player1.guns[1]!=null&&player1.guns[1]!="undefined"){
              
                        ctxMenuOver.drawImage(menuSprite, 48, 0, menuH_guns.width, menuH_guns.height, menuH_guns.drawX, menuH_guns.drawY, menuH_guns.width, menuH_guns.height);
                    }
     
            }
    }

    if(menuTrack==0){

                    
        if(menuH_items.isSelected&&menuH_items.rowSelec==itemRow){
            ctxMenuOverOver.drawImage(menuSprite, 73, 0, menuH_items.width, menuH_items.height, menuH_items.drawX, menuH_items.drawY, menuH_items.width, menuH_items.height);
        }
                        
        if(menuH_guns.isSelected&&menuH_guns.rowSelec==gunRow){
            ctxMenuOverOver.drawImage(menuSprite, 73, 0, menuH_items.width-10, menuH_items.height, menuH_items.drawX+30, menuH_items.drawY, menuH_items.width, menuH_items.height);
        }


    }else if(menuTrack==1){
                         
        if(menuH_guns.isSelected&&menuH_guns.rowSelec==gunRow){
            ctxMenuOverOver.drawImage(menuSprite, 73, 0, menuH_items.width-10, menuH_items.height, menuH_items.drawX+30, menuH_items.drawY, menuH_items.width, menuH_items.height);
        }

        if(menuH_items.isSelected&&menuH_items.rowSelec==itemRow){
            ctxMenuOverOver.drawImage(menuSprite, 73, 0, menuH_items.width, menuH_items.height, menuH_items.drawX, menuH_items.drawY, menuH_items.width, menuH_items.height);
        }
                
    }
////  if not paused or whatever...SLECTOR (es decir, afuera de esos ifs dentro de la pausa,, independiente de si es pausa o no)


}



//WORLD

function Obstacle(x, y, w, h, type, id) {
    this.drawX = x;
    this.drawY = y;
    this.width = w;
    this.height = h;
    this.leftX = this.drawX;
    this.rightX = this.drawX + this.width;
    this.topY = this.drawY;
    this.bottomY = this.drawY + this.height;

    this.isDoor = type;
    this.doorID = id;
}

////  Area type door?
function Area(x, y, w, h, n, type, id, to, column, row, roomTo,  blocked) {
    this.drawX = x;
    this.drawY = y;
    this.width = w;
    this.height = h;
    this.leftX = this.drawX;
    this.rightX = this.drawX + this.width;
    this.topY = this.drawY;
    this.bottomY = this.drawY + this.height;
    this.n = n; /////////////////////////////// area type

    this.isDoor=type;
    this.doorID=id;
    this.isBlocked=blocked;
    this.doorTO=to;
    this.roomTo= roomTo;
    this.column = column;
    this.row = row;
}

    
var roomStartX= 0;
var roomStartY= 0;
var roomLengthX= 0;
var roomLengthY= 0;



function roomDraw(currentRoom, area, tileMapIndex, tileWidthHeight, tileIndexX, tileIndexY, firstDraw, level){

    var img;

    //the starter X tile to change in all rows   >> do same for Y 
    var newTileIndexX = tileIndexX;

    roomNumberTilesY = 27;
    roomNumberTilesX = 41;

    roomLengthY= roomNumberTilesY * tileWidthHeight;
    roomLengthX= roomNumberTilesX * tileWidthHeight;

    canvasWidth = roomLengthX;
    canvasHeight = roomLengthY;



    imgSpriteTile0 = new Image();
    imgSpriteTile0.src = "images/map-tiles2.png";

    imgSpriteTile1 = new Image();
    imgSpriteTile1.src = "images/bg.png";    ///map-tiles2


    imgSpriteTile4 = new Image();
    imgSpriteTile4.src = "images/sprite.png";

    imgSpriteTile5 = new Image();
    imgSpriteTile5.src = "images/sprite2.png";

    imgSpriteTile6 = new Image();
    imgSpriteTile6.src = "images/sprite.png";




    imgSpriteTile2 = new Image();
    imgSpriteTile2.src = "images/map-tiles2.png";

    imgSpriteTile3 = new Image();
    imgSpriteTile3.src = "images/bg.png";



    // if(area=="default"){
    img = imgSpriteTile0;

        if(currentRoom == "room-1"){

            var mapObsL1 =  whatMapp("room1map");


			var mapObsL2 =  whatMapp("room1mapL2");


			var mapOverDraw=whatMapp("room1mapOver");




			if(firstDraw=="first"){
    ccc=1;
    ddd=1;
    eee=1;
    ///           siendo que estan siendo reseteados los obstaculos.. asi es como se resetea el dibujo. 
    ///////                   entra a la piesa de nuevo y vuelve a aparecer la puerta cerrada (o despues de abrir)
    ////
			   //console.log(currentLevel);

			   ////////
			   //////// SE ME ESTAN PERDIENDO LOS LADOS.. EN EL IDA Y VUELTA
			   ////  este +shiftX es sospechoso... LO MEJOR ES DEJAR QUE LOS OBSTACULOS DEFINAN EL BORDE...
			   ///////////////	HABIENDO OBSTACULOS EN LOS BORDES DE LOS MAPAS, ESTO YA ES INNECESARIO


			   obstacles =[];
			   areas = [];

			   var whatMap = {};

			    // obstacles.push(
			    //     new Obstacle(roomNumberTilesX* tileWidthHeight+shiftX, 0, tileWidthHeight, roomNumberTilesY* tileWidthHeight)
			    // );
			    // //limitScreen L
			    // obstacles.push(
			    //     new Obstacle(0-tileWidthHeight+shiftX, 0, tileWidthHeight, roomNumberTilesY* tileWidthHeight)
			    // );
			    // //limitScreen T
			    // obstacles.push(
			    //     new Obstacle(0, 0-tileWidthHeight+daVar, roomNumberTilesX* tileWidthHeight, tileWidthHeight)
			    // );
			    // //limitScreen B
			    // obstacles.push(
			    //     new Obstacle(0, roomNumberTilesY* tileWidthHeight+daVar, roomNumberTilesX* tileWidthHeight, tileWidthHeight)
			    // );

			   if(currentLevel==1){



			    tilesDraw(shiftX, shiftY, img, area, {mapObsL1}, roomNumberTilesY, roomNumberTilesX, tileMapIndex, tileWidthHeight, tileIndexX, tileIndexY, newTileIndexX);

			    //////////// ELSE LEVEL 2
			    /////////             obstacles = [];
			    ///////                               tilesDraw({tileMap LEVEL 2!! } >> with its own set of obstacles...  

			        //////                                                            then transition-area again >> goes back (var in, out to keep track)

			    }else{
			        tilesDrawLevel2(shiftX, shiftY, img, area, {mapObsL2}, roomNumberTilesY, roomNumberTilesX, tileMapIndex, tileWidthHeight, tileIndexX, tileIndexY, newTileIndexX);
			    }

			//////////////

			///////////////   CLARIFICADO:
			//                                   cuando pisa zona 3 (area transision), roomDraw(transition, level2)  [transition se ve igual que default, pero tiene que seguir siendo eso, asi no vuelve a nivel 1..mientras siga en transition]  
			//////////////////
			//////////                              Level 2 {TileMap}  es exactamente igual, con la diferencia que los blockes que te impedian entrar en level 2 desde abajo, ahora son area3(transition) caminable, y en cambio se corrieron y no te dejan bajar... Lo demas todo igual


			}else{


			    tilesOverlayDraw(shiftX, shiftY, img, area, {mapOverDraw}, roomNumberTilesY, roomNumberTilesX, tileMapIndex, tileWidthHeight, tileIndexX, tileIndexY, newTileIndexX, {x:0, y:0, t:0}, {x:120, y:0, t:1}, {x:160, y:0, t:2}, {x:150, y:0, t:3}, {x:10, y:0, t:4}, {x:200, y:0, t:5}, {x:120, y:0, t:6}, {x:35, y:80, t:7}, {x:160, y:0, t:8}, {x:40, y:40, t:9}); 
			     /////  {x:165, y:35} 3 > 4 doorHAS TO LOOK THE SAME, BUT NOT BE THE SAME (invisible door), so it looks like a door when in area
			                                                        /// (or still not if invisible..then just leave as the area block in the drawing Map[]
			                                                                           /// SAME WITH in-AREA OBSTACLES
			}
        }

        if(currentRoom == "room-2"){

        ////////////   VAR get current room
        ////////       REMEMBER THIS ROOM  >>> CURRENT ROOM = "room-1"


			var mapObsL1 =  whatMapp("room2map");

			///////////////////  what out, 3s don't work in here (cachar bien pa donde va todo que hace que aca se trunque cuando pisas un 3)
			/////////                                                   puede que la funcion pa dibujar el segundo piso no tenga argumento para "level"

			var mapOverDraw=whatMapp("room2mapOver");

			    roomNumberTilesY = 27;
			    roomNumberTilesX = 34;


		    if(firstDraw=="first"){
		        tilesDraw(shiftX, shiftY, img, area, {mapObsL1}, roomNumberTilesY, roomNumberTilesX, tileMapIndex, tileWidthHeight, tileIndexX, tileIndexY, newTileIndexX);


			    // obstacles.push(
			    //     new Obstacle(roomNumberTilesX* tileWidthHeight+shiftX, 0, tileWidthHeight, roomNumberTilesY* tileWidthHeight)
			    // );
			    // //limitScreen L
			    // obstacles.push(
			    //     new Obstacle(0-tileWidthHeight+shiftX, 0, tileWidthHeight, roomNumberTilesY* tileWidthHeight)
			    // );
			    // //limitScreen T
			    // obstacles.push(
			    //     new Obstacle(0, 0-tileWidthHeight+daVar, roomNumberTilesX* tileWidthHeight, tileWidthHeight)
			    // );
			    // //limitScreen B
			    // obstacles.push(
			    //     new Obstacle(0, roomNumberTilesY* tileWidthHeight+daVar, roomNumberTilesX* tileWidthHeight, tileWidthHeight)
			    // );

		    }else{
		        tilesOverlayDraw(shiftX, shiftY, img, area, {mapOverDraw}, roomNumberTilesY, roomNumberTilesX, tileMapIndex, tileWidthHeight, tileIndexX, tileIndexY, newTileIndexX, {x:0, y:0, t:0}, {x:12, y:0, t:1}, {x:160, y:0, t:2}, {x:160, y:0, t:3}, {x:0, y:0, t:4}, {x:200, y:0, t:5}, {x:120, y:0, t:6}, {x:40, y:80, t:7}, {x:160, y:0, t:8}, {x:40, y:40, t:9});   /////  {x:165, y:0} HAS TO LOOK THE SAME, BUT NOT BE THE SAME (invisible door), so when different area then will look like a door
		                                                                                /// (or still not)
		    }
        }/// room-2

    //limitScreenRight

}


///////////   PRELOAD IMAGES!!!
















/// TilesDraw - level2  >>> this 2, rather than draw, they define what is what>>>  later, tilesOverlayDraw  actually DRAWS this tiles on the screen



function tilesDraw(newShiftX, newShiftY, img, area, {mapObsL1}, roomNumberTilesY, roomNumberTilesX, tileMapIndex, tileWidthHeight, tileIndexX, tileIndexY, newTileIndexX){


//// cuidado con los ID de las puertas... si son iguales pueden haber problemas
            
        for(var i =0; i<roomNumberTilesY; i++){
            for(var e=0; e<roomNumberTilesX; e++){




                    if(mapObsL1[tileMapIndex].toString().substring(0,1)==0){ ///////// area (default)

                        
                        areas.push(
                            new Area(tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "default")
                        );
                    }else if(mapObsL1[tileMapIndex].toString().substring(0,1)==1){ ///////// obstacle out

                        
                        obstacles.push(
                            new Obstacle(tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "wall", 0)
                        );
                    }else if(mapObsL1[tileMapIndex].toString().substring(0,1)==2){ ///////// area 1

                     
                        areas.push(
                            new Area(tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "uno")
                        );
                    }else if(mapObsL1[tileMapIndex].toString().substring(0,1)==4){ ///////// door in area
                        areas.push(
                            new Area(tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "uno")
                        );
                     
                        obstacles.push(
                            new Obstacle(tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "door", 4)

                 
                        );
                    }else if(mapObsL1[tileMapIndex].toString().substring(0,1)==5){ ///////// door out

                     
                        obstacles.push(
                            new Obstacle(tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "door", 5)
                        );
                    }else if(mapObsL1[tileMapIndex].toString().substring(0,1)==6){ ///////// obstacle in area

                     
                        obstacles.push(
                            new Obstacle(tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "wall", 0)
                        );
                    }else if(mapObsL1[tileMapIndex]==888){ ///////// doorTO in area

                     
                        areas.push(////////////////////////////////    //  IMPORTANT!!!  after "door"=.n >> 888 = id, 885, dooTo >>> door is going to
                                        /////// now here below, this room it is going to (885)>> 885 tile has to be given it's 885 id so dootTo here MATCHES!!
                                        ///first is ID of this door, then ID doorItIsGoinggTo
                            new Area(tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "uno", "door", 888, 888, tileIndexX, tileIndexY,"room-2")
                        );
                    }else if(mapObsL1[tileMapIndex]==885){ ///////// doorTO in area

                     
                        areas.push(
                            new Area(tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "default", "door", 885, 886, tileIndexX, tileIndexY, "room-1")
                        );
                    }else if(mapObsL1[tileMapIndex]==886){ ///////// doorTO in area

                     
                        areas.push(
                            new Area(tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "default", "door", 886, 886, tileIndexX, tileIndexY, "room-1")
                        );
                    }else if(mapObsL1[tileMapIndex].toString().substring(0,1)==9){ /////////  doorTOout

                     
                        areas.push(
                            new Area(tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "default", "door", 999, 999,tileIndexX, tileIndexY,  "room-2")
                            /////////////////////////////           PLUS:  TO WHAT DOOR IN WHAT ROOM
                        );
                    }else if(mapObsL1[tileMapIndex].toString().substring(0,1)==3){ /////////  doorTOout

                     
                        areas.push(
                            new Area(tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "transition")
                            /////////////////////////////           PLUS:  TO WHAT DOOR IN WHAT ROOM
                        );
                    }
                    /////////////    ALSO THERES GOTTA BE OBSTACLES IN/OUT  THAT LOOK LIKE SOMETHING ELSE (SO DIFF NUMBER)
                    ///////                                         OR SOMETHING ELSES (IN/OUT) THAT LOK LIKE OBSTACLES

                    ////
                    //                      NUMBERS ARE TOO FEW, need to RE-MAP  with LETTERS!!!! 
                    ///


                 ///// IF OTHER NUMBER >>>>  AREA type DOOR-to-other room (inArea)  >> sprite: area/roof vs door

                ///// IF OTHER NUMBER >>>>  AREA type DOOR-to-other room (outArea)  >>  door vs blackened (or whatever outside of area looks like)


            tileIndexX+= tileWidthHeight;

            tileMapIndex++;

            }
        tileIndexY+=tileWidthHeight;
        tileIndexX=newTileIndexX;


        ///////// 3d FX
        // variance++;
        // tileWidthHeight+=1;
        /// not worth the efforst in map translation + calculating diagonals for smoth against the wall moving

        }

} /////   tilesDraw  

/////////   I JUST DON'T KNOW HOW TO TURN {mapObsL1}{mapObsL2} into a variable, to have tilesDraw in only one function
////  whatever I've tried doesn't work

function tilesDrawLevel2(newShiftX, newShiftY, img, area, {mapObsL2}, roomNumberTilesY, roomNumberTilesX, tileMapIndex, tileWidthHeight, tileIndexX, tileIndexY, newTileIndexX){


            
        for(var i =0; i<roomNumberTilesY; i++){
            for(var e=0; e<roomNumberTilesX; e++){




                    if(mapObsL2[tileMapIndex].toString().substring(0,1)==0){ ///////// area (default)

                        
                        areas.push(
                            new Area(tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "default")
                        );
                    }else if(mapObsL2[tileMapIndex].toString().substring(0,1)==1){ ///////// obstacle out

                        
                        obstacles.push(
                            new Obstacle(tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "wall", 0)
                        );
                    }else if(mapObsL2[tileMapIndex].toString().substring(0,1)==2){ ///////// area 1

                     
                        areas.push(
                            new Area(tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "uno")
                        );
                    }else if(mapObsL2[tileMapIndex].toString().substring(0,1)==4){ ///////// door in area
                        areas.push(
                            new Area(tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "uno")
                        );
                     
                        obstacles.push(
                            new Obstacle(tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "door", 4)

                 
                        );
                    }else if(mapObsL2[tileMapIndex].toString().substring(0,1)==5){ ///////// door out

                     
                        obstacles.push(
                            new Obstacle(tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "door", 5)
                        );
                    }else if(mapObsL2[tileMapIndex].toString().substring(0,1)==6){ ///////// obstacle in area

                     
                        obstacles.push(
                            new Obstacle(tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "wall", 0)
                        );
                    }else if(mapObsL2[tileMapIndex].toString().substring(0,1)==8){ ///////// doorTO in area

                     
                        areas.push(
                            new Area(tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "default", "door", 888, 888,tileIndexX, tileIndexY, "room-2")
                        );
                    }else if(mapObsL2[tileMapIndex].toString().substring(0,1)==9){ /////////  doorTOout

                     
                        areas.push(
                            new Area(tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "default", "door", 999, 999, tileIndexX, tileIndexY,"room-2")
                            /////////////////////////////           PLUS:  TO WHAT DOOR IN WHAT ROOM
                        );
                    }else if(mapObsL2[tileMapIndex].toString().substring(0,1)==3){ /////////  doorTOout

                     
                        areas.push(
                            new Area(tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "transition")
                            /////////////////////////////           PLUS:  TO WHAT DOOR IN WHAT ROOM
                        );
                    }


                 ///// IF OTHER NUMBER >>>>  AREA type DOOR-to-other room (inArea)  >> sprite: area/roof vs door

                ///// IF OTHER NUMBER >>>>  AREA type DOOR-to-other room (outArea)  >>  door vs blackened (or whatever outside of area looks like)


            tileIndexX+= tileWidthHeight;

            tileMapIndex++;

            }
        tileIndexY+=tileWidthHeight;
        tileIndexX=newTileIndexX;


        ///////// 3d FX
        // variance++;
        // tileWidthHeight+=1;
        /// not worth the efforst in map translation + calculating diagonals for smoth against the wall moving

        }

} /////   tilesDraw  L 2




    var areaY=0;
    var areaX=0;

    var animX=0;


function tilesOverlayDraw(newShiftX, newShiftY, img, area, {mapOverDraw}, roomNumberTilesY, roomNumberTilesX, tileMapIndex, tileWidthHeight, tileIndexX, tileIndexY, newTileIndexX){


    //// this will take the tiles sent by  tilesDrawOver after this standard parameters
    var defaultTiles = [];


    /// j =11>>  11 are the arguments we got in tilesOverlayDraw(). The tiles we want to get come after and we don't know how many they could be.
    for(var j=0; j < arguments.length; j++){
        if(j>11){
            ///// 11 are the arguments before the TILES Sprite corrdinates
            /// after that number we store this coordinate values in an array....
            defaultTiles.push(arguments[j]);
        }
    }////////////  I might have to give these "{x:320, y:0}" little objects another value >> number:44 >> refering exactly to what tileMap ocurrence they are supposed to be drawing. 
    ///  So they don't depend on a linear, 1, 2, 3 ,4, 5, 6 ,7, 8, 9, 10, 11.. programmatical ordering, which would never get to higher numbers.


   // console.log(defaultTiles[0].x);
            

            
        for(var i =0; i<roomNumberTilesY; i++){
            for(var e=0; e<roomNumberTilesX; e++){

        /// on each IF should call a function which takes ==N as parameter and calculates surroundings (according to that number) for smooth corners
        ///////
        //////////                                                           defaultTiles[j].x +  >>>> depending on result
        
        /////        .... now from this array we created above we relate their index value >> 0, 1, 2, 3  to the first digit 
        /////                                                      from the TILES' values in the map >>> 000, 111, 222, 333 >> 0, 1, 2, 3
        ////                                according to this we DRAW (and set the sprite)

                for(var j=0; j < defaultTiles.length; j++){
                    
                    if(area=="uno"){            
                        areaY=320;                            
                    }else{
                        areaY=0;
                    }/// will need one space for every different are (default = Y0, area1 = Y320, area2 = Y640...where everything repeats except for that area)
                    //  ||  
                    //         DO THIS IF/ELSE HERE Below to set areaY + 320 when defaultTiles[j].t == 0 (default) && IN AREA...
                    ////            then back to normal
                    /////       then all areas normal until area "X" = defaultTiles[j].t >>> areaY+320 >> back to normal..


                    if(mapOverDraw[tileMapIndex].toString().substring(0,1)==defaultTiles[j].t){   /// y menos de la mitad


                        // if(defaultTiles[j].t==0){

                        //     if(animX>=0&&animX<5){
                        //         areaX=0;
                        //     }else if(animX>=5&&animX<10){
                        //         areaX=40;
                        //     }else if(animX>=10&&animX<15){
                        //         areaX=80;
                        //     }else if(animX>=15){
                        //         areaX=0;
                        //         animX=0;
                        //     /////
                        //     /// animX lies at the bottom of this whole function, so the anim-frame doesn't move until ALL tiles have been set
                        //     /// (otherwise it animates like waterfall, pretty cool too)

                        //     /// TRy to keep a limited amount of tiles being animated!! (or check speed on avg computer)
                        //     }
                            
                           
                        // }else{
                        //    areaX=0; ///// back to ZERO so the other tiles, which aren't this animated one, don't shift
                        // }


                        /// 33 is the width of the portion to be drawn from the sprite (actual width in the sprite)
                        ctxBg.drawImage(img, defaultTiles[j].x+areaX, defaultTiles[j].y+areaY, 40, 40, tileIndexX, tileIndexY, tileWidthHeight/*+variance*/, tileWidthHeight/*+variance*/);


                        // remember the formula!!
                        // roomNumberTilesY = 27;
                        // roomNumberTilesX = 41;
                                     //// tileMapIndex+roomNumberTilesX meaning, the one directly below
                    if(!inArea.inIt){

                        if(typeof mapOverDraw[tileMapIndex+roomNumberTilesX] != "undefined"&&mapOverDraw[tileMapIndex].toString().substring(0,1)==0){
                       
                            if(mapOverDraw[tileMapIndex+roomNumberTilesX].toString().substring(0,1)==2){
                                /// 33 is the width of the portion to be drawn from the sprite (actual width in the sprite)
                                ctxOverlay.drawImage(edge, 0, 0, 40, 40, tileIndexX, tileIndexY, tileWidthHeight/*+variance*/, tileWidthHeight/*+variance*/);    
                                ///yep, it works
                                ////  now they need to be treated when IN AREAS
                            }    
                        
                        }
                    }/////////
                    /////
                    ////       IF IN AREA, ahora son estos los que pasan lista a sus edges!!  :)

                









                          //// IF   mapOverDraw[tileMapIndex].toString().substring(0,1)  == 6 
                             /// IF   mapOverDraw[tileMapIndex].toString().substring(0,2) >> DOS   >60&&<65     ELSE IF  >65&&<69 >>> DIF LOOK



             //// TO ADD THE SMOOTH EDGES:   here ctxBg after drawing, draw again now to add a background edge (so diff sprite & coord with the edges), according to what type of corner (4*4) and what's on it's side


                    } 

                                ////////////       THEN DOWN on the Overlay draws... do the same but on this ctx, so its on top of player

                                //// adding a transparency on every block, instead than a solid edge, would require adding a background on the tiles underneath the character, as well as the fancy transparency code.\

                    ///     ADD SOLID EDGES on either of the tiles that will be touching cover/smoothen mountains with grass-ends, or grass with mountain-ends  (Also keep track of colour according to tiles around)

                    ///   WHILE DOWN HERE:  Add Overlay level EDGES to adjacent tiles to areas, whenever they are toucing, so they cover player just before walking into an Area  (drawn on Overlay, otherwise, if done to the tile you are walking into itself, this edge, supposed to be the floor, would be on top of player.....)

                    ////// keep this approach were it is the tile which adds to itself a bit of whats beside/above/below it
                    ///
                    //






                    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    /////////////////////////////////////////////////////////////////////////////



                    //   SPRITE WITH ALL EDGES, DIFFERET COLUMN FOR EACH COLOR/SURFACE, DIFF ROW FOR EACH ANGLE >> RELATED TO 3 OPTIONS PER CORNER (3 ADJACENT TILEs FROM EVERY CORNER OF EVERY TILE) according to what these are, go building up those edges (seting srcX & Y too for perfectly matching colours)


                    /////////////////////////////////////////////
                    /// first is drawing what they are
                    // then
                    /// down here draws again on top those tiles that need to be OVER Player

                    if(mapOverDraw[tileMapIndex].toString().substring(0,1)==2){   /// y menos de la mitad
                        if(!inArea.inIt){



                        /// 33 is the width of the portion to be drawn from the sprite (actual width in the sprite)
                        ctxOverlay.drawImage(img, defaultTiles[2].x, defaultTiles[2].y, 40, 40, tileIndexX, tileIndexY, tileWidthHeight/*+variance*/, tileWidthHeight/*+variance*/);

                        }                            
                    }
                    if(mapOverDraw[tileMapIndex].toString().substring(0,1)==4){   /// y menos de la mitad


                        if(!inArea.inIt){
                        /// 33 is the width of the portion to be drawn from the sprite (actual width in the sprite)
                        ctxOverlay.drawImage(img, defaultTiles[4].x, defaultTiles[4].y, 40, 40, tileIndexX, tileIndexY, tileWidthHeight/*+variance*/, tileWidthHeight/*+variance*/);
                        }
                            
                    }                   

                    

                    if(mapOverDraw[tileMapIndex].toString().substring(0,1)==8){   /// y menos de la mitad


                        if(!inArea.inIt){
                        /// 33 is the width of the portion to be drawn from the sprite (actual width in the sprite)
                        ctxOverlay.drawImage(img, defaultTiles[8].x, defaultTiles[8].y, 40, 40, tileIndexX, tileIndexY, tileWidthHeight/*+variance*/, tileWidthHeight/*+variance*/);
                        }
                            
                    }        

                }/////  for

                if(mapOverDraw[tileMapIndex].toString().substring(0,1)==7){ /////  Numeros reservados para Overlays

                    /// 33 is the width of the portion to be drawn from the sprite (actual width in the sprite)
                    if(!inArea.inIt){
                        ctxOverlay.drawImage(img, 640, 0, 40, 40, tileIndexX, tileIndexY, tileWidthHeight/*+variance*/, tileWidthHeight/*+variance*/);
                    }else{
                        ctxBg.drawImage(img, 640, 0, 40, 40, tileIndexX, tileIndexY, tileWidthHeight/*+variance*/, tileWidthHeight/*+variance*/);
                    }

                            
                }   
                

                


            tileIndexX+= tileWidthHeight;

            tileMapIndex++;

            }
        tileIndexY+=tileWidthHeight;
        tileIndexX=newTileIndexX;


        }

        animX++;  /// moves to the next ANIM-frame for the animated tiles


} /////   tilesOverDraw  




















                       //         NOW THE EDGES, then fancy headings





















function Player(type) {
    //where in sprite
    this.srcX = 0;
    this.srcY = 0;

    this.upperSrcX= 1680;
    this.upperSrcY=0;


    //where in tileMap
    this.drawX = 420;
    this.drawY = 200;
    //in sprite with & height/// Math.round it
    this.width = tileDiameter+(tileDiameter/4);
    this.height = tileDiameter+tileDiameter/1.6;
    //center
    this.centerX = this.drawX + (this.width / 2);
    this.centerY = this.drawY + (this.height / 2);
    //starting moving values & speed
    this.speed = 0;
    this.moving = true; //can it move?

    this.direction = "nowhere";  // for moving mechanics purposes
    this.facing="nowhere";  /// diff from direction, for shooting Animation/sprite- purposes

    //animation
    this.isDead = false;
    this.animRate = 1;  //  ??

    //special player characteristics  if/elses
    this.playerType = type;

    this.weapons = []; /////////////// every weapon keeps count of its own ammo, 
    this.weaponSelected = 0;
    this.itemSelected=0;

    this.items = [];
    this.guns = [];

    this.shooting=false;


    this.life=20; //also inside playerType if/elses
    this.lifeTotal=100;
    ////  this(all) starts with 0,  then each diff type gets + more or less.. like Diablo, 

    ///////
    ///
    //   DIFFERENT QUALITIES LIKE speed, power, strength, intelligence.. hp, mp,  etc.....

}





//Shit happens
Player.prototype.update = function () {

    this.checkMoving(this.direction, this.moving);//  a bit faster when called right after keyPress
    this.animationState(this.dead, this.direction, this.animRate, this.moving);
    this.checkArea();

////  DEPENDING ON SELECT WHAT MENU-ITEM PLAYER IS USING  >>>>  1 button for gun, another for life item, other item permanently does/changes something

 

};




//Shit is shown
Player.prototype.draw = function () {


////////////////////////////////////////                  35, 50  ==>> this.width, this.height  ACTUAL W/H IN SPRITE

                                    ///// srcX, Y >> lower body
    

    //console.log("GUN SEL"+this.gunSelected); /////   ACCORDING TO THIS WE GO DOWN Y AXIS  this.srcY+50, 50, 50, 50
            //////////////////////       then in the future another dimension for the suits/armor you find

    if(this.gunSelected==1){
        this.srcY=50;
        this.upperSrcY=50;
    }else if(this.gunSelected==0){
        this.srcY=100;
        this.upperSrcY=100;
    }else{
        this.srcY=0;
        this.upperSrcY=0;
    }
    ctxPlayer.drawImage(imgPlayer, this.srcX, this.srcY, 35, 50, this.drawX, this.drawY, this.width, this.height);
/////////////////////////////            OK NOW DRAW SPRITE PROPERLY AND THE ANIMATION RIGHT WHEN SHOOTING
////////////
//////////                      moving changes srcX, Y... so should shooting (change upperSrcX, Y)
                                                          /// upperXrcX + + + as in the if(this.shooting) below

            ///////////////   Y AXIS should have a + VAR >>>  + 350..==> all weapons.. if got suit, or + 0 otherwise !!!!!!!!!!!!!!!!!!! 
            ///// (at that pixel all weapon cicles are repeated, but wearing this mega-cool suit)
            /////////////////
            ////////////////////            same with certain items, such as the goggles or the belt... could be seen


    if(this.shooting){            ///// changing upperSrc Anim according to shooting
        ctxPlayer.drawImage(imgPlayer, this.upperSrcX, this.upperSrcY, 35, 50, this.drawX, this.drawY, this.width, this.height);
    }else{                     //// shifted sprite (srcX, Y) for upperBody parts
        ctxPlayer.drawImage(imgPlayer, this.srcX+840, this.srcY, 35, 50, this.drawX, this.drawY, this.width, this.height);                 //// take off +3, that just to show its been drawn on top
                            ////            +3 actually + length of sprite (legs/upperbody)
    }
    ////  HEALTH BAR !!
    var shifto=0;
    for (var i = 0; i<player1.life; i++) {

                                                                  /// tal vez window.innerHeight... no se ve cuando achicas
        ctxOverlay.drawImage(itemSprite,770, 600, 5, 10, 255+shifto,window.innerHeight-60,5, 10); ///////////// ctx player so it gets updated
        shifto+=7;
    };

};


var newDrawX, 
    newDrawY;
var dirMemory = ["anywhere"];

var crash = false;
var areasCrash = false;





Player.prototype.checkMoving = function (direction, moving) {




    ////////////////IF SCREEN BIGGER THAN CANVAS
    if(canvasBg.width<window.innerWidth){
        var boxLimit_XL = canvasBg.width/8*3.3,    /// window.inner... or canvas.with depending on what the canvas size is
            boxLimit_XR = canvasBg.width/8*4.7,
            boxLimit_YT = canvasBg.height/8*3.3,
            boxLimit_YB = canvasBg.height/8*4.7; // canvasBg or any other canvas >> should all be the same

    }else{
        //// ELSE
        var boxLimit_XL = (window.innerWidth/16)*7,    /// window.inner... or canvas.with depending on what the canvas size is
            boxLimit_XR = (window.innerWidth/16)*9,
            boxLimit_YT = (window.innerHeight/8)*3,
            boxLimit_YB = (window.innerHeight/8)*5;
    }

    var    sprtLimit_XL = 100, 
    sprtLimit_XR = canvasWidth-100,
    sprtLimit_YT = 100,
    sprtLimit_YB = canvasHeight-100;


    ////////////////////////////////
    ////
    //     if not too close to room boundaries || not in center-screen-moving-areas >> you move, but the draw X,Y changes for everything else instead
    //console.log(crash);
    if(!this.checkCrash()){ 

        this.moving=true;

    }else {

        //////if direction same as crash -> false. 
        this.moving=false;
        crash=false;
        //console.log("choamo");
    }

    ///// denuevo  ACORDARSE ESTO TIENE QUE SER SEGUN PLAYERDRAWX, Y Y AFUERA DE ESTE CHECKEO DE MOVIMIENTO  (sino constante todo el rato hermano)





    if(this.moving){

        //console.log(currentRoom);

    var newCenterX = Math.round(newDrawX + (this.width / 2)),
        newCenterY = Math.round(newDrawY + (this.height / 2));
        ///
        ///// if within limits >, <=, >, <=


        newDrawX = this.drawX;
        newDrawY = this.drawY;

        
//////////////      ///      
//////////////      ///  //  
//////////////      ///     /
//////////////      ///  ////    
///////////////    ////  ////
///////////////////////  ////
/////////////////////////////


        if(this.direction=="up"){
            if(newCenterY<boxLimit_YT&&canvasHeight+shiftY<canvasHeight-this.speed){
                shiftY+=this.speed;

                ////////////////////////////////   DRAG SHIT

                for(var i =0; i<obstacles.length; i++){
                    obstacles[i].topY += this.speed;
                    obstacles[i].bottomY += this.speed;
                }


                for(var j =0; j<areas.length; j++){
                    areas[j].topY += this.speed;
                    areas[j].bottomY += this.speed;
                }
                
                //////  Items have center instead of bottom because thaat's  the point from which they get picked up
                for(var k =0; k<items.length; k++){
                    items[k].drawY += this.speed;
                    items[k].centerY += this.speed;    

                } 

            }else{
                this.drawY = this.drawY-this.speed;
            }

//////////    ///////
//////////     /////  
//////////      ///
//////////     ////
//////////    /////
/////////////////////

        }else if(this.direction=="down"){
            //console.log(canvasHeight+shiftY);
            if(newCenterY>boxLimit_YB&&canvasHeight-canvasBg.height>=Math.abs(shiftY)+this.speed){
                shiftY-=this.speed;
 
                for(var i =0; i<obstacles.length; i++){
                    obstacles[i].topY -= this.speed;
                    obstacles[i].bottomY -= this.speed;
                }

                for(var j =0; j<areas.length; j++){
                    areas[j].topY -= this.speed;
                    areas[j].bottomY -= this.speed;

                }  

                for(var k =0; k<items.length; k++){
                    items[k].drawY -= this.speed;
                    items[k].centerY -= this.speed;    

                }  
                //console.log(areas[0].topY);         

            }else{
                this.drawY = this.drawY+this.speed;
            }

        }else if(this.direction=="right"){

            /// yep yep 
            if(newCenterX>boxLimit_XR&&canvasWidth>((shiftX*-1)+canvasBg.width+this.speed)){
                shiftX-=this.speed;

                for(var i =0; i<obstacles.length; i++){
                    obstacles[i].leftX -= this.speed;
                    obstacles[i].rightX -= this.speed;
                }

                for(var j =0; j<areas.length; j++){
                    areas[j].leftX -= this.speed;
                    areas[j].rightX -= this.speed;
                }
              //alert(newObs[0].leftX);


            }else{

                this.drawX = this.drawX+this.speed;

            }            

        }else if(this.direction=="left"){

            if(newCenterX<boxLimit_XL&&canvasWidth+shiftX<canvasWidth-this.speed){
                shiftX+=this.speed;

                for(var i =0; i<obstacles.length; i++){
                    obstacles[i].leftX += this.speed;
                    obstacles[i].rightX += this.speed;
                }

                for(var j =0; j<areas.length; j++){
                    areas[j].leftX += this.speed;
                    areas[j].rightX += this.speed;
                }
            }else{
                this.drawX = this.drawX-this.speed;
            }

        }else if(this.direction=="right-down"){
            if(newCenterX>boxLimit_XR&&canvasWidth>((shiftX*-1)+canvasBg.width+this.speed)){
                shiftX-=this.speed;

                for(var i =0; i<obstacles.length; i++){
                    obstacles[i].leftX -= this.speed;
                    obstacles[i].rightX -= this.speed;
                }

                for(var j =0; j<areas.length; j++){
                    areas[j].leftX -= this.speed;
                    areas[j].rightX -= this.speed;
                }

            }else{

                this.drawX = this.drawX+this.speed;

            }

            if(newCenterY>boxLimit_YB&&canvasHeight-canvasBg.height>=Math.abs(shiftY)+this.speed){
                shiftY-=this.speed;
 
                for(var i =0; i<obstacles.length; i++){
                    obstacles[i].topY -= this.speed;
                    obstacles[i].bottomY -= this.speed;
                }

                for(var j =0; j<areas.length; j++){
                    areas[j].topY -= this.speed;
                    areas[j].bottomY -= this.speed;

                }


            }else{
                this.drawY = this.drawY+this.speed;
            }



        } else if(this.direction=="left-down"){
            if(newCenterX<boxLimit_XL&&canvasWidth+shiftX<canvasWidth-this.speed){
                shiftX+=this.speed;

                for(var i =0; i<obstacles.length; i++){
                    obstacles[i].leftX += this.speed;
                    obstacles[i].rightX += this.speed;
                }

                for(var j =0; j<areas.length; j++){
                    areas[j].leftX += this.speed;
                    areas[j].rightX += this.speed;
                }
            }else{
                this.drawX = this.drawX-this.speed;
            }

            if(newCenterY>boxLimit_YB&&canvasHeight-canvasBg.height>=Math.abs(shiftY)+this.speed){
                shiftY-=this.speed;
 
                for(var i =0; i<obstacles.length; i++){
                    obstacles[i].topY -= this.speed;
                    obstacles[i].bottomY -= this.speed;
                }

                for(var j =0; j<areas.length; j++){
                    areas[j].topY -= this.speed;
                    areas[j].bottomY -= this.speed;

                }


            }else{
                this.drawY = this.drawY+this.speed;
            }



        }

        /////  else  >>>>> oposite, stay same but move the rest..  logic down at checkCrash should remain the same (stays true both ways)


    }
        ///////////  DELETE LATER
        ctxOverlay.strokeStyle = "#FF0000";
        ctxOverlay.strokeRect(boxLimit_XL, boxLimit_YT, boxLimit_XR-boxLimit_XL, boxLimit_YB-boxLimit_YT);
}






//////  ALSO TO BE checkDOORCrash   checkCrash(wall vs door  or maybe both at all times, no if else needed, one for loop after the other) 

Player.prototype.checkCrash = function () {          ////////// GET PARAMETER >> if triggered from 


    //console.log(this.direction);

    var newCenterX = Math.round(newDrawX + (this.width / 2)),
        newCenterY = Math.round(newDrawY + (this.height / 2));


    function doorCrash(obstacleIndex){
        if(obstacles[obstacleIndex].isDoor=="door"){                     
            inDoorCrash={crash:true, id:obstacles[obstacleIndex].doorID};
        }
    }

    ///Loop through Obstacles
    for (var i = 0; i < obstacles.length; i++) {


        if(this.direction=="right"){
        
            ///in other words: as long as you are standing in the block before what would be the next one when going right
            if(newCenterY>=obstacles[i].topY&&newCenterY<obstacles[i].bottomY&&newCenterX<=obstacles[i].leftX&&newCenterX>obstacles[i].leftX-tileDiameter) {

                //but don't stop me just yet, i've just entered the square, now wait for me to be at the other side
                if(newCenterX+this.speed>=obstacles[i].leftX-(this.speed+1)){

                    crash = true; 

                    //if it's a door, you may open it   
                    doorCrash(i);
                }
            }
        }  
        if(this.direction=="left"){

            if(newCenterY<=obstacles[i].bottomY&&newCenterY>obstacles[i].topY&&newCenterX>=obstacles[i].rightX&&newCenterX<obstacles[i].rightX+tileDiameter) {
                
                if(newCenterX-this.speed<=obstacles[i].rightX+(this.speed+1)){
                    crash = true;

                        //if it's a door, you may open it   
                        doorCrash(i);
                }
            }
        }   
        if(this.direction=="up"){

            if(newCenterX>=obstacles[i].leftX&&newCenterX<obstacles[i].rightX&&newCenterY>=obstacles[i].bottomY&&newCenterY<obstacles[i].bottomY+tileDiameter) {

                if(newCenterY-this.speed<=obstacles[i].bottomY+(this.speed+1)){
                    crash = true;

                        //if it's a door, you may open it   
                        doorCrash(i);
                }         
            }
        }   
        if(this.direction=="down"){

            if(newCenterX>obstacles[i].leftX&&newCenterX<=obstacles[i].rightX&&newCenterY<=obstacles[i].topY&&newCenterY>obstacles[i].topY-tileDiameter) {

                if(newCenterY+this.speed>=obstacles[i].topY-(this.speed+1)){
                    crash = true;

                        //if it's a door, you may open it   
                        doorCrash(i);
                }
            }
        }   
        if(this.direction=="right-down"){ //////////   CONTINUE WITH ALL SIDES NOW THAT IT WORKS

            
            if(newCenterY>=obstacles[i].topY&&newCenterY<obstacles[i].bottomY&&newCenterX<=obstacles[i].leftX&&newCenterX>obstacles[i].leftX-tileDiameter) {

                //but don't stop me just yet, i've just entered the square, now wait for me to be at the other side
                if(newCenterX+this.speed>=obstacles[i].leftX-(this.speed+1)){

                    crash = true; 

                    //if it's a door, you may open it   
                    doorCrash(i);
                }
            }


            if(newCenterX>obstacles[i].leftX&&newCenterX<=obstacles[i].rightX&&newCenterY<=obstacles[i].topY&&newCenterY>obstacles[i].topY-tileDiameter) {

                if(newCenterY+this.speed>=obstacles[i].topY-(this.speed+1)){
                    crash = true;

                        //if it's a door, you may open it   
                        doorCrash(i);
                }
            }

        } 

        if(this.direction=="left-down"){ 

             if(newCenterY<=obstacles[i].bottomY&&newCenterY>obstacles[i].topY&&newCenterX>=obstacles[i].rightX&&newCenterX<obstacles[i].rightX+tileDiameter) {
                
                if(newCenterX-this.speed<=obstacles[i].rightX+(this.speed+1)){
                    crash = true;

                        //if it's a door, you may open it   
                        doorCrash(i);
                }
            }

            if(newCenterX>obstacles[i].leftX&&newCenterX<=obstacles[i].rightX&&newCenterY<=obstacles[i].topY&&newCenterY>obstacles[i].topY-tileDiameter) {

                if(newCenterY+this.speed>=obstacles[i].topY-(this.speed+1)){
                    crash = true;

                        //if it's a door, you may open it   
                        doorCrash(i);
                }
            }

        }




    }/// for loop Obstacles



    if (crash) {
        return true;
    } else {
        return false;
    }

};








////   IF AREA   DOOR-to-other-room >>>>>>>>>>>>>>>>  changeRoom(CORRESPONDING ROOM TO THIS DOOR)

Player.prototype.checkArea = function (){


    function doorTo(areasIndex){

//// ROOM TO !!!!
        if(areas[areasIndex].isDoor=="door"){

            if(areas[areasIndex].isBlocked!="blocked"){

                //console.log("door "+areasIndex);
                //console.log("ESTE?? "+ areas[i].roomTo);
                //console.log("MOV " +shiftY);
                changeRoom(areas[i].roomTo, areas[i].doorTO, shiftX, shiftY);/////  room-2 >> determined by door"To" (9[2]11), then ID (92[11])
                ///room-2 =>>> roomTO
            }                                
        }else{
           
            for(var h=0; h<blockedDoorIndex.length; h++){

                 if(typeof areas[blockedDoorIndex[h]]!="undefined"&& typeof areas[blockedDoorIndex[h]]!=null){  ///// typeof?
                           areas[blockedDoorIndex[h]].isBlocked="unblocked";
                           //console.log("BLOCK "+blockedDoorIndex[h]);
                }
            }
        }
    }

    function transitionArea(){
        if(currentArea=="transition"&&currentLevel!=2){
            currentLevel=2;
            //alert("miercale!! CARAMBA");
            roomDraw(currentRoom, currentArea, 0, tileDiameter, 0, 0, "first", currentLevel);

        }
        else if(currentArea!="transition"&&currentLevel!=1){
             //console.log(currentArea);
            currentLevel=1;

            roomDraw(currentRoom, currentArea, 0, tileDiameter, 0, 0, "first", currentLevel);
        }
    }


    var newCenterX = Math.round(newDrawX + (this.width / 2)),
        newCenterY = Math.round(newDrawY + (this.height / 2));


    for (var i = 0; i < areas.length; i++) {

        if(this.direction=="right"){
        
            if(newCenterX<areas[i].rightX&&newCenterX>=areas[i].leftX&&newCenterY<=areas[i].bottomY&&newCenterY>areas[i].topY) {
                
                currentArea=areas[i].n;

                ///Door to other room (& blocking mechanism)
                doorTo(i);
                //console.log(areas[i].roomTo);

                if(areas[i].n!="default"){
                    inArea.inIt=true;
                    //alert("area");
                    inArea.whatArea=areas[i].n;
                 }else{
                    inArea.inIt=false;
                    inArea.whatArea=areas[i].n;
                }
                ///second level on same room
                transitionArea();
            }
        }  
        
        if(this.direction=="left"){

            if(newCenterX<=areas[i].rightX&&newCenterX>areas[i].leftX&&newCenterY<areas[i].bottomY&&newCenterY>=areas[i].topY) {
                
                currentArea=areas[i].n;

                ///Door to other room (& blocking mechanism)
                doorTo(i);

                if(areas[i].n!="default"){
                    inArea.inIt=true;
                    // alert("area");
                     inArea.whatArea=areas[i].n;
                 }else{
                    inArea.inIt=false;
                     inArea.whatArea=areas[i].n;
                }

                ///second level on same room
                transitionArea();
            }
        }   

        if(this.direction=="up"){
            //console.log(areasCrash);      


            if(newCenterY<=areas[i].bottomY&&newCenterY>areas[i].topY&&newCenterX>=areas[i].leftX&&newCenterX<areas[i].rightX) {

                    currentArea=areas[i].n;
                    ///Door to other room (& blocking mechanism)
                    doorTo(i);

                    if(areas[i].n!="default"){
                        inArea.inIt=true;
                        // alert("area");
                         inArea.whatArea=areas[i].n;
                    }else{
                        inArea.inIt=false;
                         inArea.whatArea=areas[i].n;
                    }
                ///second level on same room
                transitionArea();
            }
        }   
        if(this.direction=="down"){

            if(newCenterY<areas[i].bottomY&&newCenterY>=areas[i].topY&&newCenterX>areas[i].leftX&&newCenterX<=areas[i].rightX) {
                    currentArea=areas[i].n;

                    ///Door to other room (& blocking mechanism)
                    doorTo(i);

                if(areas[i].n!="default"){
                    inArea.inIt=true;
                    // alert("area");
                     inArea.whatArea=areas[i].n;
                }else{
                    inArea.inIt=false;
                     inArea.whatArea=areas[i].n;
                }
                ///second level on same room
                transitionArea();
            }

        }   

        if(this.direction=="right-down"){

            if(newCenterX<areas[i].rightX&&newCenterX>=areas[i].leftX&&newCenterY<=areas[i].bottomY&&newCenterY>areas[i].topY||newCenterY<areas[i].bottomY&&newCenterY>=areas[i].topY&&newCenterX>areas[i].leftX&&newCenterX<=areas[i].rightX) {

                    currentArea=areas[i].n;

                    ///Door to other room (& blocking mechanism)
                    doorTo(i);

                if(areas[i].n!="default"){
                    inArea.inIt=true;
                     inArea.whatArea=areas[i].n;
                }else{
                    inArea.inIt=false;
                     inArea.whatArea=areas[i].n;
                }
                ///second level on same room
                transitionArea();
            }

        } 

        if(this.direction=="left-down"){

            if(newCenterX<=areas[i].rightX&&newCenterX>areas[i].leftX&&newCenterY<areas[i].bottomY&&newCenterY>=areas[i].topY||newCenterY<areas[i].bottomY&&newCenterY>=areas[i].topY&&newCenterX>areas[i].leftX&&newCenterX<=areas[i].rightX) {
                    currentArea=areas[i].n;

                    ///Door to other room (& blocking mechanism)
                    doorTo(i);

                if(areas[i].n!="default"){
                    inArea.inIt=true;
                     inArea.whatArea=areas[i].n;
                }else{
                    inArea.inIt=false;
                     inArea.whatArea=areas[i].n;
                }
                ///second level on same room
                transitionArea();
            }

        }

    }

}


Player.prototype.animationState = function (dead, direction, animRate, moving) {

    //DIFFERENT ANIMATIONS WITH DIFF WEAPON




        //// Also keep track of what weapon is selected and move whole srcY of the sprite one down (where player is holding corresponging gun

            ////  +  in all rows include a Fighting mode for every direction (so it animates when shoting or punching)




        if(this.direction=="up"){
            this.srcX = 420;
            this.srcY = 0;

        }else if(this.direction=="down"){

            this.srcX = 0;
            animCount += animRate;
            if(animCount<2){
                
            }else if(animCount>0&&animCount<3){
                this.srcX=35;
            }else if(animCount>3&&animCount<6){
                this.srcX=70;
            }else if(animCount>6){
                this.srcX=0;
                animCount =0;
            }
            
        }

        if(this.shooting){
           animCount += animRate;
           

            if(this.facing=="down"){
                this.upperSrcX = 1680;

                if(animCount<2){
                    
                }else if(animCount>0&&animCount<3){
                   this.upperSrcX = 1715;
                }else if(animCount>3&&animCount<6){
                    this.upperSrcX = 1740;
                }else if(animCount>6){
                    this.upperSrcX = 1680;
                    animCount =0;
                }

            }else{
                this.upperSrcX = 1715;
            }
            
        }else{
            if(this.facing=="down"){
                    this.upperSrcX = 840;
                }else{
                    this.upperSrcX = 840;
                }
        }


}









 























    








//////////////////////////////////////  have another arguemtn for big and small, which applies when ammo != null
///////////////
function Item(x,y, xx, yy, w,h, itemType, itemNumber, selec, caught, branch, room) {   //// ALSO CURRENTROOM!!!!!!S for drawing purposes

////  this whole  item, gun, ammo >> 0, null, null... has to be changed to itemType >> "item", "gun", "ammo", "shield".....etc 
    ////                                        else I would have to be adding for every kind of 'non-selectable item' I come up

    /// need to add item ID though, to keep track of what type within that type (weapon 1, 2, 3...)


    //where in sprite
    this.srcX = x;
    this.srcY = y;
    //where in tileMap
    this.drawX = xx;
    this.drawY = yy;
    //in sprite with & height
    this.width = w;
    this.height =  h;
    this.centerX = this.drawX + (this.width / 2);
    this.centerY = this.drawY + (this.height / 2);

    this.itemType = itemType;
    this.itemNumber  =itemNumber;   //// 0 to 9 (+10 = special)     branch 0 = weak, branch 1, stronger.. etc.
                                ///         if selec (use) >> if ammoType == 1 >> (loop gunsMenu, if gunMenuType[i] == 1) >> gunsMenu.bullets += X
                                 //                            if ammoType == 10 >>  all gunMenu.bullets + X.... (or some mmore than others)    

    //this.lifeType = life; //// NOT NEEDED... LIFE CAN BE ITEMS THAT DO LIFE.... (very special)  >> the rest like Marathon
    //////////////                      special  stations scattered around the place which increase your life (method)

    this.select=selec;
    this.isCaught=caught;

    this.inRoom=room;
}


Item.prototype.update = function () {


    this.pickUp();

};










var menuItemAlreadyPainted=false;
var menuGunAlreadyPainted=false;




Item.prototype.draw = function () {


       
 




    var newCenterX = Math.round(this.drawX  + (this.width / 2)), /// this.drawX will have to be changed to (newItemDrawX when I start moving it.. maybe
    newCenterY = Math.round(this.drawY + (this.height / 2));
                                                                                                                      
    if(!this.isCaught){

    //alert(this.inRoom);
        
            ///  draw only the ones in that area
            if(!inArea.inIt||currentArea=="transition"){  
             ///////   unles there's also areas in level2
                //// then transition-areas, and area-areas  would have to be separated..


                if(currentRoom==this.inRoom){
            ////////////////////////////////////////                   30, 30 ==>>  tileDiameter changes >> this is  ACTUAL W/H IN SPRITE
                    ctxEntities.drawImage(itemSprite, this.srcX, this.srcY, 30, 30, this.drawX, this.drawY, tileDiameter, tileDiameter);
                }
            }else{

                for (var i = 0; i<areas.length; i++) {
                    if(newCenterX<areas[i].rightX&&newCenterX>=areas[i].leftX&&newCenterY<=areas[i].bottomY&&newCenterY>areas[i].topY){
                        if(areas[i].n!="default"){

                            // if areas[i].n == inArea.THE-EXACT-AREA 

                            /// DRAW  this only
                            //alert(inArea.whatArea);
                            if(inArea.whatArea == areas[i].n){
                                if(currentRoom==this.inRoom){
                                    ctxEntities.drawImage(itemSprite, this.srcX, this.srcY, 30, 30, this.drawX, this.drawY, this.width, this.height);
                                }
                            }

                            




                            //////  si inArea={inIt:true, whichOne:n}  >>
                                                                                
             ///  if player's position inArea >>> if(inArea.whichOne == areas[i].n)

                        }
                        
                    }
                };
            }//// IF item inArea

    
        }// IF   not-Caught


        //// inMenu DRAW

        //// OK, so if there is an Item already there.. keep itemAdding to the array, but only show the newst one (then in pause mode you can scroll and select other ones with the arrows)

        for (var i =0; i<3; i++) { ///// 3 Tracks

        
            if(i==0){
                if(player1.items[1]!=null&&player1.items[1]!="undefined"){
                        
                    if(!menuItemAlreadyPainted){

                        ctxMenu.clearRect(200,window.innerHeight-60,this.width,this.height);
      

                    for (var j = 0;j<player1.items.length; j ++) {
                           
                        
                        /// FOR  ROW>>> IT COULD BE INFINITE!    for player1.items  igual que en checkKey
                        if(itemRow==j){
                            if(typeof player1.items[j+1]!="undefined"){
                                ctxMenu.drawImage(itemSprite, player1.items[j+1].srcX, player1.items[j+1].srcY, 30, 30, 200, window.innerHeight-60, player1.items[j+1].width, player1.items[j+1].height);
                            }    
                        }
                    };
                    
                    menuItemAlreadyPainted=true;
                        ///// should be this.ICON >> diff image in game and inventory
                }
            } 
            
        }else if(i==1){
            if(player1.guns[1]!=null&&player1.guns[1]!="undefined"){

                if(!menuGunAlreadyPainted){
                        ctxMenu.clearRect(230,100,this.width,this.height);

                     for (var j = 0;j<player1.guns.length; j ++) {
                      
                        if(gunRow==j){
                            if(typeof player1.guns[j+1]!="undefined"){
                                ctxMenu.drawImage(itemSprite, player1.guns[j+1].srcX, player1.guns[j+1].srcY, 30, 30, 230, 100, player1.guns[j+1].width, player1.guns[j+1].height);
                            }
                        }
                    };
                    menuGunAlreadyPainted=true;
                        ///// should be this.ICON >> diff image in game and inventory
                }
            }
        }


   
}/// FOR  menuTrack

        
};



Item.prototype.pickUp = function(){

    //console.log(player1.items.length);
    var newCenterX = Math.round(newDrawX + (player1.width / 2)),
        newCenterY = Math.round(newDrawY + (player1.height / 2));
selecto();    

var itemAdd=false;
var noItemAdd=false;
var memberJ;

var gunAdd=false;
var noGunAdd=false;

player1.items[0]={srcX:this.srcX, srcY:this.srcY, width:this.width, height:this.height, selec:this.selec, itemType:null, itemNumber:0,lifeType:null,amount:0};

player1.guns[0]={srcX:this.srcX, srcY:this.srcY, width:this.width, height:this.height, selec:this.selec, itemType:null, itemNumber:0, lifeType:null,amount:0};

/////////////////
////  for some reason that I forgot, I need to set the first mnenu-items/weapon's  values here. 

///  it doesn't mattter since the first weapon in the game will always be 0. The problem comes when that's not the case.

if(newCenterX>this.centerX-this.width/2&&newCenterX<this.centerX+this.width/2&&newCenterY>this.centerY-this.height/2&&newCenterY<this.centerY+this.height/2){
       
    if(currentRoom==this.inRoom){
        if(!this.isCaught){

            this.isCaught=true;

            /// here sort whether player1.items has already got one item of this type...
                if(this.itemType=="item"){

                    for(var j=0; j<player1.items.length; j++){
                        if(player1.items.length==1){
                            itemAdd=true;

                        }else if(player1.items.length>1){
                          
                            if(this.itemNumber!=player1.items[j].itemNumber&&j!=0){
                               itemAdd=true;
                                
                            }else if(this.itemNumber==player1.items[j].itemNumber&&j!=0) {
                            
                              noItemAdd=true;   
                                 memberJ=j;  
                            }
                        }
                        
                    }

                    menuTrack=0;
                         
                  
                    console.log(this.itemType.toUpperCase());

                    ///diff stuff happens when grabbing diff category of "iTEMS"
                     
                }else if(this.itemType=="gun"){
                    menuTrack=1;
              
                    console.log("GUN");
                     
                }else if(this.itemType=="ammo"){
                    menuTrack=1;
     
                    console.log("AMMO");
                }
                ////  ... if not, push into a newly sortted array to tidily show items in menu
                /////  .. if yes, then 

                if(itemAdd&&!noItemAdd){  
                    itemRow=0;
                    if(player1.items.length<=1){
                        player1.items[0]={srcX:this.srcX, srcY:this.srcY, width:this.width, height:this.height, selec:this.selec, rowSelec:null, trackSelec:null, itemType:this.itemType, itemNumber:this.itemNumber, amount:1};   
                    }
                    player1.items.push({srcX:this.srcX, srcY:this.srcY, width:this.width, height:this.height, selec:this.selec, rowSelec:null, trackSelec:null, itemType:this.itemType, itemNumber:this.itemNumber, amount:1});   
  
                }else if(noItemAdd&&memberJ!="undefined"){

                    player1.items[memberJ].amount++;    ////////////  maybe set a limit to this amount (like secret of Mana's magic 4....)
                }

                noItemAdd=false;
                itemAdd=false;
               

            ///////////   GUN PICK-UP    
                //////
                if(this.itemType=="gun"&&this.inRoom==currentRoom){
                    for(var j=0; j<player1.guns.length; j++){

                    if(this.itemType=="gun"){

                            if(player1.guns.length==1){
                                gunAdd=true;

                            }else if(player1.guns.length>1){
                              
                                if(this.itemNumber!=player1.guns[j].itemNumber&&j!=0){
                                   gunAdd=true;
                                    
                                }else if(this.itemNumber==player1.guns[j].itemNumber&&j!=0) {
                                
                                    noGunAdd=true;  
                                }
                            }
                        }
                    }
                }                
                ////  ... if not, push into a newly sortted array to tidily show items in menu
                /////  .. if yes, then remember the player1.items.INDEX so as to increment its amount

                if(gunAdd&&!noGunAdd){
                    gunRow=0;

                    //alert(player1.guns.length);

                    if(player1.guns.length<=1){
                        //console.log("TYPE "+player1.guns[0].gunType);
                       player1.guns[0]={srcX:this.srcX, srcY:this.srcY, width:this.width, height:this.height, selec:this.selec, rowSelec:null, trackSelec:null,itemType:this.itemType, itemNumber:this.itemNumber, lifeType:this.lifeType, bullets:0};
                       //console.log("TYPE "+player1.guns[0].gunType);
                    }

                    player1.guns.push({srcX:this.srcX, srcY:this.srcY, width:this.width, height:this.height, selec:this.selec, rowSelec:null, trackSelec:null, itemType:this.itemType, itemNumber:this.itemNumber, lifeType:this.lifeType, bullets:0}); 
                     // console.log("TYPE "+player1.guns[1].gunType);
         ///if this.gunType = 1  player1.guns[player1.guns.length].bullets = "WHATEVER INICIAL LOAD FOR THAT WEAPON FIND<< thats:last one just added           
                }

                noGunAdd=false;
                gunAdd=false;



                if(this.itemType=="ammo"&&this.inRoom==currentRoom){


                    for (var i = 0; i<bullets.length; i++) {
                        if(this.itemNumber==i){
                            bullets[i]+=10;
                            //alert(bullets[i]);
                        }
                    }//for


                //     if(typeof player1.guns[0]!="undefined"){
                //         //alert(player1.guns.length);
                //     for (var i = 0; i<player1.guns.length; i++) {
                //         if(this.itemNumber==player1.guns[i].itemNumber){   ////////// this.itemNumber(1), player1.guns[i].itemNumber(1)
                //             console.log("ANTES "+player1.guns[i].bullets); ////// intended for weap 1, but what if I haven't got it yet????
                //             player1.guns[i].bullets+=10;         //// there should be an array keeping count of bullets, independent of weapons     
                //                                     /////////    Then when selecting weapon, it asks that array, matching numbers.


                //             /// ALSO HAVE DIFF TYPE OF AMMO, BIG & SMALL
                //             console.log( player1.guns[i].bullets);

                //             //console.log("DESPUES "+player1.guns[i].bullets);
                //         }
                //     }//for
                // }

                }           

///////////////////////////////////////////////////////////////////////////////////////////////////////


        }//// IF this caught
    
       }/// if this in room

        //console.log("DE ESTE "+player1.items[1].itemType+"HAY " +player1.items[1].amount); 



    }/// IF  newCenterX == itemCoordinates
   
}











///

//
//
//   FOR BULLETS, essentially, copy Player >> draw, direction, check crash (if some gunSelected), animate
//
//                  they are created (new Bullet) when shooting (take direction..etc, from player shooting)
