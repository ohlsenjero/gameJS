
var canvasBg = document.getElementById("canvasBg"),
	ctxBg = canvasBg.getContext("2d"),
	canvasDoors = document.getElementById("canvasDoors"),
	ctxDoors = canvasDoors.getContext("2d"),
	
	canvasPlayer = document.getElementById("canvasPlayer"),
	ctxPlayer = canvasPlayer.getContext("2d"),
	canvasBullets = document.getElementById("canvasBullets"),
	ctxBullets = canvasBullets.getContext("2d"),
	canvasOverlay = document.getElementById("canvasOverlay"),
	ctxOverlay = canvasOverlay.getContext("2d"),
	canvasEntities = document.getElementById("canvasEntities"),
	ctxEntities = canvasEntities.getContext("2d"),
	canvasPause = document.getElementById("canvasPause"),
	ctxPause = canvasPause.getContext("2d"),
	canvasMenu = document.getElementById("canvasMenu"),
	ctxMenu = canvasMenu.getContext("2d"),
	canvasMenuOver = document.getElementById("canvasMenuOver"),
	ctxMenuOver = canvasMenuOver.getContext("2d"),
	canvasMenuOver = document.getElementById("canvasMenuOverOver"),
	ctxMenuOverOver = canvasMenuOverOver.getContext("2d"),
	canvasMapOverMenu = document.getElementById("canvasMapOverMenu"),
	ctxMapOverMenu = canvasMapOverMenu.getContext("2d"),

	canvasOverOverlay = document.getElementById("canvasOverOverlay"),
	ctxOverOverlay = canvasOverOverlay.getContext("2d");
/////////////////////////////////////////////////////////////////////////



function clearCtx(ctx) {
	ctx.clearRect(0, 0, canvasWidth, canvasHeight);
}
// function randomRange (min, max) {
// 	return Math.floor(Math.random() * (max + 1 - min)) + min;
// }


//// FIXES game speed across different computers and processors 
var startTime = Date.now();
var gameSpeed=80;  ////  + == slower game 
/////  KEEP IN MIND whatever that may SLOW GAME DOWN >>> keep game at slowest is seen performing
// so then it doesn't suddenly speed up (when in an Area were Edges almost don't take place)

var then = startTime;
/// I don't know, it seems to make it faster than having startTime down there
///  maybe it doesn't have to calculate Date.now() twice, but gets it from a closer set of memory

//////////////////////////////////////////////////////////////////////////////////////////////////////

// PLAYER
var players=[1,2];

var enemies = [];


  /// dependent on controller input
var playerChoosing="player1";////////

///  upon choosing from the list at introScreen, VAR [#] is set, to later create new Player
var playerTypes = ["warrior", "warlock"]

var enemyTypes = ["blob"];


var playerFirstX=0;
var playerFirstY=0;

var playerShiftY =0;

var animCount = 0;
var animShootingCount = 0;

var tele=false;

var slowDown;
var slowDownDirection;


var dashCount=0;
var dash=false;

/// prevents moving right after Pause (from pressing while paused)
///	but brings it back so player can shoot without having to move first
var facingBeforePause=null;


///for diagonals
var latestKeys = []; 
///some dirty hack to fix something to do with direction, friction or something
// not quite sure, but keeping it just in case
var superLastKey=null;



//BULLETS
//// each weapon in its corresponding index  (rename to weaponBullets)
var bullets = [{current:0, max: 0},{current:44, max: 200},{current:10, max: 550}];  

/// active bullets (flying around and being updated)
var bulletsFired = []; 

/// porbably not necessary, but in case, keeping bullets separate and identifiable
var bulletID=0;



//// GAME MENU
var daMenu = new menu(700, 600, canvasBg.width, canvasBg.heigth, 0, 0);/// doesnt need any of this params

var menuHeight =100;

var menuAnimCount=0;

/// Position in Menu
var menuTrack=1;  // starts with 1 gun >> no item
var itemRow=0;
var gunRow=0;

/// flashy details in manu >>>  for when first picking a type of Item of Gun
var pickingGun = false;
var pickingGunCount=0;
var pickingItem = false;
var pickingItemCount=0;

////  >>>>  1 button for gun, another for item
///  while other item spermanently do/change something in the game/player 

/// All items before being picked (includes items, weapons, ammo and life)
var items = [];



///  PLAYER LOCATION
var currentRoom;
var currentLevel;

var currentArea;
var currentSubArea;

var nextRoom;
///when changing rooms, so you can't shoot while facing nowhere (frozen bullet on screen)
var blockInput = false;


////////////////////////////////////////////////////////////////////////////////////////////////////


///Playing || Paused
var isPlaying = false;

var paused = false;

var pauseType="gamePause";
var pausedRoomChangeLoop=false;
var pauseCount= 0;


///LOOP ENGINE
var requestAnimFrame =  window.requestAnimationFrame ||
						window.webkitRequestAnimationFrame ||
						window.mozRequestAnimationFrame ||
						window.oRequestAnimationFrame ||
						window.msRequestAnimationFrame ||

						function(callback) {
							window.setTimeout(callback, 1000 / 1);
						};

////////////////////////////////////////////////////////////////



/// WORLD essential tile-types
///doors, obstacles, areas..
var obstacles = [];
var areas= [];
var doorTiles = [];
var doors=[];

var pendingClose = [];

// DOORS
var ID;   


var doorBlock =false;
var blockedDoorIndex =[];

var inActiveObstacle = [];

var inDoorCrash={crash:false, id:0};

var inArea={inIt:false, whatArea:currentArea};

var doorKeys = [{id:403, key:100}, {id:428, key:101}];

var key1;



/// WORLD TILES +
var mapObsL1;

var canvasWidth;
var canvasHeight;

var shiftX=0;
var shiftY=0;


///TILE SIZE
var tileDiameter; 

if(window.innerWidth>1000){
	tileDiameter = 64;  // >>>> cambiar segun tamanho de pantalla
}else{
	tileDiameter = 64; /// mmm, maybe not..
}


var flash=0;




var weapon1SFX = new Audio("audio/weapon1.wav");

var weapon2SFX = new Audio("audio/weapon2.wav");

var weapon2explodeSFX = new Audio("audio/weapon2explode.wav");

var weapon2explodeWaterSFX = new Audio("audio/weapon2explode-water.wav");

var weaponGrabSFX = new Audio("audio/weapon-grab.wav");

var pickingItemSFX = new Audio("audio/picking-item.wav");

var nonSelectSFX = new Audio("audio/non-select.wav");

var orbSFX = new Audio("audio/orb.wav");

var keySFX = new Audio("audio/key.wav");

var itemUseSFX = new Audio("audio/item-use.wav");

var healthRefillSFX = new Audio("audio/health-refill.wav");

var blockDestroySFX = new Audio("audio/block-destroy.wav");


var elecDamageSFX = new Audio("audio/elec-damage.wav");

var pauseSFX = new Audio("audio/pause.wav");


var doorOpenSFX = new Audio("audio/door-open.wav");
var doorCloseSFX = new Audio("audio/door-close.wav");

var poweroffSFX = new Audio("audio/poweroff.wav");

var doorShutSFX = new Audio("audio/door-shut.wav");



/// ROOM TILE MAPS !!!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

function whatRoomMap(map){
/// 010|020 translate to 1|2,  unless turned to strings
///  and using them as strings here makes the map less readable >>> 000 ommited


/////                                      					 r   o   o   m     1
	/// first: the basic layout and tile definition
	if(map=="room-1"){
		return  [333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,333,333,339,100,100,100,100,333,333,333,333,333,333,333,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,391,391,391,391,391,391,391,391,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,333,339,100,100,100,100,100,338,333,333,333,333,333,333,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,391,391,391,391,391,391,391,391,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,339,100,100,100,100,100,100,100,338,333,333,333,335,333,100,100,100,100,100,100,100,333,333,333,333,333,333,333,391,391,391,102,100,100,100,333,333,333,391,391,391,391,391,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,333,300,300,335,333,100,100,100,100,100,100,333,333,333,333,333,333,333,333,391,391,391,102,100,100,100,100,333,333,333,391,391,391,391,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,338,333,333,333,333,333,333,333,333,333,333,333,333,100,102,100,102,102,102,391,391,391,102,100,100,100,100,100,333,333,391,391,391,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,338,333,333,333,333,333,333,333,100,100,100,100,100,100,100,102,102,391,391,102,102,102,100,100,100,100,100,100,100,391,391,391,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,390,100,100,100,100,100,100,100,333,333,333,333,333,333,333,100,100,100,100,100,100,100,102,104,391,102,102,100,100,100,100,100,100,100,100,100,391,391,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,338,333,333,333,333,333,333,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,102,102,104,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,102,100,100,100,100,100,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,102,100,100,100,100,100,100,100,100,100,100,100,100,100,102,102,391,391,102,102,102,100,100,100,100,100,100,100,100,100,102,102,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,102,100,100,100,100,100,100,100,100,100,100,100,100,100,102,104,391,102,102,100,100,100,100,100,100,100,100,100,100,100,102,102,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,333,333,100,100,100,100,100,100,100,100,100,102,100,100,100,100,100,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,102,102,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,333,333,333,333,100,100,100,100,337,333,100,102,100,100,100,100,100,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,333,333,333,333,333,333,333,333,333,333,100,102,100,100,100,100,100,100,100,100,100,100,100,100,100,102,102,391,391,102,102,102,100,100,100,102,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,333,333,333,333,333,333,333,333,335,333,100,102,100,100,100,100,100,100,100,100,100,100,100,100,100,102,104,391,102,102,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,333,333,333,333,333,333,333,300,300,333,333,102,100,100,100,100,100,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,102,102,102,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,333,333,333,333,333,333,300,300,335,333,333,102,100,100,100,100,100,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,333,333,333,333,333,333,300,335,335,333,100,102,100,100,100,100,100,100,100,100,100,100,100,100,100,102,102,391,391,102,102,102,100,100,100,102,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,333,333,333,333,333,333,335,335,333,333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,102,104,391,102,102,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,333,333,333,333,333,333,335,333,333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,102,102,102,100,102,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,333,334,334,333,333,333,333,333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,102,102,391,391,102,102,102,100,100,100,102,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,334,240,240,100,333,339,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,102,104,391,102,102,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,240,240,333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,102,102,102,102,102,333,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,240,240,339,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,335,100,102,102,391,391,102,102,102,100,100,100,102,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,240,333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,102,104,391,102,102,100,100,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,240,333,333,333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,104,391,391,102,102,102,100,100,100,100,100,100,100,100,100,100,333,333,334,334,334,334,334,334,334,334,334,333,333,333,333,333,333,333,
				 333,240,333,333,333,333,100,100,100,100,100,100,100,100,100,100,100,100,337,306,306,333,333,100,100,102,102,102,391,102,102,100,100,100,100,100,100,100,100,100,100,100,100,333,333,240,240,240,240,240,240,240,240,240,334,333,333,333,333,333,333,
				 333,240,333,333,333,333,333,100,100,100,100,100,100,100,100,100,100,337,333,323,323,333,333,100,100,102,102,102,102,391,102,100,100,100,100,100,100,100,100,335,335,100,100,335,333,240,333,333,333,333,333,333,240,240,240,334,334,100,100,333,333,
				 333,240,334,334,334,334,333,100,100,100,100,100,100,100,100,100,337,333,333,320,320,320,320,333,102,104,102,102,102,100,100,100,102,100,100,100,100,100,104,370,100,100,100,333,335,240,333,333,333,333,333,333,240,240,240,240,240,100,100,333,333,
				 333,240,240,240,240,240,333,333,100,100,100,100,100,100,100,337,335,335,333,221,221,221,221,333,335,390,390,390,390,100,102,102,102,100,100,100,100,371,104,104,100,371,100,333,335,100,100,100,333,333,333,333,333,333,333,333,333,100,100,333,333,
				 333,333,335,335,240,240,333,333,100,100,100,100,100,100,100,337,337,100,333,221,221,221,221,335,335,390,390,390,390,390,100,100,100,100,100,100,100,100,100,100,104,100,100,333,100,100,333,371,333,333,333,333,333,333,333,333,333,100,100,333,333,
				 333,100,100,335,240,240,333,333,100,100,100,100,100,100,100,100,100,100,333,221,221,333,333,333,100,100,100,104,102,390,390,102,102,100,100,100,100,100,102,335,100,100,371,100,100,333,333,102,102,102,333,333,333,333,333,333,333,100,100,333,333,
				 333,100,100,333,240,240,333,333,333,100,100,100,100,962,965,965,965,961,333,220,220,333,333,390,100,100,104,104,100,390,390,100,100,100,341,306,340,102,102,371,100,100,335,333,335,333,333,102,702,102,333,333,333,333,334,333,333,333,100,333,333,
				 333,100,333,333,240,240,333,333,333,333,100,100,100,967,960,740,960,968,333,220,220,333,102,390,390,100,104,104,391,390,390,341,306,306,306,333,333,100,100,100,335,100,335,333,333,333,333,102,102,333,333,333,333,333,333,334,333,333,247,333,333,
				 333,333,333,333,240,240,333,333,333,333,333,333,333,964,960,960,960,963,333,220,220,333,102,390,390,390,100,104,391,390,390,306,306,342,333,333,306,340,102,100,100,104,335,335,333,333,333,103,103,333,333,333,333,333,333,333,333,333,247,333,333,
				 333,333,333,333,240,240,333,333,333,306,306,333,333,306,306,306,306,306,333,220,220,333,100,100,306,306,100,104,104,391,391,306,342,333,339,100,306,333,333,100,371,371,371,371,335,333,333,333,333,333,333,333,333,333,333,333,333,333,247,333,333,
				 333,333,333,333,240,240,333,333,333,333,306,306,306,333,333,333,333,333,333,220,220,333,100,100,333,333,102,104,104,104,391,306,333,339,100,100,333,100,100,100,100,100,104,371,335,336,336,336,336,336,336,336,336,336,336,336,333,333,247,333,333,
				 333,333,333,333,240,240,333,333,333,333,333,333,306,306,333,333,333,333,333,220,306,306,306,333,306,333,102,104,104,102,102,306,333,100,100,100,428,100,100,100,100,100,100,371,371,247,247,247,247,247,247,247,247,247,247,247,333,333,247,333,333,
				 333,333,333,333,100,100,333,333,333,333,333,333,333,333,333,100,100,102,333,220,321,320,320,320,306,333,104,100,104,341,306,306,333,102,100,341,306,306,340,100,100,333,335,335,335,333,333,333,333,333,333,333,333,333,333,247,333,333,247,333,333,
				 333,333,100,100,100,100,333,333,333,333,100,100,391,391,391,391,391,102,333,227,220,220,220,220,306,104,104,102,104,306,306,306,339,102,100,306,306,306,306,306,306,306,306,306,306,306,306,333,333,333,333,333,333,333,333,247,334,334,247,333,333,
				 333,100,100,100,100,100,100,100,333,100,100,100,333,333,333,333,391,333,333,227,227,220,333,230,306,107,107,102,102,333,333,333,107,107,100,333,333,333,306,306,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,247,247,247,247,333,333,
				 333,100,100,100,100,100,100,100,333,100,100,100,333,100,100,333,391,333,333,114,227,333,333,456,320,578,578,306,306,333,333,333,109,109,306,306,333,306,333,333,333,333,333,306,100,100,986,987,987,987,987,987,987,987,987,333,247,247,247,333,333,
				 333,100,100,100,100,100,100,100,333,333,100,100,333,100,100,333,391,333,333,113,114,333,333,456,320,578,578,333,306,306,306,306,572,572,306,306,306,333,333,333,333,333,306,333,100,987,986,987,987,987,987,987,987,986,986,333,247,247,247,333,333,
				 333,100,100,100,100,100,100,100,100,333,333,333,333,100,100,333,391,333,333,391,113,334,320,220,220,227,227,333,333,300,300,300,572,572,306,306,306,333,333,333,333,333,333,100,986,986,986,987,987,987,987,987,987,986,987,333,247,247,247,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,333,100,100,333,391,333,333,391,391,100,512,220,220,227,113,333,334,300,300,302,200,200,306,306,333,986,986,986,100,100,100,986,986,987,986,986,986,986,987,986,986,986,987,333,247,247,247,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,391,391,391,391,391,100,512,220,227,113,102,100,102,401,200,200,200,200,301,300,334,986,987,987,986,100,100,986,986,987,987,986,987,986,986,986,986,987,987,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,336,336,336,391,391,102,333,333,333,102,102,100,102,306,306,333,207,207,200,402,100,986,986,986,986,986,986,986,986,987,987,986,987,987,987,987,986,986,986,987,987,987,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,333,333,391,391,102,100,102,100,102,100,100,102,333,333,333,210,210,333,306,306,306,306,306,306,306,306,987,987,987,987,986,987,333,333,333,986,986,986,987,987,987,987,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,967,960,960,965,965,965,961,306,100,102,333,333,333,573,573,333,333,333,333,333,333,333,306,306,987,987,987,987,986,987,333,333,333,986,306,306,987,987,987,987,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,967,960,960,960,960,960,960,333,306,102,333,333,333,573,573,333,333,306,306,306,333,333,333,333,306,987,987,987,986,986,333,987,987,986,306,306,987,987,987,987,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,967,960,960,960,960,960,968,333,333,102,102,333,333,100,100,100,100,250,250,250,333,333,333,333,333,333,987,987,987,986,986,987,306,306,306,333,333,333,987,987,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,967,960,960,960,960,960,960,965,961,102,102,306,333,100,100,100,100,335,250,250,333,333,333,333,333,333,333,333,987,987,306,986,333,333,333,333,333,333,987,986,333,333, 
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,333,967,960,960,960,960,960,960,306,968,100,306,306,306,306,102,100,100,333,257,257,333,306,306,306,306,306,306,306,306,306,333,986,986,333,333,333,987,987,987,986,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,960,960,960,960,960,960,960,960,306,971,333,306,306,333,333,333,306,306,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,986,986,986,986,987,987,987,986,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,333,100,100,100,960,960,960,960,960,960,960,306,970,969,333,333,333,333,333,333,306,100,100,333,333,333,333,306,333,333,333,333,333,333,333,333,333,333,333,333,333,986,986,986,986,986,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,333,100,100,100,100,960,960,960,960,960,960,968,333,970,972,960,960,961,333,333,333,333,100,100,333,333,306,333,333,333,333,333,333,333,306,333,333,333,333,333,333,333,333,986,986,986,986,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,960,960,960,960,960,960,960,306,306,306,306,306,960,960,968,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,960,960,960,960,960,306,306,333,333,306,333,333,306,964,968,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,960,100,960,960,306,306,306,306,333,333,333,333,333,333,306,306,960,961,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,960,960,306,306,333,333,333,333,333,333,333,333,333,333,306,960,968,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,960,333,333,333,333,333,333,333,333,333,333,333,333,333,964,963,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,306,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,100,150,150,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,100,150,150,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333];


	/// second floor >>> swap after hitting "transition" area
	}else if(map=="room-1L2"){
		return  [333,100,100,100,100,100,333,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,102,100,102,102,102,391,391,391,102,100,100,100,333,333,333,333,306,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,100,100,100,100,100,100,100,102,102,391,391,102,102,102,100,100,100,391,391,391,391,391,391,391,391,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,100,100,100,100,100,100,100,102,104,391,102,102,100,100,100,100,100,100,391,391,391,391,391,391,391,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,102,102,391,391,391,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,100,100,100,100,100,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,102,100,102,102,102,391,391,391,102,100,100,100,333,333,333,333,306,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,100,100,100,100,100,100,100,102,102,391,391,102,102,102,100,100,100,391,391,391,391,391,391,391,391,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,100,100,100,100,100,100,100,102,104,391,102,102,100,100,100,100,100,100,391,391,391,391,391,391,391,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,102,102,391,391,391,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,100,100,100,100,100,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,102,100,102,102,102,391,391,391,102,100,100,100,333,333,333,333,306,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,100,100,100,100,100,100,100,102,102,391,391,102,102,102,100,100,100,391,391,391,391,391,391,391,391,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,100,100,100,100,100,100,100,102,104,391,102,102,100,100,100,100,100,100,391,391,391,391,391,391,391,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,102,102,391,391,391,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,100,100,100,100,100,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,100,100,100,100,100,100,100,102,102,391,391,102,102,102,100,100,100,102,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,100,100,100,100,100,100,100,102,104,391,102,102,100,100,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,102,102,102,100,102,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,100,100,100,100,100,100,100,102,102,391,391,102,102,102,100,100,100,102,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,100,100,100,100,100,100,100,102,104,391,102,102,100,100,100,100,100,100,100,100,100,100,668,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,102,102,102,100,102,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,100,100,100,100,100,100,100,102,102,391,391,102,102,102,100,100,100,102,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,100,100,100,100,100,100,100,102,104,391,102,102,100,100,100,100,100,100,100,100,100,100,102,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,102,102,102,102,102,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,100,100,100,100,100,335,100,102,102,391,391,102,102,102,100,100,100,102,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,107,107,100,100,100,333,333,102,104,391,102,102,100,100,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,100,221,221,333,100,100,100,100,100,104,391,391,102,102,102,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,220,220,333,333,100,100,102,102,102,391,102,102,100,100,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,323,323,333,102,100,100,102,102,102,102,391,102,100,100,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,320,320,320,320,333,102,104,102,102,102,100,100,100,102,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,221,221,221,221,333,335,390,390,390,390,390,102,102,102,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,221,221,221,221,306,335,390,390,390,390,390,390,100,100,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,221,221,333,333,333,100,100,100,104,390,390,390,102,102,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,220,220,333,333,100,100,100,104,104,390,390,390,100,100,100,100,306,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,220,220,333,102,100,100,100,104,104,391,390,390,306,306,306,306,333,333,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,220,220,333,102,102,100,100,100,104,391,390,390,306,333,333,333,333,333,333,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,700,220,333,102,102,306,306,100,104,104,391,391,306,333,100,740,100,306,333,333,100,333,333,371,371,306,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,220,220,333,102,100,333,333,102,104,104,104,391,306,333,100,100,100,333,100,100,100,100,100,100,371,371,306,306,334,334,334,334,334,334,334,334,334,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,220,306,306,306,306,306,333,102,104,104,102,102,306,333,100,100,100,428,100,100,100,100,100,100,370,371,247,247,247,247,247,247,247,247,247,247,247,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,220,321,320,320,320,306,333,104,100,104,306,306,306,333,102,100,306,306,306,100,100,100,100,100,371,333,306,306,333,333,333,333,333,333,333,333,247,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,227,220,220,220,220,306,104,104,102,104,306,306,306,333,102,100,306,306,306,306,306,306,306,306,306,306,306,306,306,333,333,333,333,333,333,333,247,334,334,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,227,227,220,333,230,306,107,107,102,102,333,333,333,107,107,100,333,333,333,306,306,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,247,247,247,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,391,100,333,114,227,333,333,456,320,578,578,306,306,333,333,333,109,109,109,109,333,306,333,333,333,333,333,306,100,100,986,987,987,987,987,987,987,987,987,333,247,247,334,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,391,100,333,113,114,333,333,456,320,578,578,333,306,306,306,306,572,572,306,306,306,333,333,333,333,333,306,333,100,987,986,987,987,987,987,987,987,986,986,333,247,247,247,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,391,100,333,391,113,334,320,220,220,227,227,333,333,300,300,300,572,572,306,306,306,333,333,333,333,333,333,100,986,986,986,987,987,987,987,987,987,986,987,333,247,247,247,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,391,100,333,391,391,100,512,220,220,227,113,333,333,300,300,302,200,200,306,306,333,986,986,986,100,100,100,986,986,987,986,986,986,986,987,986,986,986,987,333,247,247,247,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,391,391,391,391,391,100,512,220,333,113,102,100,102,401,200,200,200,200,301,300,334,986,987,987,986,100,100,986,986,987,987,987,987,986,986,986,986,987,987,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,391,391,102,333,333,333,102,102,100,102,306,306,333,207,207,200,402,100,986,986,986,986,986,986,986,986,987,987,987,987,987,987,987,986,986,986,100,100,102,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,391,391,102,100,102,100,102,100,100,102,333,333,333,210,210,333,306,306,306,306,306,306,306,306,306,306,306,306,306,333,333,333,333,333,333,333,100,102,102,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,702,102,962,965,965,965,961,306,100,102,333,333,333,573,573,333,333,333,333,333,333,333,306,306,306,333,333,333,333,333,333,333,333,333,333,333,333,102,102,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,104,102,967,960,960,960,960,333,306,102,333,333,333,573,573,333,333,306,306,306,333,333,333,333,306,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,984,102,967,960,960,960,968,333,333,102,102,333,333,100,100,100,100,306,306,306,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,984,980,967,960,960,960,960,965,961,102,102,306,333,100,100,100,100,333,306,306,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333, 
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,984,980,964,960,960,960,960,306,968,100,306,306,306,306,102,100,100,333,333,333,333,306,306,306,306,306,306,306,306,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,981,984,983,980,964,966,306,971,333,306,306,333,333,333,306,306,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,981,980,984,983,980,980,306,970,969,333,333,333,333,333,333,306,100,100,333,333,333,333,306,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,981,984,984,984,104,980,333,970,972,960,960,961,333,333,333,333,100,100,333,333,306,333,333,333,333,333,333,333,306,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,104,104,104,104,104,104,306,306,306,306,306,960,960,968,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,104,104,104,104,306,306,333,333,306,333,333,306,964,968,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,306,306,306,306,306,333,333,333,333,333,333,306,306,960,961,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,306,306,333,333,333,333,333,333,333,333,333,333,306,960,968,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,964,963,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,306,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,100,150,150,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,100,150,150,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333];


 	/// then: what the tiles look like (independent of what they might be)
	}else if(map=="room-1Over"){
		return  [333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,333,333,339,100,100,100,355,333,333,333,333,333,333,333,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,391,391,391,391,391,391,391,391,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,333,339,100,100,100,100,100,338,333,333,333,333,333,333,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,391,391,391,391,391,391,391,391,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,339,100,100,100,100,100,100,100,338,333,333,333,335,333,100,100,100,100,100,100,100,333,333,333,333,333,333,333,391,391,391,102,100,100,100,333,333,333,391,391,391,391,391,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,333,300,300,335,333,100,100,100,100,100,100,333,333,333,333,333,333,333,333,391,391,391,102,100,100,100,100,333,333,333,391,391,391,391,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,338,333,333,333,333,333,333,333,333,333,333,333,337,100,102,100,102,102,102,391,391,391,102,100,100,100,100,100,333,333,391,391,391,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,338,333,333,333,333,333,333,333,355,100,100,100,100,100,100,102,102,391,391,102,102,102,100,100,100,100,100,100,100,391,391,391,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,390,100,100,100,100,100,100,100,333,333,333,333,333,333,333,100,100,100,100,100,100,100,102,104,391,102,102,100,100,100,100,100,100,100,100,100,391,391,391,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,338,333,333,333,333,333,339,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,102,102,104,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,355,337,339,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,102,100,100,100,102,100,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,102,100,100,100,100,100,100,100,100,100,100,100,100,100,102,102,391,391,102,102,102,100,100,100,100,100,100,100,100,100,102,102,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,102,100,100,100,100,100,100,100,100,100,100,100,100,100,102,104,391,102,102,100,100,100,100,100,100,100,100,100,100,100,102,102,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,333,333,100,100,100,100,100,100,100,100,100,102,100,100,100,100,100,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,102,102,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,333,333,333,333,100,100,100,100,337,333,100,102,100,100,100,100,100,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,333,333,333,333,333,333,333,333,333,333,100,102,100,100,100,100,100,100,100,100,100,100,100,100,100,102,102,391,391,102,102,102,100,100,100,102,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,333,333,333,333,333,333,333,333,335,333,100,102,100,100,100,100,100,100,100,100,100,100,100,100,100,102,104,391,102,102,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,333,333,333,333,333,333,333,300,300,333,333,102,100,100,100,100,100,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,102,102,102,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,333,333,333,333,333,333,300,300,335,333,333,102,100,100,100,100,100,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,333,333,333,333,333,333,300,335,335,333,100,102,100,100,100,100,100,100,100,100,100,100,100,100,100,102,102,391,391,102,102,102,100,100,100,102,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,333,333,333,333,333,333,335,335,333,337,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,102,104,391,102,102,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,333,333,333,333,333,333,335,333,339,100,100,100,100,100,100,100,100,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,102,102,102,100,102,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,333,334,334,333,333,333,333,339,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,102,102,391,391,102,102,102,100,100,100,102,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,334,240,240,100,333,339,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,102,104,391,102,102,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,240,240,335,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,102,100,102,102,102,391,391,391,102,100,100,100,102,102,102,102,102,333,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,240,240,339,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,335,100,102,102,391,391,102,102,102,100,100,100,102,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,240,333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,102,104,391,102,102,100,100,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,240,333,333,333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,104,391,391,102,102,102,100,100,100,100,100,100,100,100,100,100,333,333,334,334,334,334,334,334,334,334,334,333,333,333,333,333,333,333,
				 333,240,333,333,333,333,100,100,100,100,100,100,100,100,100,100,100,100,337,306,306,333,333,100,100,102,102,102,391,102,102,100,100,100,100,100,100,100,100,100,100,100,100,333,333,240,240,240,240,240,240,240,240,240,334,333,333,333,333,333,333,
				 333,240,333,333,333,333,333,100,100,100,100,100,100,100,100,100,100,337,333,323,323,333,333,100,100,102,102,102,102,391,102,100,100,100,100,100,100,100,100,335,335,100,100,335,333,240,333,333,333,333,333,333,240,240,240,334,334,100,100,333,333,
				 333,240,334,334,334,334,333,100,100,100,100,100,100,100,100,100,337,333,333,320,320,320,320,333,102,104,102,102,102,100,100,100,102,100,100,100,100,100,104,370,100,100,100,333,335,240,333,333,333,333,333,333,240,240,240,240,240,100,100,333,333,
				 333,240,240,240,240,240,333,333,100,100,100,100,100,100,100,337,335,335,333,221,221,221,221,333,335,390,390,390,390,100,102,102,102,100,100,100,100,371,104,104,100,371,100,333,335,100,100,100,333,333,333,333,333,333,333,333,333,100,100,333,333,
				 333,333,335,335,240,240,333,333,100,100,100,100,100,100,100,337,337,100,333,221,221,221,221,335,335,390,390,390,390,390,100,100,100,100,100,100,100,100,100,100,104,100,100,333,100,100,333,371,333,333,333,333,333,333,333,333,333,100,100,333,333,
				 333,100,100,335,240,240,333,333,100,100,100,100,100,100,100,100,100,100,333,221,221,333,333,333,100,100,100,104,102,390,390,102,102,100,100,100,100,100,102,335,100,100,371,100,100,333,333,102,102,102,333,333,333,333,333,333,333,100,100,333,333,
				 333,100,100,333,240,240,333,333,333,100,100,100,100,962,965,965,965,961,333,220,220,333,333,390,100,100,104,104,100,390,390,100,100,100,341,306,340,102,102,371,100,100,335,333,335,333,333,102,702,102,333,333,333,333,334,333,333,333,100,333,333,
				 333,100,333,333,240,240,333,333,333,333,100,100,100,967,960,960,960,968,333,220,220,333,102,390,390,100,104,104,391,390,390,341,306,306,306,333,333,100,100,100,335,100,335,333,333,333,333,102,102,333,333,333,333,333,333,334,333,333,247,333,333,
				 333,333,333,333,240,240,333,333,333,333,333,333,333,964,960,960,960,963,333,220,220,333,102,390,390,390,100,104,391,390,390,306,306,342,333,333,306,340,102,100,100,104,335,335,333,333,333,103,103,333,333,333,333,333,333,333,333,333,247,333,333,
				 333,333,333,333,240,240,333,333,333,306,306,333,333,306,306,306,306,306,333,220,220,333,100,100,306,306,100,104,104,391,391,306,342,344,339,100,306,333,333,100,371,371,371,371,335,333,333,333,333,333,333,333,333,333,333,333,333,333,247,333,333,
				 333,333,333,333,240,240,333,333,333,333,306,306,306,333,333,333,333,333,333,220,220,333,100,100,333,333,102,104,104,104,391,306,333,339,100,100,333,100,100,100,100,100,104,371,335,336,336,336,336,336,336,336,336,336,336,336,333,333,247,333,333,
				 333,333,333,333,240,240,333,333,333,333,333,333,306,306,333,333,333,333,333,220,306,306,306,333,306,333,102,104,104,102,102,306,333,100,100,100,428,100,100,100,100,100,100,371,371,247,247,247,247,247,247,247,247,247,247,247,333,333,247,333,333,
				 333,333,333,333,100,100,333,333,333,333,333,333,333,333,333,100,100,102,333,220,321,320,320,320,306,333,104,100,104,341,306,306,333,102,100,341,306,306,340,100,100,333,335,306,306,333,333,333,333,333,333,333,333,333,333,247,333,333,247,333,333,
				 333,333,100,100,100,100,333,333,333,333,100,100,391,391,391,391,391,102,333,227,220,220,220,220,306,104,104,102,104,306,306,306,339,102,100,306,306,306,306,306,306,306,306,306,306,306,306,333,333,333,333,333,333,333,333,247,334,334,247,333,333,
				 333,100,100,100,100,100,100,100,333,100,100,100,333,333,333,333,391,333,333,227,227,220,333,230,306,107,107,102,102,343,306,306,107,107,100,333,333,333,306,306,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,247,247,247,247,333,333,
				 333,100,100,100,100,100,100,100,333,100,100,100,333,100,100,333,391,333,333,114,227,333,333,456,320,578,578,306,306,306,306,306,109,109,306,306,333,306,333,333,333,333,333,306,100,100,986,987,987,987,987,987,987,987,987,333,247,247,247,333,333,
				 333,100,100,100,100,100,100,100,333,333,100,100,333,100,100,333,391,333,333,113,114,333,333,456,320,578,578,333,306,306,306,306,572,572,306,306,306,333,333,333,333,333,306,333,100,987,986,987,987,987,987,987,987,986,986,333,247,247,247,333,333,
				 333,100,100,100,100,100,100,100,100,333,333,333,333,100,100,333,391,333,333,391,113,334,320,220,220,227,227,333,333,300,300,300,572,572,306,306,306,333,333,333,333,333,333,100,986,986,986,987,987,987,987,987,987,986,987,333,247,247,247,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,333,100,100,333,391,333,333,391,391,100,512,220,220,227,113,333,334,306,300,302,200,200,306,306,333,986,986,986,100,100,100,986,986,987,986,986,986,986,987,986,986,986,987,333,247,247,247,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,391,391,391,391,391,100,512,220,227,113,102,100,102,401,200,200,200,200,301,300,334,986,987,987,986,100,100,986,986,987,987,986,987,986,986,986,986,987,987,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,336,336,336,391,391,102,333,333,333,102,102,100,102,306,306,334,207,207,207,402,100,986,986,986,986,986,986,986,986,987,987,986,987,987,987,987,986,986,986,987,987,987,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,333,333,391,391,102,100,102,100,102,100,100,102,333,333,333,210,210,344,344,306,306,306,306,306,306,306,987,987,987,987,986,987,333,333,333,986,986,986,987,987,987,987,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,967,960,960,965,965,965,961,306,100,102,333,333,333,573,573,333,333,333,333,333,333,333,306,306,987,987,987,987,986,987,333,333,333,986,306,306,987,987,987,987,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,967,960,960,960,960,960,960,333,306,102,333,333,333,573,573,333,333,350,350,350,333,333,333,333,306,987,987,987,986,986,333,987,987,986,306,306,987,987,987,987,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,967,960,960,960,960,960,968,333,333,102,102,333,333,100,100,100,100,257,257,257,333,333,333,333,333,333,987,987,987,986,986,987,306,306,306,333,333,333,987,987,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,967,960,960,960,960,960,960,965,961,102,102,306,333,100,100,100,100,335,257,257,333,333,333,333,333,333,333,333,987,987,306,986,333,333,333,333,333,333,987,986,333,333, 
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,333,967,960,960,960,960,960,960,306,968,100,306,306,306,306,102,100,100,333,250,250,333,306,306,306,306,306,306,306,306,306,333,986,986,333,333,333,987,987,987,986,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,960,960,960,960,960,960,960,960,306,971,333,306,306,333,333,333,306,306,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,986,986,986,986,987,987,987,986,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,333,100,100,100,960,960,960,960,960,960,960,306,970,969,333,333,333,333,333,333,306,100,100,333,333,333,333,306,333,333,333,333,333,333,333,333,333,333,333,333,333,986,986,986,986,986,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,333,100,100,100,100,960,960,960,960,960,960,968,333,970,972,960,960,961,333,333,333,333,100,100,333,333,306,333,333,333,333,333,333,333,306,333,333,333,333,333,333,333,333,986,986,986,986,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,960,960,960,960,960,960,960,306,306,306,306,306,960,960,968,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,960,960,960,960,960,306,306,333,333,306,333,333,306,964,968,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,960,100,960,960,306,306,306,306,333,333,333,333,333,333,306,306,960,961,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,960,960,306,306,333,333,333,333,333,333,333,333,333,333,306,960,968,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,960,333,333,333,333,333,333,333,333,333,333,333,333,333,964,963,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,306,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,100,150,150,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,100,150,150,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,
				 333,100,100,100,100,100,333,100,100,100,100,100,333,100,100,100,100,100,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333,333];







	/////                                       r   o   o   m     2

	}else if(map=="room-2"){
		return  [333,333,333,333,333,333,333,333,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,985,703,
				 335,701,100,100,100,100,100,306,982,983,983,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,985,985,985,985,247,
				 335,100,100,306,100,306,100,306,981,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,985,247,247,247,247,
				 335,100,100,333,306,333,100,333,981,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,985,985,985,985,985,985,985,985,985,985,985,985,247,333,333,333,
				 333,102,306,333,333,100,100,333,981,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,333,333,333,333,333,985,985,985,985,985,247,247,247,333,984,984,
				 333,102,333,333,100,100,306,306,981,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,333,247,247,247,333,985,985,985,985,247,247,333,333,984,984,984,
				 333,102,103,103,100,100,333,333,981,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,333,247,247,247,247,247,247,247,247,247,333,984,984,984,984,984,
				 333,100,306,103,306,306,333,333,981,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,333,247,247,247,333,333,333,333,333,333,984,984,984,984,984,984,
				 335,100,333,306,306,306,306,333,981,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,333,247,247,247,333,984,984,984,984,984,984,984,984,984,984,984,
				 335,100,100,333,306,306,306,983,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,333,247,247,247,333,984,984,984,984,984,984,984,984,984,984,984,
				 335,100,100,333,333,333,306,981,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,333,333,333,333,333,984,984,984,984,984,984,984,984,984,984,984,
				 333,306,306,333,333,333,333,981,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,
				 333,333,333,333,982,983,983,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,
				 982,983,983,983,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,
				 981,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,
				 981,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,
				 984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,
				 984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984, 
				 984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,
				 984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984];

	}else if(map== "room-2Over"){
		return  [333,333,333,333,333,333,333,333,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,985,703,
				 335,701,100,100,100,100,100,306,982,983,983,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,985,985,985,985,247,
				 335,100,100,306,100,306,100,306,981,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,985,247,247,247,247,
				 335,100,100,333,306,333,100,333,981,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,985,985,985,985,985,985,985,985,985,985,985,985,247,333,333,333,
				 333,102,306,333,333,100,100,333,981,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,333,333,333,333,333,985,985,985,985,985,247,247,247,333,984,984,
				 333,102,333,333,100,100,306,306,981,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,333,247,247,247,333,985,985,985,985,247,247,333,333,984,984,984,
				 333,102,103,103,100,100,333,333,981,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,333,247,247,247,247,247,247,247,247,247,333,984,984,984,984,984,
				 333,100,306,103,306,306,333,333,981,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,333,247,247,247,333,333,333,333,333,333,984,984,984,984,984,984,
				 335,100,333,306,306,306,306,333,981,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,333,247,247,247,333,984,984,984,984,984,984,984,984,984,984,984,
				 335,100,100,333,306,306,306,983,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,333,247,247,247,333,984,984,984,984,984,984,984,984,984,984,984,
				 335,100,100,333,333,333,306,981,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,333,333,333,333,333,984,984,984,984,984,984,984,984,984,984,984,
				 333,306,306,333,333,333,333,981,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,
				 333,333,333,333,982,983,983,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,
				 982,983,983,983,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,
				 981,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,
				 981,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,
				 984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,
				 984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984, 
				 984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,
				 984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984,984];

	}else if(map=="room-3"){
		return  [333,333,333,333,333,333,333,333,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,333,333,
				 335,100,200,200,200,200,200,306,982,983,983,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,333,333,333,333,333,
				 335,200,200,306,200,306,200,306,981,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,333,333,333,200,333,333,333,333,333,
				 335,200,200,333,306,333,200,333,981,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,985,985,985,985,985,985,985,985,349,333,333,333,333,333,333,333,
				 333,200,306,333,333,200,200,333,981,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,333,333,333,333,333,985,985,985,247,333,333,333,333,333,200,200,
				 333,200,333,333,200,200,306,306,981,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,333,247,247,247,333,333,333,333,247,333,333,333,333,200,200,200,
				 333,200,750,200,200,403,700,333,981,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,333,247,751,247,247,247,247,247,247,333,333,200,200,200,200,200,
				 333,200,306,200,306,306,333,333,981,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,333,247,247,247,333,333,333,333,333,333,200,200,200,200,200,200,
				 335,200,333,306,306,306,306,333,981,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,333,247,247,247,333,200,200,200,200,200,200,200,200,200,200,200,
				 335,200,200,333,306,306,306,983,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,333,247,247,247,333,200,200,200,200,200,200,200,200,200,200,200,
				 335,200,200,333,333,333,306,981,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,333,333,333,333,333,200,200,200,200,200,200,200,200,200,200,200,
				 333,306,306,333,333,333,333,981,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,
				 333,333,333,333,982,983,983,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,
				 982,983,983,983,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,
				 981,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,
				 981,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,
				 200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,
				 200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200, 
				 200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,
				 200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200];

	}else if(map== "room-3Over"){
		return  [333,333,333,333,333,333,333,333,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,333,333,
				 335,100,200,200,200,200,200,306,982,983,983,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,333,333,333,333,333,
				 335,200,200,306,200,306,200,306,981,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,333,333,333,200,333,333,333,333,333,
				 335,200,200,333,306,333,200,333,981,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,985,985,985,985,985,985,985,330,349,333,333,333,333,333,333,333,
				 333,200,306,333,333,200,200,333,981,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,333,330,330,330,330,985,985,330,247,333,333,333,333,333,200,200,
				 333,200,333,333,200,200,306,306,981,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,333,247,247,247,330,330,330,330,247,333,333,333,333,200,200,200,
				 333,200,750,200,200,403,700,333,981,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,333,247,751,247,247,247,247,247,247,333,333,200,200,200,200,200,
				 333,200,306,200,306,306,333,333,981,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,333,247,247,247,333,333,333,333,333,333,200,200,200,200,200,200,
				 335,200,333,306,306,306,306,333,981,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,333,247,247,247,333,200,200,200,200,200,200,200,200,200,200,200,
				 335,200,200,333,306,306,306,983,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,333,247,247,247,333,200,200,200,200,200,200,200,200,200,200,200,
				 335,200,200,333,333,333,306,981,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,333,333,333,333,333,200,200,200,200,200,200,200,200,200,200,200,
				 333,306,306,333,333,333,333,981,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,
				 333,333,333,333,982,983,983,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,
				 982,983,983,983,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,
				 981,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,
				 981,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,
				 200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,
				 200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200, 
				 200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,
				 200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200];
	}

}//// whatRoomMap FUNC

/// this is kept here so you don't have to constantly define it  when you need it elsewhere 
////  (to calculate distances|width&height| in map for different room sizes) 
function checkTileNumbers(room){

	if(room=="room-1"){
		roomNumberTilesY = 68;
		roomNumberTilesX = 61;
	}else if(room=="room-2"){
		roomNumberTilesY = 20;
		roomNumberTilesX = 41;
	}else if(room=="room-3"){
		roomNumberTilesY = 20;
		roomNumberTilesX = 41;
	}
///with the maps right up there it's easy to adjust
}






///     ///
  //   //
  /////       ////// ///  //  ///////
  //////     ////     ////   ///
  //   //   ///       //    /////
///    //   /////    //  ///////


var keysPressed = []; 

var keyDown={isDown:false, whatKey:null};

///from Event Listener (at Init)
function checkKey(e, value, checkArrows) {

	

		if(checkArrows){
			return e.keyCode;
		}else{

			keyDown.isDown=true;
			// e = e || event; 
			keysPressed[e.keyCode] = e.type;

			if(e.keyCode==38||e.keyCode==39||e.keyCode==40||e.keyCode==37){
				latestKeys.push(e.keyCode);/////    IGNORE  ANY OTHER KEY BUT ARROWS!!!!
			}
	

			// YEAH!! it remembers last keysPressed so can go from 1 diagonal to another!!

			if (keysPressed[38]) { 
				
				superLastKey=38;		
				//player1 should change to "Da player"
				if(keysPressed[39]||latestKeys[0]==39){
					player1.direction = "right-up";  /// to know it can do another one..
					player1.facing = "right-up";
				}else if(keysPressed[37]||latestKeys[0]==37){
					player1.direction = "left-up";  /// to know it can do another one..
					player1.facing = "left-up";
				}else{
					player1.direction = "up";
					player1.facing = "up";
				}



				if(paused){

					player1.direction = "nowhere";
					player1.facing = "nowhere";

					if(menuTrack==0){
							//console.log(itemRow+ "HHH "+(player1.items.length-1));
						if(typeof player1.items[1]!="undefined"&&itemRow!=0){

							itemRow-=1;
							//console.log("row"+menuRow);
							menuItemAlreadyPainted=false;
				
						}else if(itemRow==0){

							itemRow=player1.items.length-2;
							menuItemAlreadyPainted=false;
								
						}

						selecto();

					}else if(menuTrack==1){
							
						if((gunRow-1)<0){
							gunRow=player1.guns.length-1;
						}else if((gunRow-1)<player1.guns.length){
							gunRow-=1;
						}
								
						menuGunAlreadyPainted=false;

						selecto();
					}
				}                 
			}


			if (keysPressed[40]) {  /////////////////////////////// YES, WORKS 

				superLastKey=40;


				if(keysPressed[39]||latestKeys[0]==39){
					player1.direction = "right-down";  /// to know it can do another one..
					player1.facing = "right-down";
				}else if(keysPressed[37]||latestKeys[0]==37){
					//console.log("YEAH!");
					player1.direction = "left-down";  /// to know it can do another one..
					player1.facing = "left-down";
				}else {      
					player1.direction = "down";  /// to know it can do another one.. 
					player1.facing = "down";
				}
				
		

				if(paused){

					player1.direction = "nowhere";
					player1.facing = "nowhere";

					menuCount=0;
					daMenu.draw();
					
					/// this could be other buttons>> like R-L   
			
					if(menuTrack==0){
							
						if(typeof player1.items[1]!="undefined"&&itemRow!=player1.items.length-2){

							itemRow+=1;
							//console.log("row"+menuRow);
							menuItemAlreadyPainted=false;
				
						}else if(itemRow==player1.items.length-2){

							itemRow=0;
							menuItemAlreadyPainted=false;
								
						}

						selecto();

					}else if(menuTrack==1){
							
						console.log("LLLL "+player1.guns.length);

						if((gunRow+1)==player1.guns.length){
							gunRow=0;
						}else if((gunRow+1)<player1.guns.length){
							gunRow+=1;
						}
								
						console.log("GRR"+gunRow);
						//console.log("row"+menuRow);
						menuGunAlreadyPainted=false;

						selecto();
					}

					menuH_items.draw();

					clearCtx(ctxEntities);

					for(var i=0; i< items.length; i++){
					   items[i].draw();
					}
					player1.direction = "nada";

					console.log(player1.direction);

				}// if paused  

			}// DOWN arrow



			if (keysPressed[39]) {  

				if(mBorderX>256){
					oldmBorderCount=0;
					mBorderCount=0;
					mBorderX=0;
				}

				superLastKey=39;	
			
				if(keysPressed[40]||latestKeys[0]==40){
					//console.log("DOWN");
					player1.direction = "right-down";  /// to know it can do another one..
					player1.facing = "right-down";
				}else if(keysPressed[38]||latestKeys[0]==38){
					player1.direction = "right-up";  /// to know it can do another one..
					player1.facing = "right-up";
				}else{
					player1.direction = "right";  /// to know it can do another one..
					player1.facing = "right";
				}
			   
				if(paused){
					player1.direction = "nowhere";
					player1.facing="nowhere";

					if(menuTrack==0){
						menuTrack=1;
						 selecto();
						menuH_guns.draw();
					}else if(menuTrack==1){
						menuTrack=0;
						 selecto();
						menuH_items.draw();
					}
				}
			}
			if (keysPressed[37]) {  /////////////////////////////// YES, WORKS
			if(mBorderX>256){
						oldmBorderCount=0;
						mBorderCount=0;
						mBorderX=0;
					}
				/// this is the problem, for some reason Last Key 39 goes back to 37
				superLastKey=37;

				if(keysPressed[40]||latestKeys[0]==40){
					player1.direction = "left-down";  /// to know it can do another one..
					player1.facing = "left-down";
				}else if(keysPressed[38]||latestKeys[0]==38){
					player1.direction = "left-up";  /// to know it can do another one..
					player1.facing = "left-up";
				}else{
					player1.direction = "left";  /// to know it can do another one..   
					player1.facing = "left";
				}
				if(paused){

					player1.direction = "nowhere";
					player1.facing="nowhere";

					if(menuTrack==0){
						menuTrack=1;
						 selecto();
						menuH_guns.draw();
					}else if(menuTrack==1){
						menuTrack=0;
						 selecto();
						menuH_items.draw();
					}
				}       
			}/// key pressed 37


			//////////////////////////////////////////////////////////////////
			/// Player DASH
			if (keysPressed[16]) { 
				
				if(menuTrack==0){

					if(typeof player1.items[1]!="undefined"&&itemRow!=player1.items.length-2){

						itemRow+=1;
						//console.log("row"+menuRow);
						menuItemAlreadyPainted=false;
					
					}else if(itemRow==player1.items.length-2){

						itemRow=0;
						menuItemAlreadyPainted=false;
									
					}

					selecto();
				}else if(menuTrack==1){
					if(typeof player1.guns[1]!="undefined"&&gunRow!=player1.guns.length-1){

					gunRow+=1;
					//console.log("row"+menuRow);
					menuGunAlreadyPainted=false;
				
					}else if(gunRow==player1.guns.length-1){

						gunRow=0;
						menuGunAlreadyPainted=false;
									
					}
					selecto();
				}

				    

			}/// key: SHIFT  >> Select


			if (keysPressed[18]) { 

				if(paused){
					for(var n = 0; n < player1.nonSelectItems.length; n++ ){
						if(player1.nonSelectItems[n].itemCategory==1){
						   // console.log(player1.nonSelectItems[n].itemCategory);	
							if(!tele){

								tele=true;

							}else{

								tele=false;   		
									
							}
							clearCtx(ctxOverOverlay);   /// Rather.. clearRect Exactly on top of THIS
												///   to avoid ugly milisecond flicker on all other items..
						}
					}
				}
				
			}/// key: alt

			if (keysPressed[32]) {  /////////////////////////////// YES, WORKS
				if(!player1.isDead){
					//console.log("FACING ?"+player1.facing);

					if(facingBeforePause==null){
						facingBeforePause=player1.facing;
					}
					

					player1.direction="nowhere"; /// leave or not... a matter of style
					player1.facing="nowhere";

					clearCtx(ctxMenu);
					clearCtx(ctxMenuOver);

					if(!paused){

						if(player1.items.length<=1){
							menuTrack=1;
						}
						paused=true;
						selecto();
						pause();

						////also : pause IS BEING SENT TO OUTSIDE FUNCTION SO AS TO RECOURSE IT WHILE notPlaying & WHILE STILL LISTENING TO KEYS 
						////                                                                            which trigger different parts of pause(function)
					   
					}else{
						paused=false;
						player1.facing=facingBeforePause;
						facingBeforePause=null;
						pause();
					}
				}

				pauseSFX.play();

			} /// key: SPACE

			// C



			if(keysPressed[50]){
				
				if(doorBlock){
					doorBlock=false;
				}

				if(player1.direction!="room-change"){
					player1.shooting=true;
					//shaker();
				}
			} /// key: 2 >>> B button


			if(keysPressed[49]){

				menuTrack=0;

				if(player1.direction!="room-change"&&player1.items.length>1){
					if(itemDecrementCount==0){
						player1.usingItem=true;
					}
					
					//console.log("using Item");
				}
			} /// key: 1 >>> A button


			if(keysPressed[17]){
				
				console.log("START button")
			} /// key: crtl >>> START button

			e.preventDefault();

		}// IF !checkArrows


}//END CheckKEYS



																							     ///    P   H   I   S  Y  C  S   HELPERS



/// FRICTION (player keeps moving for a bit when released)

var releaseCounter=false;

function friction(){

	///this is kinda messes up  ///will need a definitive arrangement at some point. 
	///  because of the friction and 2 key diagonals+release, its hard to set the shooting direction
	//														and to pin point the definite angle player1 is facing

	if(releaseCounterCount>14){ /// it was on 4.. but now works on 14.. forgot what it was that conflicted with..?
																/// that wouldn't work well over 4??
		slowDownDirection=player1.direction;
		player1.facing=player1.direction;
	}else{
		slowDownDirection=player1.facing;	
	}/// but remember NES games didn't even go that far

	slowDownDirection=player1.facing;

	// diagonal friction
	if(latestKeys.length>0){

		if(latestKeys[0]==39){
			player1.direction="right"; 
		}else if(latestKeys[0]==37){
			player1.direction="left"; 
		}else if(latestKeys[0]==40){
			player1.direction="down"; 
		}else if(latestKeys[0]==38){
			player1.direction="up"; 
		}
		
	}else{ 
		//either this if for friction
		if(player1.speed>0){
			slowDown=true;
		}
		////or this for no-friction
		// player1.speed=0;
		// player1.direction="nada"; 
			
	} // else IF latestKeys.length>0
 
}/// FUNC friction






/// SHAKE Screen FX
var shakeCount=0;

function shaker(){

	//console.log("SHAKE "+shakeCount);
	shakeCount++;

	if(shakeCount>=0&&shakeCount<5){
		
		document.getElementById('containerbody').style.left= 10+"px";
		document.getElementById('containerbody').style.top= -10+"px";
		requestAnimFrame(shaker);
	}else if(shakeCount>=5&&shakeCount<10){
		document.getElementById('containerbody').style.left= -10+"px";
		document.getElementById('containerbody').style.top= 0;
		requestAnimFrame(shaker);
	}else if(shakeCount>=10){
		document.getElementById('containerbody').style.left= 0;
		document.getElementById('containerbody').style.top= 0;
		shakeCount=0;
	}
}/// FUNC shaker()




///l]|[]/l]|[]/l]|[]/l]|[]/l]|[]/l]|[]/l]|[]/l]|[]/l]|[]/l]|[]/l]|[]/l]|[]/l]|[]/l]|[]/l]|[]/l]
///
///             S  E  L  E  C  T      I  N  V  E  N  T  O  R  Y
///
///l]|[]/l]|[]/l]|[]/l]|[]/l]|[]/l]|[]/l]|[]/l]|[]/l]|[]/l]|[]/l]|[]/l]|[]/l]|[]/l]|[]/l]|[]/l]


function selecto(){
	////  WHEN A GUNTYPE FIRSTPICK >> GOES AND SELECT IT AND DRAWS IT IN MENU AS CURRENT
	//console.log("IT R "+itemRow);
	if(menuTrack==0){

		//if not true already..
		menuH_items.isSelected=true;

		///loop row =>> loop player1.items...
		for(var i=0; i<player1.items.length-1; i++){
			if(itemRow==i){
				player1.itemSelected=player1.items[i+1].itemCategory;

				//console.log("ITEMS?" +player1.itemSelected);
				//console.log(player1.items[i+1].itemCategory);
				menuH_items.rowSelec=i;
			}
		}

		menuH_items.draw();

	/// ELSE if .... gunSelectPressed
	}else if(menuTrack==1){

		/// IF menuTrack==0

		//if not true already..
		menuH_guns.isSelected=true;
		//console.log("GGeeee"+player1.guns.length);
		for(var i=0; i<player1.guns.length; i++){
					
			if(gunRow==i){	
				//console.log("A VER A VER "+player1.guns[i+1].itemCategory);
				//player1.gunSelected=player1.guns[i+1].itemCategory;
				player1.weaponSelected=player1.guns[i].itemCategory;
				menuH_guns.rowSelec=i;
			}
		}
		/// ELSE if menuTrack ==1 .... gunSelectPressed
		menuH_guns.draw();
	}
}/// selecto


////L]_^#@~~/\\\|_-_////L]_^#@~~/\\\|_-_////L]_^#@~~/\\\|_-_////L]_^#@~~/\\\|_-_////L]_^#@~~/\\\|_-_////L]_^#@~~/\\\|_-_////L]_^#@~~/\\\|_-_////L]_^#@~~/\\\|_-_////L]_^#@~~/\\\|_-_////L]_^#@~~/\\\|_-_///L]_^#@~~/\\\|_-_////L]_^#@~~/\\\|_-_////L]_^#@~~/\\\|_-_////L]_^#@~~/\\\|_-_////L]_^#@~~/\\\





									 ////   ////   ///   ////   ////////      
									 ////   /////  ///   ////       ///            
									 ////   ////// ///   ////       ///                          
 									 ////   //////////   ////       ///     
									 ////   /// //////   ////       ///           
									 ////   ///  /////   ////       ///       

var screenHeight;

// var HH=window.innerHeight-90;  //// menu height - 10px top
// var WW=HH*1.4;    /////////// aarrg!! Canvas only takes straight values, calcutions result in this lines between the tiles (and calculating only one slows everything down)
////  instead, get win.heignt, and then figure out a straight number not bigger than, and is 4:3 width equivalent
var HH=670;  //// menu height - 10px top
var WW=1000;


function getCanvasSize(){

///////    IF  ! window.height > tileDiamter * totalTilesY

/// for camera work ->  would put all this in a function, and then pass it again with diff values (for Each), say: everything + 20%, and style.top - however much to center again...
																								/////		and move around like that, decreasing the top by the corresponding amount
	canvasBg.width =WW;
	canvasBg.height = HH;
	canvasDoors.width =WW;
	canvasDoors.height = HH;
	canvasEntities.width =WW;
	canvasEntities.height = HH;
	canvasPlayer.width =WW;
	canvasPlayer.height = HH;
	canvasBullets.width =WW;
	canvasBullets.height = HH;
	canvasOverlay.width =WW;
	canvasOverlay.height = HH;
	canvasOverOverlay.width =WW;
	canvasOverOverlay.height =HH+80; /// canvas height + Menu height
	canvasPause.width =WW;
	canvasPause.height = HH;

	canvasMenu.width =WW;
	canvasMenu.height = 80;

	/// FOR SOME REASON IT DOESNT DO THIS ONE.. (hardcoded on index.html)
	canvasMenuOver.width =WW;
	canvasMenuOver.height = HH;

	canvasMapOverMenu.width =canvasBg.width/7;
	canvasMapOverMenu.height = canvasBg.height/7;


	canvasMenuOverOver.width =WW;
	canvasMenuOverOver.height = 80;

	if(canvasBg.width<window.innerWidth){
		document.getElementById("container").style.left= (window.innerWidth-canvasBg.clientWidth)/2+"px";
	}else{
		document.getElementById("container").style.left= "0";
	}
	// CSS margin won't work
	document.getElementById("container").style.top= 15+"px";

	document.getElementById("divleft").style.width= (window.outerWidth-canvasBg.clientWidth)/2+10+"px";
	document.getElementById("divleft").style.height= window.outerHeight+"px";

	document.getElementById("divright").style.width= (window.outerWidth-canvasBg.clientWidth)/2+10+"px";
	document.getElementById("divright").style.height= window.outerHeight+"px";

	document.getElementById("divbottom").style.top= window.outerHeight+"px";

	screenHeight = canvasBg.height+canvasMenu.height;

//// COOL, COOL... because of Canvas quirks, Width and Height has to be hardcoded as above
/////																			   now SET MAXIMUM HEIGHT (so it doesn't miss half the tiles if monitor is huge)
////																				.... so figure out maxHeight -> not bigger than tileDiameter * totalTilesY
}// END getCanvasSize()



window.addEventListener("load", initGame, false);

//should be in Funtion => GAME
function initGame() {


	getCanvasSize();
																				



    ///     ///
      //   //
       ////
       //\\
       //  \\
     ///    //
   ///     ///



	/// Key   Down|Up   LISTENERS!!                                       
	//																	K - D O W N
	document.addEventListener("keydown", function(e) {

		if(!blockInput && !player1.isDead){

			checkKey(e, true, false); 
			
			 if(checkKey(e, true, true)==37||checkKey(e, true, true)==38||checkKey(e, true, true)==39||checkKey(e, true, true)==40){
				
			 		/// NO PUEDE SER IMPAR por alguna razon
			   		player1.speed=8; //// = 12, = currentSpeed <<<   should vary throughout the game
			   		releaseCounter=false;

					slowDown=false;
					slowDownDirection=player1.direction;		
			}// IF Check for Arrows (D-pad) pressed	

		}

	}, false);
	/// END KeyDown


	/// 																  K - U P	
	document.addEventListener("keyup", function(e) {	
		 
		for (var i = 0; i<latestKeys.length;i++) {
			//console.log(latestKeys[i]);
			if(checkKey(e, true, true)==latestKeys[i]){
				//console.log(latestKeys.length);
				latestKeys.splice(i,1);
				i=i-1; /// otherwise after splicing, the next i comes to take the current i's place and on the next iteration it won't be checked anymore (and too late to check on this one, so it passes)
			}
		}// FOR latest keys

		keysPressed = [];
		keyDown.isDown=false; 

		///ONLY IF ARROWS keyUp!!!
		if(checkKey(e, true, true)==37||checkKey(e, true, true)==38||checkKey(e, true, true)==39||checkKey(e, true, true)==40){

			releaseCounter=true;

			/// this should stop player when key up  << but with a little delay
			
				friction(); 
			
			
		}// IF check Arrows Pressed



		//// ignore and delete this mess when moving to controller-input.......
		if(checkKey(e, true, true)==38){ //up

			//console.log("DFDFDSFD"+player1.direction);
		}
		if(checkKey(e, true, true)==40){ //down

			//console.log("DFDFDSFD"+player1.direction);
		}

		if(checkKey(e, true, true)==37){ //left

			// console.log("LAST K"+latestKeys[1]);
			// console.log("SUPER"+superLastKey);

			if(latestKeys[1]==39||latestKeys[1]==37){
				superLastKey=39;
			}else if(latestKeys[1]==38){
				superLastKey=38;
			}else if(latestKeys[1]==40){
				superLastKey=40;
			}

			if(player1.direction=="down"&&superLastKey==39){
				player1.direction="right-down";
				
			}else if(player1.direction=="up"&&superLastKey==39){
				player1.direction="right-up";
			}else if(player1.direction=="up"&&superLastKey!=39){
				player1.direction="up";
			}else if(player1.direction=="down"&&superLastKey!=39){
				player1.direction="down";
			}

		}

		if(checkKey(e, true, true)==39){//right

			//console.log("DFDFDSFD"+player1.direction);
			// player1.direction="down";
			if(player1.direction=="down"&&superLastKey==37){
				player1.direction="left-down";
				
			}else if(player1.direction=="up"&&superLastKey==37){
				player1.direction="left-up";
			}else if(player1.direction=="up"&&superLastKey!=37){
				player1.direction="up";
			}else if(player1.direction=="down"&&superLastKey!=37){
				player1.direction="down";
			}	
		}

		/// Shooting's UP (SpaceBar Release)
		if(checkKey(e, true, true)==50){
			player1.shooting=false;
		}


		if(checkKey(e, true, true)==49){
			player1.usingItem=false;
			itemDecrementCount=0;
		}


	},false);
	/// END KeyUp


	///////////  S T A R T    G A M E  ///////////////
	begin();

}/// FUNC initGame








  /////////\                                                        ///       /////
 ////////////\        ////////          ////////           ///     ///       /////
//////     ///\      ///             ///      ///         ///     ///      // ///
/////       ///      ///           ///                   ///      //     //   //
//////      //       /////        ///                   ///      //    //    //
///////////////\     ///          ////      /////      ///      //   //     //
/////       \///     ///           ////      ////     ///      //  //      //
//////      ////     //////////     ////       //    ///      // //       //
  /////////////       /////////      ///////////    ///      /////       //




function begin() {

	currentRoom= "room-1";
	currentArea="default";
	currentLevel=1;

	roomDraw(currentRoom, currentArea, 0, tileDiameter, 0, 0, "first", currentLevel);


	// So, if it's not gonna start from corner 0, 0 >>>  Block screen with something (block input too)....
	
	// ... then release it, ad there you go


	if(playerChoosing=="player1"){

		/// ///// INSTEAD PUSH INTO Players Array (limited amount of diff players at any one time)

		/// and then in Player.prototype. functions use a foor loop... checking for each.


		///DO SAME WITH ENEMIES.. and items

		///replace the whole player1 for 

			// players.push(

			// 	new Enemy(enemyTypes[0])
			// );
		
		player1 = new Player(playerTypes[0]); /////// [0] <<<< VAR depending on playerType chosen at introScreen
	}

	isPlaying = true;

	requestAnimFrame(loop);



	enemies.push(

		new Enemy(5*tileDiameter, 3*tileDiameter, enemyTypes[0])
	);


	///// Initial GAME ITEMS  (unlike enemy drops which appear as the game goes)
	items.push( 

		///key 0 -> rooms: 301, 
		new Item( 5*tileDiameter,45*tileDiameter, "item", 100, false, false, null, "room-1"), 

		new Item( 38*tileDiameter,54*tileDiameter, "item", 101, false, false, null, "room-1"), 

		///teleport relic
		new Item( 6*tileDiameter,2*tileDiameter, "item", 1,false, false, null, "room-3"), 

		///boots
		new Item(6*tileDiameter,2*tileDiameter, "item", 2, false, false, null, "room-1"),

		///long range shoot
		new Item(28*tileDiameter, 8*tileDiameter, "item", 3, false, false, null, "room-2"),

		///water tank
		new Item(26*tileDiameter, 5*tileDiameter, "item", 4, false, false, null, "room-2"),

		///radar
		new Item(5*tileDiameter, 2*tileDiameter, "item", 5, false, false, null, "room-1"),


		///speed-boost collectible
		new Item( 5*tileDiameter,3*tileDiameter, "item", 11, true, false, null, "room-1"),
		new Item( 6*tileDiameter, 9*tileDiameter, "item", 11, true, false, null, "room-1"), 
		/// health-boost collectible
		new Item( 4*tileDiameter, 1*tileDiameter,  "item", 10, true, false, null, "room-1")
		); 


	items.push( 
		new Item(3*tileDiameter,5*tileDiameter, "gun", 1, false, false, null, "room-1"), 
		new Item(37*tileDiameter,53*tileDiameter, "gun", 2, false, false, null, "room-1"), 
		new Item(5*tileDiameter,tileDiameter, "gun", 2, false, false, null, "room-1")
		);


	items.push( 
		// ammo gun 1
		new Item(26*tileDiameter, 8*tileDiameter, "ammo", 11, false, false, null, "room-2"),
		// ammo gun 2 
		new Item(27*tileDiameter, 8*tileDiameter, "ammo", 2, false, false, null, "room-2"), 

		/// health-insta
		new Item(4*tileDiameter,3*tileDiameter, "life", 0, false, false, null, "room-1")
		);


//// salpicado de pared
// items.push(new Item(26*tileDiameter, 8*tileDiameter, "ammo", 11, false, false, null, "room-2"));

	menuH_items = new menuH(700, 600, 30, 30, 200, 100, "item", false);
	menuH_guns = new menuH(700, 600, 30, 30, 230, 100, "gun", false);


	player1.guns[0]={srcX:570, srcY:605, width:45, height:45, selec:true, itemType:"gun", itemCategory:1, amount:0};
 

	////// hmmmm   draw once.. then do this)
 	ctxOverOverlay.fillRect(0, 0, canvasWidth-50, Math.round(screenHeight));

 	alert("[Arrow Keys : move around -> when paused: select weapon or items to use]\n[2 : fire weapon]\n[1 : use item]\n[shift : swap between items or weapons]\n[space : pause -> menu]\n[alt : when paused -> activate teleport-item]")
}

var gameBeginsRoomChange=false;



var poweroff = false;






  ////////////        ///////////
 ///////             /////    ////
/////      //////    ///       ///
//////      /////    ///       ///
////////////////     /////    ////
  /////////////       ///////////


var gameCounter =0;




//UPDATE everything
function update() {

	gameCounter++;


	if(gameCounter>6){
		if(!gameBeginsRoomChange){
			changeRoom("room-1", 674, shiftX, shiftY, "normal");

			gameBeginsRoomChange=true;	
		}
		/// This goes here, or else there is nothing drawn yet and the game start on "white"
	}


	clearCtx(ctxBg);
	clearCtx(ctxDoors);
	clearCtx(ctxPlayer);
	clearCtx(ctxBullets);
	clearCtx(ctxOverlay);
	
	clearCtx(ctxEntities);
	clearCtx(ctxMenu);
	clearCtx(ctxMenuOver);


	window.onresize = function(){

		getCanvasSize();
	}// END onResize




	//DONDE SEA QUE HALLA player1 >>> CAMBIAR POR 
	//for (var i = 0; i < players.length; i++) {
	  
	for (var i = 0; i < enemies.length; i++) {
		enemies[0].update();
	}

	 //   if(players[i][0 == 1
	for (var i = 0; i < players.length; i++) {
		if(players[i]== 1){
			player1.update();
			
		}else{
			//player2.update();
		}
	}

	////  Sample of being pushed unvoluntarily and still having walls stop you, yay! (enemy power weapon) >>>  for STUN FX simply block key-listening
		// if(player1.moving){
		//    player1.direction ="right";
		// }


	for(var i=0; i < inActiveObstacle.length; i++){
		
			/// id -> doorOpen(argument)

		if(inActiveObstacle[i].time>0){
			inActiveObstacle[i].time--;

			for (var f=0; f<doors.length; f++) {

				if(doors[f].id==inActiveObstacle[i].ID){
					doors[f].timeToClose=inActiveObstacle[i].time;
				}
			}

			//console.log("closing? :"+inActiveObstacle[i].time);
		}else if(inActiveObstacle[i].time<=0 && inActiveObstacle[i].time != null ){


			for(var j=0; j < obstacles.length; j++){

				/// Si no dice ID delete!"  cuando cambio de piesa >> PORQUE los obstaculos son otros!!(disintos ids)

				if(obstacles[j].ID==inActiveObstacle[i].ID){


					obstacles[j].obstacleStatus="closed";

					for (var f=0; f<doors.length; f++) {

						if(doors[f].id==obstacles[j].ID){

							if(player1.tile!=obstacles[j].ID){
								doors[f].doorStatus="closed";

								doorCloseSFX.play();
								/// ONLY WHEN DOORS CLOSE BY <<< calculate sorrounding Tiles before !

							}else{
								///make noise
								pendingClose.push({doorID:obstacles[j].ID, doorIndex:f});
							}

							/// UNLESS PLAYER STANDING ON IT!
						}
					}
					//console.log("ID delete! :: "+obstacles[j].ID);
				}
			}
			inActiveObstacle.splice(i,1);
			/// Si no dice ID delete!" ........
			//console.log("pero inActive.time->0 se encarga del resto");
		}
		  
	}// for obst length


	if(pendingClose.length>=1){
		// console.log(pendingClose[0].doorID);
		// console.log(player1.tile);
		if(player1.tile!=pendingClose[0].doorID){
			doors[pendingClose[0].doorIndex].doorStatus="closed";
			pendingClose=[];
		}
	}


	for(var i=0; i< items.length; i++){
		items[i].update();
	}


	for(var i=0; i< bulletsFired.length; i++){
		if(bulletsFired[i].active){//// diff var, if inActiveObstacle >>> debris anim >>> if(!debrisOver 
			bulletsFired[i].update();
		}else{												/// then ELSE if debrisOver
			/// NOW splice
			bulletsFired.splice(i,1);
		}
		
	}
}/// END UPDATE





  ////////////        ///////////
 ///////             /////    ////
/////      //////    ///       ///
//////      /////    ///       ///
////////////////     /////    ////
  /////////////       ///////////





// & Re-DRAW
function draw() {

	for (var i = 0; i < enemies.length; i++) {
		enemies[0].draw();
	}

	for (var i = 0; i < players.length; i++) {
		if(players[i] == 1){
			player1.draw();
		}else{
			//player2.draw();
		}
	}

	
	for(var i=0; i< items.length; i++){
		items[i].draw();
	}
 	
	for(var i=0; i< bulletsFired.length; i++){
		bulletsFired[i].draw();
	}
	
	roomDraw(currentRoom, currentArea, 0, tileDiameter, shiftX, shiftY, "not-first");

}/// END DRAW




  ////////////        ///////////
 ///////             /////    ////
/////      //////    ///       ///
//////      /////    ///       ///
////////////////     /////    ////
  /////////////       ///////////




function loop() {

	if(isPlaying){

		/// Do_Stuff  >>> at a constant rate, regardless of processor speed
		if(Date.now()>then+gameSpeed){
			then=Date.now();

		//???\\\//GAME HAPPENS HERE!!!!! 
			update();
			draw();

			//console.log(shiftY);

		}
		/// Enable loop (so stuff can be done)
		requestAnimFrame(loop);
	}
}/// END LOOP





//TYUIH^*@()//TYUIH^*@(//TYUIH^*@()//TYUIH^*@()//TYUIH^*@(//TYUIH^*@()//TYUIH^*@(//TYUIH^*@()//TYUIH^*@()//TYUIH^*@(
//TYUIH^*@()//TYUIH^*@(//TYH^*@()//TYUIH^*@()//TYUIH^*@(//TYUIH^*@()//TYUIH^*@(//TYUIH^*@()//TYUIH^*@()//TYUIH^*@(
//TYUIH^*@()//TYUIH^*@(//TYH^*@()//TYUIH^*@()//TYUIH^*@(







															//\///\\//\  ///////    ///    //  /    ///
															///\\\\\\\\  ///       /////  //  /    ///
															///\\\\\\\\  /////    /// // //  /    ///
															//// \/ \\\  ///     ///  ////  /    ///
															///    \ \\  //////////   ///  ////////



///animate items||gun >>  on/off
var itemCounter = 0;
var gunCounter = 0;
///Menu items  >>> only updated on pause

function menu(srcX, srcY, w, h, x, y) {
	this.srcX=srcX;
	this.srcY=srcY;
	this.width = w;
	this.height = h;
	this.drawX = x;
	this.drawY = y;
}

var menuCount=0;
var srccX=0;

var repeat=0;
/// PARAMS to distinguish if draw.ITEM or draw.GUN  (from pause-press or first-pick)  ||  BOTH (not-paused)
menu.prototype.draw = function () {
/////  no FLASH, OR RESET ANIMCOUNTER >>> IF ITS NOT YOUR MENUTRACK (no flashing gun-item when scrolling item-item)
	//// in pause mode you can scroll and select other ones with the arrows)

	var itemSrcX=0;
	var itemDrawX=0;
	clearCtx(ctxMenu);
	clearCtx(ctxMenuOver);

	for (var i =0; i<3; i++) { ///// 3 Tracks
			
		if(i==0){
			if(player1.items[1]!=null&&player1.items[1]!="undefined"){
								
						
				for (var j = 0;j<player1.items.length; j ++) {			 
								
							/// FOR  ROW>>> IT COULD BE INFINITE!    for player1.items  igual que en checkKey
					if(itemRow==j){
						if(typeof player1.items[j]!="undefined"){

							//console.log( " L"+player1.itemSelected);

							if(player1.itemSelected==10){
								itemSrcX=0;
								itemSrcY=128;
							}else if(player1.itemSelected==11){
								itemSrcX=128;
								itemSrcY=128;
							}

							///ONLY DRAW IF SELECTABLE!!!  and only apply effects if items-> thisRow <<<< MOR THAN ONE
							///// so duplicate this if elses and >> if player1.items 
									
	          				if(paused&&menuTrack==0&&pauseType=="gamePause"){
	          					
	          					//console.log("RRR "+repeat);
	          					if(itemCounter<20){
	          						ctxMenuOver.drawImage(itemsMenuSprite, itemSrcX, itemSrcY, 128, 76, 64, 0,128, 76);

	          						itemCounter++;
	          						//console.log("I C " +itemCounter);
	          					}else if(itemCounter>=20&&itemCounter<27){
	          						itemCounter++;
	          						//console.log("I C " +itemCounter);
	          						clearCtx(ctxMenuOver);
	          					}else{
	          						itemCounter=0;
	          						//console.log("I C " +itemCounter);
	          					}
	          				}else{
	          					//console.log("FIRST PICK ? "+pickingItem + "COUNT " + pickingItemCount);

			          			if(pickingItem){
			          				pickingItemCount++;
			          			}

			          			if(pickingItemCount==0){
			          				ctxMenuOver.drawImage(itemsMenuSprite, itemSrcX, itemSrcY, 128, 76, 64, 0, 128, 76);
			          			}else if(pickingItemCount>0 && pickingItemCount< 25){
			          				
			          			}else if(pickingItemCount>=25 && pickingItemCount< 50){
			          				ctxMenuOver.drawImage(itemsMenuSprite, itemSrcX, itemSrcY, 128, 76, 64, 0, 128, 76);
			          			}else if(pickingItemCount>=50 && pickingItemCount< 75){

			          			}else if(pickingItemCount>=100){
			          				pickingItemCount=0;
			          				pickingItem=false;
			          				ctxMenuOver.drawImage(itemsMenuSprite, itemSrcX, itemSrcY, 128, 76, 64, 0, 128, 76);
			          			}
	          					
	          				}
	          				//console.log("CUANTOS YA? "+player1.nonSelectItems.length);
						}    
					}
				};
							
				menuItemAlreadyPainted=true;
								///// should be this.ICON >> diff image in game and inventory	
			} 
				
		}else if(i==1){
							

			if(player1.guns[0]!=null&&player1.guns[0]!="undefined"){

				itemSrcY=0;

				if(player1.weaponSelected==1){
					itemSrcX=0;
				}else if(player1.weaponSelected==2){
					itemSrcX=128;
				}


				for (var j = 0;j<player1.guns.length; j ++) {
						  	//console.log(gunRow);
					if(gunRow==j){
								
						if(typeof player1.guns[j]!="undefined"){


							//console.log(player1.guns[j].itemCategory);
							if(player1.guns[j].itemCategory==1){
								itemSrcX=0;

								
								//console.log("une");
							}else if(player1.guns[j].itemCategory==2){
								itemSrcX=128;
								//console.log("duw");
								
							}

															//// not gun width but custom width
							if(paused&&menuTrack==1&&pauseType=="gamePause"){
			          			if(gunCounter<20){
			          				ctxMenuOver.drawImage(itemsMenuSprite, itemSrcX, itemSrcY, 128, 76, 230, 0, 128, 76);

			          				gunCounter++;
			          			}else if(gunCounter>=20&&gunCounter<27){
			          				gunCounter++;
			          						
			          			}else{
			          				gunCounter=0;
			          			}
			          		}else{
			          			//console.log("FIRST PICK ? "+pickingGun + "COUNT " + pickingGunCount);

			          			if(pickingGun){
			          				pickingGunCount++;
			          			}

			          			if(pickingGunCount==0){
			          				ctxMenuOver.drawImage(itemsMenuSprite, itemSrcX, itemSrcY, 128, 76, 230, 0, 128, 76);
			          			}else if(pickingGunCount>0 && pickingGunCount< 25){
			          				
			          			}else if(pickingGunCount>=25 && pickingGunCount< 50){
			          				ctxMenuOver.drawImage(itemsMenuSprite, itemSrcX, itemSrcY, 128, 76, 230, 0, 128, 76);
			          			}else if(pickingGunCount>=50 && pickingGunCount< 75){

			          			}else if(pickingGunCount>=100){
			          				pickingGunCount=0;
			          				pickingGun=false;
			          				ctxMenuOver.drawImage(itemsMenuSprite, itemSrcX, itemSrcY, 128, 76, 230, 0, 128, 76);
			          			}
			          			
			          		}

						}
					}
				};
			
			}
		}// if i = 1>> menuTrack


	   	// ctxMenu.clearRect(170,140,46, 46);   /// this blocks the bottom ITEM in the "sliding-trick"
	}/// FOR  menuTrack
		


	if(paused&&pauseType=="gamePause"){

		//clearCtx(ctxOverlay);
		ctxOverlay.fillStyle = "rgba(0, 0, 0, 0.245)";
		ctxOverlay.fillRect(0, 0, 1000, 115);

		ctxOverlay.fillStyle = "rgba(3, 0, 6, 0.24)";
		ctxOverlay.fillRect(0, 115, 1000, 115);

		ctxOverlay.fillStyle = "rgba(3, 0, 6, 0.21)";
		ctxOverlay.fillRect(0, 230, 1000, 115);

		ctxOverlay.fillStyle = "rgba(3, 0, 6, 0.16)";
		ctxOverlay.fillRect(0, 345, 1000, 115);

		ctxOverlay.fillStyle = "rgba(3, 0, 6, 0.12)";
		ctxOverlay.fillRect(0, 460, 1000, 115);

		ctxOverlay.fillStyle = "rgba(3, 0, 6, 0.1)";
		ctxOverlay.fillRect(0, 575, 1000, 120);


		//// NON SELECTABLE ITEMS >> in menu
		for (var i=0; i< player1.nonSelectItems.length; i++) {
			
			
			itemDrawY=214;

			if(player1.nonSelectItems[i].itemCategory==100||player1.nonSelectItems[i].itemCategory==101){

				itemSrcY=384;
				itemSrcX=0;
				itemDrawX=110;
					
			}else if(player1.nonSelectItems[i].itemCategory==1){
				itemSrcX=0;
				if(!tele){
					itemSrcY=512;
					
				}else{
					itemSrcY=640;
				}
				
				itemDrawX=410;
			}else if(player1.nonSelectItems[i].itemCategory==2){
				itemSrcY=256;
				itemSrcX=128;
				itemDrawX=310;
			}else if(player1.nonSelectItems[i].itemCategory==3){
				itemSrcY=256;
				itemSrcX=0;
				itemDrawY=312;
				itemDrawX=210;
			}else if(player1.nonSelectItems[i].itemCategory==4){
				itemSrcY=256;
				itemSrcX=256;
				itemDrawY=312;
				itemDrawX=110;
			}else if(player1.nonSelectItems[i].itemCategory==5){
				itemSrcY=256;
				itemSrcX=384;
				itemDrawY=312;
				itemDrawX=510;
			}					

			ctxOverOverlay.drawImage(itemsMenuSprite, itemSrcX, itemSrcY, 128, 128, itemDrawX, itemDrawY, 128, 128);

		}
		// ctxMenu.clearRect(170,30,46, 46);
		
		if(menuCount<20){
			menuCount++;
			if (menuCount%7 == 0){
				clearCtx(ctxMenu);  /// this should be clearRECT  when I have the right position for menu>>
											////   only erase (or move) one side(track) of the Menu
			}
		}else{
			menuCount=20;

		}
		
	}



	///////// >>>>>>>>>>>>>>>>>>>>>>>>>>>>                            LIFE BAR DRAW

	var shiftBar=0;
	ctxMenuOver.clearRect(420,0, 400, 300);

	for (var i = 0; i<player1.life; i++) {

		if(shiftBar<3){
			ctxMenuOver.fillStyle = "#aa0019";	
		}else if(shiftBar>=3&&shiftBar<9){
			ctxMenuOver.fillStyle = "#bbf0019";	
		}else if(shiftBar>=9&&shiftBar<18){
			ctxMenuOver.fillStyle = "#cc0019";
		}else if(shiftBar>=18&&shiftBar<30){
			ctxMenuOver.fillStyle = "#dd0019";
		}else if(shiftBar>=30&&shiftBar<54){
			ctxMenuOver.fillStyle = "#ee0019";
		}else if(shiftBar>=54){
			ctxMenuOver.fillStyle = "#ff0019";
		}
						
		ctxMenuOver.fillRect(420+shiftBar*1.4, 20, 4, 20);

		shiftBar+=3;
	};


}/// END MenuDraw





//////^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+
//////^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+



//Menu Highlighter
function menuH(srcX, srcY, w, h, x, y, type, selec) {
	this.srcX=srcX;
	this.srcY=srcY;
	this.width = w;
	this.height = h;
	this.drawX = x;
	this.drawY = y;
	this.is = type;
	this.isSelected= selec;
}


var mBorderX = 0;
var mBorderCount = 0;
var oldmBorderCount = 0;

menuH.prototype.draw = function(){

	clearCtx(ctxMenuOver);
	clearCtx(ctxMenuOverOver);
	
	//clearCtx(ctxMenu);

	ctxMenuOverOver.font="20px Georgia";
	ctxMenuOverOver.fillStyle="blue";

	ctxMenuOverOver.fillText(bullets[player1.weaponSelected].current,170,40);

	for(var j=0; j<player1.items.length; j++){
		if(player1.items[j].itemCategory==player1.itemSelected){
			//console.log("ITEM SELECTED "+ player1.itemSelected);

			if(typeof player1.items[j] !="undefined"&&player1.items.length>1){
				ctxMenuOverOver.fillText(player1.items[j].amount ,70,40);
			}

		}
	}

	if(paused){

		if(menuTrack==0&&player1.items.length>1){

			////  SO THIS 2 HAVE TO GO ON A DIFF CANVAS >>> HIDE ON afterPAUSE

			

				/// HERE::  ANIMATION OVER itemInMenu >>> like a light reflection 	

				ctxMenuOverOver.drawImage(menuBorder, mBorderX, 0, 128, 96, 64, 0, 128, 96);
				

				mBorderCount++;

				if(mBorderCount>oldmBorderCount+2){
					oldmBorderCount=mBorderCount;
					mBorderX+=128;
				}
					            
			
		}else if(menuTrack==1){
			  
			  							////   48 + counter to make anim
				ctxMenuOverOver.drawImage(menuBorder, mBorderX, 0, 128, 96, 230, 0, 128, 96);

				mBorderCount++;

				if(mBorderCount>oldmBorderCount+2){
					oldmBorderCount=mBorderCount;
					mBorderX+=128;
				}
		}

	}// if paused

}/// END Menu Highlighter Draw


//////^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+///^)*_+







										///////   ////    ////////   //////
										//   //  /////    ////     ////
										// //// //  //    / ////// /////
										//     //   //   //     // ////
										//    //    /////// /////   /////




function pause(){
	menuH_items.draw();
	menuH_guns.draw();
	//console.log(paused);
	daMenu.draw();

	if(paused){

		player1.speed=0;
		isPlaying = false;

	//// pause IS BEING SENT TO OUTSIDE FUNCTION SO AS TO RECOURSE IT WHILE notPlaying WHILE STILL LISTENING TO KEYS 
		/// which trigger different parts of pause(function)
		requestAnimFrame(pause);
		
	}else{		 
		
		if(mBorderX>256){
			oldmBorderCount=0;
			mBorderCount=0;
			mBorderX=0;
		}
		isPlaying = true;

		///erased nonSelect Items  from screen
		clearCtx(ctxOverOverlay);

		requestAnimFrame(loop);
	}
}/// PAUSE





//||\\||//||\\||//||\\||//||\\||//||\\||//||\\||//||\\||//||\\||//||\\||//||\\||//||\\||//||\\||//||\\||//||\\||//||





						 ///              ///  ///////     ////////   //      /////
						  ///           ///   ///   ///   ///   ///  //      //  ///
						  ///  ///   ///    //      //  /////////  //       //   ///
						   ////  /////      ///   ///  ///   //   //       //  ///
							///  ///         //////   ///    //   /////// /////






////                                                                                      O B S T A C L E S
function Obstacle(id, x, y, w, h, type, status, timer, tindex) {
	this.drawX = x;
	this.drawY = y;
	this.width = w;
	this.height = h;
	this.leftX = this.drawX;
	this.rightX = this.drawX + this.width;
	this.topY = this.drawY;
	this.bottomY = this.drawY + this.height;
	this.timeToClose = timer;

	this.isDoor = type;
	this.ID = id;
	this.obstacleStatus = status;
	this.Tindex = tindex;
}// Obstacle


////                                                                                           A R E A S
function Area(number, x, y, w, h, n, type, id, doorTo, column, row, roomTo,  blocked, n2) {
	this.num=number;
	this.drawX = x;
	this.drawY = y;
	this.width = w;
	this.height = h;
	this.leftX = this.drawX;
	this.rightX = this.drawX + this.width;
	this.topY = this.drawY;
	this.bottomY = this.drawY + this.height;
	this.n = n; /////////////////////////////// area type
	this.n2 = n2;
	///area & subArea

	this.ID=id;

	this.isDoor=type;
	this.isBlocked=blocked;
	this.doorTO=doorTo;
	this.roomTo= roomTo;
	this.column = column;
	this.row = row;
}// Area

	





	
   
///////   |||||\\\\  |||||\\\\  ||\ |\ /\         //////    ///////    ////   |||||\\\\
//   //   |||||\\\\  |||||\\\\  |||||\\\\         //   //   ///  //   /////   |||||\\\\  
//////    |||||\\\\  |||||\\\\  |||||\\\\         ///  //  ///////   //////   |||||\\\\
///  //   |||||\\\\  |||||\\\\  |||/  \\\         /////   ///  //   ///////   |||||\\\\
///  ///  |||||\\\\  |||||\\\\  ||/    \\         ///    ///   //  ////////   |||||\\\\



///Global Sprites
var imgPlayer = new Image();
	imgPlayer.src = "images/playerSpriteBig.png";

var imgPlayer2 = new Image();
	imgPlayer2.src = "images/playerSpriteBig2.png";

var imgMonster= new Image();
	imgMonster.src = "images/monsterSprite.png";

var imgBullets = new Image();
	imgBullets.src = "images/bullets.png";   


var itemsMenuSprite = new Image();
	itemsMenuSprite.src = "images/items-menu.png";

var itemsPickSprite = new Image();
	itemsPickSprite.src = "images/items-pick.png";

var menuBorder = new Image();
	menuBorder.src = "images/menuhighlight2.png";


var img = new Image();
var anim = new Image();
var doorSprite = new Image();
var doorsSprite = new Image();

function roomDraw(currentRoom, area, tileMapIndex, tileWidthHeight, tileIndexX, tileIndexY, firstDraw, level){

	img.src = "images/spritesBg2.png";
	anim.src = "images/spritesAnim.png";
	doorsSprite.src = "images/doors.png";


	// Uncaught SyntaxError: Duplicate parameter name not allowed in this context
	var newTileIndexX = tileIndexX;
		
	if(currentRoom == "room-1"){

		checkTileNumbers("room-1");

		roomLengthY= roomNumberTilesY * tileWidthHeight;
		roomLengthX= roomNumberTilesX * tileWidthHeight;

		canvasWidth = roomLengthX;
		canvasHeight = roomLengthY;

		//console.log("WHAT LEVEL ?"+currentLevel);

		if(currentLevel==1){
			var mapObsL1 =  whatRoomMap("room-1");
		}else if(currentLevel==2){
			var mapObsL1 =  whatRoomMap("room-1L2");
		}

		var mapOverDraw=whatRoomMap("room-1Over");


	}else if(currentRoom == "room-2"){

		///seems to be fine having different NumberTiles per room
		checkTileNumbers("room-2");

		roomLengthY= roomNumberTilesY * tileWidthHeight;
		roomLengthX= roomNumberTilesX * tileWidthHeight;

		canvasWidth = roomLengthX;
		canvasHeight = roomLengthY;
		////////////   VAR get current room
		////////       REMEMBER THIS ROOM  >>> CURRENT ROOM = "room-2"

		var mapObsL1 =  whatRoomMap("room-2");

		var mapOverDraw=whatRoomMap("room-2Over");

	}else if(currentRoom == "room-3"){

		///seems to be fine having different NumberTiles per room
		checkTileNumbers("room-3");

		roomLengthY= roomNumberTilesY * tileWidthHeight;
		roomLengthX= roomNumberTilesX * tileWidthHeight;

		canvasWidth = roomLengthX;
		canvasHeight = roomLengthY;
		////////////   VAR get current room
		////////       REMEMBER THIS ROOM  >>> CURRENT ROOM = "room-3"

		var mapObsL1 =  whatRoomMap("room-3");

		var mapOverDraw=whatRoomMap("room-3Over");

	}/// if WHAT ROOM


	if(firstDraw=="first"){
		//// this means first pass over the tiles >> only grab what they are, regardless of what they are supposed to look like

		obstacles =[];
		areas = [];

			tilesDefine(shiftX, shiftY, img, area, {mapObsL1}, roomNumberTilesY, roomNumberTilesX, tileMapIndex, tileWidthHeight, tileIndexX, tileIndexY, newTileIndexX);

			//   cuando pisa zona 150 (area transision), roomDraw(transition, level2)  [transition se ve igual que default, pero tiene que seguir siendo eso, asi no vuelve a nivel 1..mientras siga en transition]  
			//////////////////
			//////////                         Level 2 se ve exactamente igual, con la diferencia que los blockes que te impedian entrar en level 2 desde abajo, ahora son area3(transition) caminable, y en cambio se corrieron y no te dejan bajar [un ajuste en firstDraw]... Lo demas todo igual
	}else{

		////then on second pass over Tiles is time to actually DRAW them

		/// 		  t: the tile number (same as in Map >> hooks to proper image in sprite)
		/// areaTrigger: the inside-area they belong to (at which area they will show their second sprite-hook)
		///	   those that say: "all" never show a "second sprite-hook" and simply go black when at any of these areas

		/// Re-use areas# after rooms are far enough that they won't both be visible at once  (you probably can't fit more than 5 any way)

		 tilesOverlayDraw(shiftX, shiftY, img, area, {mapOverDraw}, roomNumberTilesY, roomNumberTilesX, tileMapIndex, tileWidthHeight, tileIndexX, tileIndexY, newTileIndexX, 

		 	//tiles' Areas of interest                                   Define what AREA will trigger their b-drawing


		 	{t:100, areaTrigger:"all"}, // main Default Tile

		 	{t:102, areaTrigger:"all"}, /// 2nd Default Tile

		 	{t:103, areaTrigger:"uno"}, /// 3nd Default Tile


		 	{t:104, areaTrigger:"all"},  // default: rocky ground


		 	{t:107, areaTrigger:"uno"},    // a: roof-edge | b: black

		 	{t:109, areaTrigger:"uno"},    /// a: roof  | b: In-fakeWall


		 	{t:113, areaTrigger:"dos"}, // default Tile in and out (area 2)
		 	{t:114, areaTrigger:"dos"}, // same as 113, but higher perspective, looks like inside


		 	{t:150, areaTrigger:"all"},  // <<<< TELEPORT AREA


		 	{t:960, areaTrigger:"all"}, 
		 	{t:961, areaTrigger:"all"},
		 	{t:962, areaTrigger:"all"}, 
		 	{t:963, areaTrigger:"all"},
		 	{t:964, areaTrigger:"all"},
		 	{t:965, areaTrigger:"all"},
		 	{t:966, areaTrigger:"all"},
		 	{t:967, areaTrigger:"all"},
		 	{t:968, areaTrigger:"all"}, 
		 	{t:970, areaTrigger:"all"},
		 	{t:969, areaTrigger:"all"}, 
		 	{t:971, areaTrigger:"all"}, 
		 	{t:972, areaTrigger:"all"}, 
		 	{t:973, areaTrigger:"all"}, 
		 	{t:974, areaTrigger:"all"}, 

		 	{t:980, areaTrigger:"all"}, 
		 	{t:981, areaTrigger:"all"}, 
		 	{t:982, areaTrigger:"all"}, 
		 	{t:983, areaTrigger:"all"}, 
		 	{t:984, areaTrigger:"all"}, 
		 	{t:985, areaTrigger:"tres"},
		 	{t:986, areaTrigger:"all"}, 
		 	{t:987, areaTrigger:"all"},	


			{t:200, areaTrigger:"uno"}, // in floor - out roof1
		 	{t:207, areaTrigger:"uno"}, // in floor - out wall1
		 	{t:210, areaTrigger:"uno"},// in nothing - out roof (over in-doors)

			{t:300, areaTrigger:"uno"}, // in wall - out roof
		 	{t:301, areaTrigger:"uno"}, // in wall(left angle) - out roof
		 	{t:302, areaTrigger:"uno"}, // in wall(right angle) - out roof (supposedly)


		 	{t:220, areaTrigger:"dos"}, // in floor - out roof
		 	{t:221, areaTrigger:"dos"}, // in floor - out roof
		 	{t:227, areaTrigger:"dos"}, // in floor - out wall

		 	{t:230, areaTrigger:"dos"}, // in nothing - out roof (over in-doors)




		 	{t:320, areaTrigger:"dos"}, /// in wall - out roof
		 	{t:321, areaTrigger:"dos"}, /// in wall(left angle) - out roof
		 	{t:323, areaTrigger:"dos"},
	

		 	{t:240, areaTrigger:"tres"}, // in nothing - out roof (over in-doors)
			{t:247, areaTrigger:"tres"}, // in floor - out wall

			{t:330, areaTrigger:"tres"}, // in nothing - out roof (over in-doors)
			{t:331, areaTrigger:"tres"}, // in floor - out wall
			{t:332, areaTrigger:"tres"}, // in nothing - out roof (over in-doors)
			
			{t:250, areaTrigger:"cuatro"}, // in nothing - out roof (over in-doors)
			{t:257, areaTrigger:"cuatro"}, // in floor - out wall

			{t:350, areaTrigger:"dos"}, /// in wall - out roof
		 	{t:351, areaTrigger:"dos"}, /// in wall(left angle) - out roof
		 	{t:353, areaTrigger:"dos"},

		 	{t:333, areaTrigger:"all"}, /// GENERIC obstacle
		 	{t:344, areaTrigger:"all"}, // GENERIC obstacle diff
		 	{t:355, areaTrigger:"all"}, // GENERIC obstacle diff

		 	{t:334, areaTrigger:"all"}, /// same as 333, but is not drawn over player (so it stays under door)
		 	{t:335, areaTrigger:"all"}, 
		 	{t:336, areaTrigger:"all"}, /// same as 333, but is not drawn over player (so it stays under door)

		 	{t:337, areaTrigger:"all"}, /// GENERIC obstacle  /// borde falso
		 	{t:338, areaTrigger:"all"}, /// GENERIC obstacle  // diagonal derecha
		 	{t:339, areaTrigger:"all"}, /// GENERIC obstacle  // diagonal izq


		 	{t:306, areaTrigger:"all"}, // in black - out roof                         DEBERIA SER OTRO NUMERO

		 	{t:340, areaTrigger:"all"}, // in black - out roof (right-angle)  HALF ROOF HALF FLOOR
		 	{t:341, areaTrigger:"all"}, // in black - out roof (left-angle)  HALF ROOF HALF FLOOR
		 	{t:342, areaTrigger:"all"}, // in black - out roof (right-angle)  HALF ROOF HALF WALL
		 	{t:343, areaTrigger:"all"}, // in black - out roof (left-angle)  HALF ROOF HALF WALL



		 	{t:370, areaTrigger:"all"}, // breakable (comes back)
		 	{t:371, areaTrigger:"all"}, // breakable Normal

		 	{t:390, areaTrigger:"all"}, // Obstacle - item
		 	{t:391, areaTrigger:"all"}, // Rocky-slow ground


		 	{t:349, areaTrigger:"tres"},
		 	

			{t:428, areaTrigger:"all"}, // out 1
		 	
		 	{t:401, areaTrigger:"uno"}, // in 1
		 	{t:402, areaTrigger:"uno"}, // in 1
		 	{t:403, areaTrigger:"uno"}, // in 1

		 	{t:572, areaTrigger:"uno"}, // in 4
		 	{t:573, areaTrigger:"uno"}, // in 4

		 	 
		 	{t:578, areaTrigger:"dos"}, // in 4
		 	{t:512, areaTrigger:"dos"}, // in 4-2 (4 de lado >> 2)

		 	{t:456, areaTrigger:"dos"}, // in 1-2 (1 de frente >> 2)


		 	/// doors Rooms  out
		 	{t:702, areaTrigger:"dos"}, 
		 	{t:700, areaTrigger:"uno"}, 
		 	{t:701, areaTrigger:"uno"},
		 	{t:703, areaTrigger:"uno"},
		 	{t:674, areaTrigger:"all"}, 
		 	/// doors Rooms  in
		 	// {t:740, areaTrigger:"all"}, 
		 	{t:750, areaTrigger:"uno"},
		 	{t:751, areaTrigger:"tres"}

		 	); 

	}/// if first pass (define) or second+ (draw)

	
}/// roomDraw





/// a: outside Area, b: inside ITS area ..  
//											This could also be subject to whatRoom you are in, changing the drawingCoordinates accordingly								 

///if room 1 >>>   room 2,3 >> slightly different drawings
var tileBgMap=[
/// Tiles coordinates in Sprite


	{n:100, xA:64, xB:0, yA:0, yB:0}, 
	{n:102, xA:128, xB:0, yA:0, yB:0},
	{n:103, xA:192, xB:0, yA:0, yB:0},


	{n:104, xA:704, xB:0, yA:0, yB:0},	


	{n:113, xA:320, xB:320, yA:64, yB:64},
	{n:114, xA:320, xB:320, yA:0, yB:0},

	{n:150, xA:0, xB:0, yA:0, yB:0}, 


	{n:107, xA:768, xB:0, yA:64, yB:0},

	{n:109, xA:768, xB:1024, yA:0, yB:0},


	{n:960, xA:0, xB:0, yA:0, yB:0},  ///anim sprites
	{n:961, xA:0, xB:0, yA:0, yB:0},  ///anim sprites
	{n:962, xA:0, xB:0, yA:0, yB:0},  ///anim sprites
	{n:963, xA:0, xB:0, yA:0, yB:0},  ///anim sprites
	{n:964, xA:0, xB:0, yA:0, yB:0},  ///anim sprites
	{n:965, xA:0, xB:0, yA:0, yB:0},  ///anim sprites
	{n:966, xA:0, xB:0, yA:0, yB:0},  ///anim sprites
	{n:967, xA:0, xB:0, yA:0, yB:0},  ///anim sprites
	{n:968, xA:0, xB:0, yA:0, yB:0}, 
	{n:970, xA:192, xB:0, yA:0, yB:0},  ///anim sprites
	{n:969, xA:192, xB:0, yA:320, yB:0},  ///anim sprites

	{n:971, xA:192, xB:0, yA:0, yB:0},  ///anim sprites
	{n:972, xA:192, xB:0, yA:0, yB:0},  ///anim sprites
	{n:973, xA:192, xB:0, yA:0, yB:0},  ///anim sprites
	{n:974, xA:192, xB:0, yA:0, yB:0},  ///anim sprites

	{n:980, xA:384, xB:0, yA:0, yB:0},   ///anim sprites
	{n:981, xA:576, xB:0, yA:0, yB:0},   ///anim sprites
	{n:982, xA:576, xB:0, yA:0, yB:0},   ///anim sprites
	{n:983, xA:576, xB:0, yA:0, yB:0},	 ///anim sprites
	{n:984, xA:576, xB:576, yA:0, yB:0},	 ///anim sprites
	{n:985, xA:576, xB:576, yA:0, yB:0},	
	{n:986, xA:960, xB:0, yA:0, yB:0},  ///anim sprites
	{n:987, xA:960, xB:0, yA:0, yB:0},  ///anim sprites


	{n:200, xA:832, xB:320, yA:0, yB:0},
	{n:207, xA:576, xB:320, yA:0, yB:0},
	{n:210, xA:576, xB:0, yA:0, yB:64},

	{n:300, xA:768, xB:960, yA:0, yB:0},
	{n:301, xA:832, xB:960, yA:0, yB:64},
	{n:302, xA:832, xB:960, yA:0, yB:128},

	{n:220, xA:768, xB:320, yA:0, yB:0},
	{n:221, xA:768, xB:384, yA:0, yB:0},
	{n:227, xA:576, xB:320, yA:0, yB:0},
	{n:230, xA:768, xB:0, yA:0, yB:64},

	{n:320, xA:768, xB:960, yA:0, yB:0},
	{n:321, xA:768, xB:960, yA:0, yB:64},
	{n:323, xA:768, xB:0, yA:0, yB:0},

	{n:240, xA:640, xB:320, yA:0, yB:0},
	{n:247, xA:768, xB:320, yA:0, yB:0},

	{n:330, xA:768, xB:960, yA:0, yB:0},
	{n:331, xA:768, xB:960, yA:0, yB:64},
	{n:332, xA:768, xB:0, yA:0, yB:0},

	{n:250, xA:640, xB:320, yA:0, yB:0},
	{n:257, xA:768, xB:320, yA:0, yB:0},

	{n:350, xA:768, xB:960, yA:0, yB:0},
	{n:351, xA:768, xB:960, yA:0, yB:64},
	{n:352, xA:768, xB:0, yA:0, yB:0},

	
	{n:333, xA:768, xB:0, yA:0, yB:0},
	{n:334, xA:576, xB:0, yA:0, yB:0},
	{n:335, xA:640, xB:0, yA:0, yB:0},

	{n:336, xA:768, xB:0, yA:0, yB:0},

	{n:306, xA:832, xB:0, yA:0, yB:0},

	{n:337, xA:192, xB:0, yA:0, yB:0},

	{n:338, xA:576, xB:0, yA:64, yB:0},
	{n:339, xA:576, xB:0, yA:128, yB:0},


	{n:340, xA:128, xB:0, yA:0, yB:0},
	{n:341, xA:128, xB:0, yA:0, yB:0},
	{n:342, xA:576, xB:0, yA:0, yB:0},      
	{n:343, xA:576, xB:0, yA:0, yB:0}, 

	{n:344, xA:576, xB:0, yA:0, yB:0}, 

	{n:355, xA:896, xB:0, yA:0, yB:0},

	{n:370, xA:768, xB:0, yA:0, yB:0},
	{n:371, xA:768, xB:0, yA:0, yB:0},

	{n:390, xA:384, xB:0, yA:64, yB:0},
	{n:391, xA:256, xB:0, yA:0, yB:0},



	{n:349, xA:832, xB:0, yA:0, yB:192},



	{n:428, xA:64, xB:0, yA:0, yB:0}, 
	
	{n:401, xA:832, xB:320, yA:0, yB:0},
	{n:402, xA:768, xB:320, yA:0, yB:0},
	{n:403, xA:768, xB:320, yA:0, yB:0},
	{n:572, xA:768, xB:320,  yA:0, yB:0}, 
	{n:573, xA:320, xB:320,  yA:0, yB:0}, 

	{n:456, xA:768, xB:320, yA:0, yB:0},
	{n:578, xA:768, xB:320, yA:0, yB:0},
	{n:512, xA:768, xB:320, yA:0, yB:0},


	
	{n:704, xA:720, xB:0, yA:0, yB:0},
	{n:700, xA:768, xB:1280, yA:0, yB:0},//dos
	{n:701, xA:1216, xB:0, yA:0, yB:0},
	{n:703, xA:1216, xB:0, yA:0, yB:0},

	{n:702, xA:1152, xB:0, yA:0, yB:0}, 

	// {n:740, xA:1152, xB:0, yA:0, yB:0},
	{n:750, xA:0, xB:1344, yA:0, yB:0},
	{n:751, xA:0, xB:1344, yA:0, yB:0}
]




			   /////////  //   ///      ///////         ///////  //////   ////// ||  ||| ||  //////  
				   ///    //    //      //              ///  //  ///     ////    ||  ||\\||  ///     
				   ///    //    //      ///             //   //  ////    //      ||  || \\|  ////      
				   ///    //    //////  ///////         /////    //////  //      ||  ||  \\  //////   


var inActID;
var inAct=false;

/// tilesDefine - level2  >>> this 2 defineLevel 1-2 functions >> they define what is what>>>  later, tilesOverlayDraw actually DRAWS the tiles you see on the screen

function tilesDefine(newShiftX, newShiftY, img, area, {mapObsL1}, roomNumberTilesY, roomNumberTilesX, tileMapIndex, tileWidthHeight, tileIndexX, tileIndexY, newTileIndexX){

	inAct=false;
		
	/// Aqui se llenan los arrays de areas[] y obstacles[]
	for(var i =0; i<roomNumberTilesY; i++){
		for(var e=0; e<roomNumberTilesX; e++){



			if(mapObsL1[tileMapIndex].toString().substring(0,1)==1){ ///////// area (default)

				if(mapObsL1[tileMapIndex]==195){ 
					areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "transition"));

				///// TELEPORT areas
				}else if(mapObsL1[tileMapIndex]==150){ // & maybe many other >> diff types/colors of water
					areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight,"default", null, null, null, null, null, null, null, "teleportArea"));


				//// ANIM areas
				}else{
					areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "default"));
				}	
			
			/// if mapObsL1[tileMapIndex] ==1...	 
			}else if(mapObsL1[tileMapIndex].toString().substring(0,2)>=92){ ///////// area (default)

				/////////  TRANSITION areas
				if(mapObsL1[tileMapIndex]==960){ // & maybe many other >> diff types/colors of water
					areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight,"default", null, null, null, null, null, null, null, "water"));

				}else if(mapObsL1[tileMapIndex]==969){ // & maybe many other >> diff types/colors of water
					obstacles.push(new Obstacle(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "wall", "closed", null, tileMapIndex));

				}else if(mapObsL1[tileMapIndex]==970){ 

					areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight,"default", null, null, null, null, null, null, null, "deep-water"));
					
				}else if(mapObsL1[tileMapIndex]==986){ 

					areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight,"default", null, null, null, null, null, null, null, "quicksand"));
					
				}else if(mapObsL1[tileMapIndex]==987){ 

					areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight,"default", null, null, null, null, null, null, null, "deep-sand"));
					
				}else if(mapObsL1[tileMapIndex]==980){ 
					areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight,"default", null, null, null, null, null, null, null, "orange-lava"));

				}else if(mapObsL1[tileMapIndex]==981){ 

					areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight,"default", null, null, null, null, null, null, null, "red-lava"));
				}else if(mapObsL1[tileMapIndex]==984){ 

					areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight,"default", null, null, null, null, null, null, null, "red-lava"));
				}else if(mapObsL1[tileMapIndex]==985){ 

					areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight,"tres", null, null, null, null, null, null, null, "red-lava"));
				}




			}else if(mapObsL1[tileMapIndex]>=300&&mapObsL1[tileMapIndex]<350){ ///////// obstacle out

				//NORMAL OBSACLES
				obstacles.push(new Obstacle(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "wall", "closed", null, tileMapIndex));


			}else if(mapObsL1[tileMapIndex]>=350&&mapObsL1[tileMapIndex]<371){ ///////// obstacle in area

			/// BREAKABLE WITH COME BACKS

				inAct=false;
				//console.log("INACTIVE?? "+inActiveObstacle.length);

				areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight,"default"));

					
					if(inActiveObstacle.length==0){
						obstacles.push(new Obstacle(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "door", "closed", 100, tileMapIndex));
					}else{
						///WHATS HAPPENING:
						/// inAct keeps track of whether this Tile's number has had any match within the inActiveObstacle Obstacles.
						// if at any poin it did, then doesn't matter what happens, inAct is true and the obstacle is not (this way it waits for the whole inActiveObstacle-obs Array to finish before deciding to draw or not)

						
						for (var a = 0; a < inActiveObstacle.length; a++) {

							if(inActiveObstacle[a].ID==mapObsL1[tileMapIndex]&&inActiveObstacle[a].time>0||inActiveObstacle[a].ID==mapObsL1[tileMapIndex]&&inActiveObstacle[a].time==null){

								if(mapObsL1[tileMapIndex]!=390&&inActiveObstacle[a].tindex==tileMapIndex){
									inAct=true;

									inActID = mapObsL1[tileMapIndex];   /// HAS TO BE ARRAY FOR MULTIPLE
									memberIndex = 	tileMapIndex;
								}else if(mapObsL1[tileMapIndex]==390){
									inAct=true;

									inActID = mapObsL1[tileMapIndex];   /// HAS TO BE ARRAY FOR MULTIPLE
									memberIndex = 	tileMapIndex;
								}
								
							}else if(inActiveObstacle[a].ID!=mapObsL1[tileMapIndex]){

								
								if(!inAct){
									inAct=false;
								}		 
							}

						}// FOR inActiveObstacle

						if(inAct&&mapObsL1[tileMapIndex]==inActID&&tileMapIndex==memberIndex){

							obstacles.push(new Obstacle(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "door", "open", 100,  tileMapIndex));	
						}else{
							obstacles.push(new Obstacle(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "door", "closed", 100,  tileMapIndex));		
						}
					}// if 4 Active


			//// AREAS	
			}else if(mapObsL1[tileMapIndex]>=371&&mapObsL1[tileMapIndex]<=390){ ///////// obstacle in area
					 
				inAct=false;

				/// NORMAL BREAKABLE + innaccessible until item

				areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight,"default"));

					
					if(inActiveObstacle.length==0){
						obstacles.push(new Obstacle(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "door", "closed", null, tileMapIndex));
					}else{
						///WHATS HAPPENING:
						/// inAct keeps track of whether this Tile's number has had any match within the inActiveObstacle Obstacles.
						// if at any poin it did, then doesn't matter what happens, inAct is true and the obstacle is not (this way it waits for the whole inActiveObstacle-obs Array to finish before deciding to draw or not)

						
						for (var a = 0; a < inActiveObstacle.length; a++) {

							
							if(inActiveObstacle[a].ID==mapObsL1[tileMapIndex]&&inActiveObstacle[a].time>0||inActiveObstacle[a].ID==mapObsL1[tileMapIndex]&&inActiveObstacle[a].time==null){

								if(mapObsL1[tileMapIndex]!=390&&inActiveObstacle[a].tindex==tileMapIndex){
									inAct=true;

									inActID = mapObsL1[tileMapIndex];   /// HAS TO BE ARRAY FOR MULTIPLE
									memberIndex = 	tileMapIndex;
								}else if(mapObsL1[tileMapIndex]==390){
									inAct=true;

									inActID = mapObsL1[tileMapIndex];   /// HAS TO BE ARRAY FOR MULTIPLE
									memberIndex = 	tileMapIndex;
								}
								
							}else if(inActiveObstacle[a].ID!=mapObsL1[tileMapIndex]){

								
								if(!inAct){
									inAct=false;
								}
										 
							}
						}

						if(inAct&&mapObsL1[tileMapIndex]==inActID&&tileMapIndex==memberIndex){

							obstacles.push(new Obstacle(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "door", "open", null,  tileMapIndex));	
						}else{
							obstacles.push(new Obstacle(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "door", "closed", null,  tileMapIndex));		
						}
					}// if 4 Active

				/// end if tile 166
				

			//// AREAS	
			}else if(mapObsL1[tileMapIndex]==391){

				areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "default", null, null, null, null, null, null, null, "rocks"));

			}




					//////////////    A R E A S

			else if(mapObsL1[tileMapIndex]>=200&&mapObsL1[tileMapIndex]<211){ ///////// area 1

				areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "uno"));
			
			}else if(mapObsL1[tileMapIndex]>=220&&mapObsL1[tileMapIndex]<230){ ///////// area 1

				areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "dos"));

			}else if(mapObsL1[tileMapIndex]==230){ ///////// area 1

					 
				areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "dos"));


					//// INSIDE DOORS
			}else if(mapObsL1[tileMapIndex]>=240&&mapObsL1[tileMapIndex]<250){ ///////// area 1

					 
				areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "tres"));


					//// INSIDE DOORS
			}else if(mapObsL1[tileMapIndex]>=250&&mapObsL1[tileMapIndex]<261){ ///////// area 1

					 
				areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "cuatro"));


					//// INSIDE DOORS
			}





			else if(mapObsL1[tileMapIndex].toString().substring(0,1)>=4&&mapObsL1[tileMapIndex].toString()<674){ ///////// doors

				if(mapObsL1[tileMapIndex]==401||mapObsL1[tileMapIndex]==402||mapObsL1[tileMapIndex]==403||mapObsL1[tileMapIndex]==572||mapObsL1[tileMapIndex]==573){
					areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "uno"));
				}else if(mapObsL1[tileMapIndex]==456||mapObsL1[tileMapIndex]==578||mapObsL1[tileMapIndex]==512){
					areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "dos"));
				}else{
					areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "default"));
				}
				inAct=false;

			
				doorTiles.push({id:mapObsL1[tileMapIndex], index:tileMapIndex});

						
				if(inActiveObstacle.length==0){
					obstacles.push(new Obstacle(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "door", "closed", 195, tileMapIndex));
				}else{
					///WHATS HAPPENING:
					/// inAct keeps track of whether this Tile's number has had any match within the inActiveObstacle Obstacles.
					// if at any poin it did, then doesn't matter what happens, inAct is true and the obstacle is not (this way it waits for the whole inActiveObstacle-obs Array to finish before deciding to draw or not)

					// repeat same for breakableObstacles
					//console.log(inAct);

					for (var a = 0; a < inActiveObstacle.length; a++) {

						if(inActiveObstacle[a].ID==mapObsL1[tileMapIndex]&&inActiveObstacle[a].time>0){
							
							inAct=true;
									
						}else if(inActiveObstacle[a].ID!=mapObsL1[tileMapIndex]){
							if(!inAct){
								inAct=false;
							}
									 
						}
					}

					if(inAct){

						obstacles.push(new Obstacle(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "door", "open", 195, tileMapIndex));	
					}else{
						obstacles.push(new Obstacle(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "door", "closed", 195, tileMapIndex));		
					}
				}// if 4 Active

				inAct=false;
						

					//// OUTSIDE DOORS	
			}
			

			if(mapObsL1[tileMapIndex]==740){ ///////// doorTOs
					 
				areas.push(////////////////////////////////    //  IMPORTANT!!!  after "door"=.n >> 888 = id, 885, dooTo >>> door is going to
										/////// now here below, this room it is going to (888)>> 888 tile has to be given it's 885 id so dootTo here MATCHES!!
										///first is ID of this door, then ID doorItIsGoinggTo
				new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "default", "door", 740, 750, tileIndexX, tileIndexY,"room-3", null, "water"));
			}else if(mapObsL1[tileMapIndex]==750){ ///////// doorTO in area
					 
				areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "uno", "door", 750, 740, tileIndexX, tileIndexY,"room-1"));
			}else if(mapObsL1[tileMapIndex]==751){ /////////  doorTOout
					 
				areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "tres", "door", 751, 700,tileIndexX, tileIndexY,  "room-3"));
			}else if(mapObsL1[tileMapIndex]==700){ ///////// doorTO in area
					 
				areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "uno", "door", 700, 751, tileIndexX, tileIndexY, "room-3"));
			}else if(mapObsL1[tileMapIndex]==701){ ///////// doorTO in area
					 
				areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "default", "door", 701, 700, tileIndexX, tileIndexY, "room-1"));
			}else if(mapObsL1[tileMapIndex]==702){ /////////  doorTOout
					 
				areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "default", "door", 702, 703,tileIndexX, tileIndexY,  "room-2",));
			}else if(mapObsL1[tileMapIndex]==703){ /////////  doorTOout
					 
				areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "tres", "door", 703, 702,tileIndexX, tileIndexY,  "room-1",));
			}else 

			// if(mapObsL1[tileMapIndex]==502){ /////////  doorTOout
					 
			// 	areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "default", "door", 502, 501,tileIndexX, tileIndexY,  "room-2",));
			// }else 

			if(mapObsL1[tileMapIndex]==674){ /////////  doorTOout
					 
				areas.push(new Area(mapObsL1[tileMapIndex], tileIndexX+shiftX, tileIndexY+shiftY, tileWidthHeight, tileWidthHeight, "default", "door", 674, 674,tileIndexX, tileIndexY,  "room-1",));
			}

			tileIndexX+= tileWidthHeight;

			tileMapIndex++;

		}// FORroomNumberTilesX

		tileIndexY+=tileWidthHeight;
		tileIndexX=newTileIndexX;

	}// FOR roomNumberTilesY

	getDoors();



	if(poweroff){
		///here gotta check and re-open every time. Why? I was having the problem that if the switch is not in the same room as the obstacles, doorOpen(FUNC) would miss them
																									/// since the obstacles it's looking for are not thre (not on that room)
		doorOpen(390);

	}

} /////  END TILES DEFINE






////////////// //////// //////// ////// ///  >>>>>>>>>>>>>>>>>>>>                             G E T    D O O R S


function getDoors(){
	
	doors=[];


	for (var ll=0; ll<doorTiles.length; ll++){
		
		if(doors.length==0){
			//console.log("WHAT?? "+memberD);
														/// force open on start (define & here) those doors that start opened
			doors.push({id:doorTiles[ll].id, index:doorTiles[ll].index, c:1, doorStatus:"closed", timeToClose:0, area:"uno", anim:0});
			//console.log(doors[0].id + " " +doors[0].index + " " +doors[0].c);
		}else{

			var memberN;
			var match=false;

			for (var hh=0; hh<doors.length; hh++) {
				if(doorTiles[ll].id==doors[hh].id){
					
					match=true;
					memberN=hh;

				}else{
					if(match!=true){
						match=false;
					}	
				}
			}

			if(!match){													/// force open on start (define & here) those doors that start opened
				doors.push({id:doorTiles[ll].id, index:doorTiles[ll].index, c:1, doorStatus:"closed", timeToClose:0, area:"uno", anim:0});
			}else{
				doors[memberN].c++;
				//console.log(doors[memberN].id + " " +doors[memberN].index + " " +doors[memberN].c);
			}
		}
	}// FOR doorTiles

	doorTiles=[];////  its being done 3 times on start, I don't know why (at least one for relocation of player, but the third one?)
	/// I leave door on top, cause I wanna keep it, whereas this one depends on info coming from the top, and can be discharted after use


////////////													
/////										D E F I N E    O P E N    D O O R S				
//////
	//// so here run the obstacles(& equivalent door) and decide which ones start opened! >> and open
	// for (var p=0; p< obstacles.length; p++ ) {
	// 	if(obstacles[p].ID==350){
	// 		obstacles[p].timeToClose=null; /// if it is to be activated later, it can be done likewise.. but this has to be null, or else it will shut up, or (270) not show the changes
	// 		doorOpen(obstacles[p].ID, obstacles[p].timeToClose, obstacles[p].Tindex);
	// 	}
	// }

	//console.log("TILE "+doorTiles[ll].id +"   "+doorTiles[ll].index);
	


	for (var f=0; f<doors.length; f++) {

		if(doors[f].id==456||doors[f].id==578||doors[f].id==512){
			//console.log(doors[f].id);
			doors[f].area="dos";

			for (var u=0; u<inActiveObstacle.length; u++) {

				if(inActiveObstacle[u].ID==doors[f].id){
					doors[f].anim=384;
				}
			}	

		}else if(doors[f].id==401||doors[f].id==402||doors[f].id==403||doors[f].id==573){
			//console.log(doors[f].id);
			doors[f].area="uno";

			for (var u=0; u<inActiveObstacle.length; u++) {

				if(inActiveObstacle[u].ID==doors[f].id){
					doors[f].anim=384;
				}
			}	

		}else if(doors[f].id>=428&&doors[f].id<456){
			doors[f].area="default";

			////dirty hack.. i don't know why this one nees this and the others don't
			for (var u=0; u<inActiveObstacle.length; u++) {

				if(inActiveObstacle[u].ID==doors[f].id){
					doors[f].anim=384;
				}
			}	
		}

		var openORclosed;
		var memberD;

		if(inActiveObstacle.length>=1){
			for(var ff=0; ff<inActiveObstacle.length; ff++){
				
				if(doors[f].id == inActiveObstacle[ff].ID){
					//console.log("INACTIVE ID =" + inActiveObstacle[ff].ID);
					
					doors[f].doorStatus="open";
				}else{
					if(doors[f].doorStatus!="open"){
						doors[f].doorStatus="closed";
						
					}
				}
				
			}
		}
	}/// FOR doors.length

}/// FUNC GET DOORS















													      //\               
														 ///\\				   //\ 
			     ///////  //    //      ////|            //////     ///////   // \    |||||\
				   ///    //    //      //               //   //   ///  //   //  \   |/   \\
				   ///    //    //      //|              //  ///  ///////   //   \   |/   \\
				   ///    //    //////  ////|            /////   //  //    //____\   \||||\
				   										 ///			  //     \




var areaEdgeX=0;

/// for flashes and light effects
var yAnim=0;
var yyAnim=0;
var yyyAnim=0;
var xxAnim=0;// animated tiles have a slightly diff sprite layout
/// for animation effects
var xAnim=0;
var xAnimSandCounter=0;
/// for animation effects
var xAnimCounter=0;

var animC=0;

var doorCollection="not-done";

//// ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);


function tilesOverlayDraw(newShiftX, newShiftY, img, area, {mapOverDraw}, roomNumberTilesY, roomNumberTilesX, tileMapIndex, tileWidthHeight, tileIndexX, tileIndexY, newTileIndexX){

	if(!paused){
		xAnimCounter++;  /// moves ANIM-frames for the animated tiles
		xAnimSandCounter++;
	}



	//// this will take the tiles sent by  tilesDefineOver after this standard parameters
	var defaultTiles = [];
	/// j =11>>  11 are the arguments we got in tilesOverlayDraw() - The tiles we want to get come after and we don't know how many they could be...
	for(var j=0; j < arguments.length; j++){
		if(j>11){
			///... after the arguments (11) we store this SpriteTile coordinate values in an array defaultTiles...
			defaultTiles.push(arguments[j]);
		}
	}////////////  



	var srcX;
	var srcY;

	var columnsPerRow=0;
	var countingColumns=0;
	var columnsPerRow2=0;
	var countingColumns2=0;

	var done=false;
	
	/// menuMap back-ground >> drawn only once, underneath  >> and probably make some for items/guns
	ctxMapOverMenu.fillStyle = "#000";					
ctxMapOverMenu.fillRect(0, 0, canvasMapOverMenu.width, canvasMapOverMenu.height);


	for(var i=0; i<roomNumberTilesY; i++){

		for(var e=0; e<roomNumberTilesX; e++){


			for(var j=0; j < defaultTiles.length; j++){	


				if(mapOverDraw[tileMapIndex]==defaultTiles[j].t){ 


						if(!done){
							// IF tiles != DOORS:
							if(area=="default"||area=="transition"){ 
								///+ other outside areas

								/// tiles OUTside areas
								srcX=getTileX(defaultTiles[j].t, "xA");
								srcY=getTileY(defaultTiles[j].t, "yA");

									///// defaultTiles[j].areaSECONDTrigger ??? for some> and null on the rest?
							}else if(area==defaultTiles[j].areaTrigger||defaultTiles[j].areaTrigger=="all"){
								//////  SPECIFY ALL NUMBR OF AREAS + FLASH STATES.....

								/// tiles INside areas
								srcX=getTileX(defaultTiles[j].t, "xB");
								srcY=getTileY(defaultTiles[j].t, "yB");
							}else{
								srcX=0;
								srcY=0;	
							}
						}///  Tiles draws SET

						
				

					done=false; // goes back to false to check next Tile (maybe a door, maybe not)
					


					//// DO  C AREAS FOR IN-WALLS!!!



					//     	   TILE  
					//		   SRC
                    //\\      ///
				      //\\  ///   	
			           //////   
				       //\\\\    
			          ///  \\\     
				    ///     \\\\

					//  TILE srcX >> Area-PAIR COMBINATIONS
					function getTileX(tileID, tileAreaX){
	
						


						for(var k = 0; k <tileBgMap.length; k++){
							if(tileID==tileBgMap[k].n){
								if(tileAreaX =="xA"){
									return tileBgMap[k].xA;
								}else if(tileAreaX =="xB"){
									return tileBgMap[k].xB;
								}
							}
						}/// FOR tileBgMap.length
						
					}// FUNC getTileX


					//      TILE  
					//		SRC
					//	    ||
					 //   ///
					  ///// 
					 ////
					///  
				   //

					// TILE src Y  SAME TO ALL <<<<<  this is what is manipulated to control "flashes" and such
					function getTileY(tileID, tileAreaY){
	

						for(var k = 0; k <tileBgMap.length; k++){
							if(tileID==tileBgMap[k].n){
								if(tileAreaY =="yA"){
									return tileBgMap[k].yA;
								}else if(tileAreaY =="yB"){
									return tileBgMap[k].yB;
								}
							}
						}/// FOR tileBgMap.length
						
					}// FUNC getTileY


					//spriteANIM
					yyAnim=0;
					yyyAnim=0;
					xxAnim=0;
					//spriteBG
					yAnim=0;
					/// MAKE MOREE (sprite DOOR , sprite EDGES) & add yAnim to overtiles

					if(flash==1){
						//console.log("FLASH "+flash);
						yAnim+=288;
						yyAnim=336;
						yyyAnim=144;
						xxAnim=192;
					}else if(flash==2){
						//console.log("FLASH "+flash);
						yAnim+=576;
						yyAnim=672;
						yyyAnim=288;
						xxAnim=384;
					}


					//\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\	 \\\\\	\\\\	 \\\\\	\\\\	 \\\\\	\\\\	 \\\\\	\\\\	 \\\\\	\\\\	 \\\\\	\\  ////
					//\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


					//\///\\//\  ///////    ///    //  /    ///         //\///\\//\   	 ///\      //////// 
					///\\\\\\\\  ///       /////  //  /    ///          ///\\\\\\\\     /\\\ \     //   //
					///\\\\\\\\  /////    /// // //  /    ///           ///\\\\\\\\    ////\ \\    //////
					//// \/ \\\  ///     ///  ////  /    ///            //// \/ \\\   ////  \\ \   //
					///    \ \\  //////////   ///  ////////             ///    \ \\  ////    \ \\  //

					// Menu Map here so Tiles have been Defined already (as dependent on them)

					//////  gameCounter Global, or else, if placed within here, the dot flickers faster in other Rooms

					///flicker FX
				
					if(pauseType!="teleport"){

						if(gameCounter<22){

							ctxMapOverMenu.fillStyle = "#83ff00";
							if(!player1.isDead){  ///divided by has to do with aspect ratio
								ctxMapOverMenu.fillRect(15+player1.drawX/16+5, 13+player1.drawY/16+2.4, 6, 6);
							}

						}else if(gameCounter>=22&&gameCounter<30){

							// nada
						}else if(gameCounter>=30){
							gameCounter=0; /// rinse & repeat	
						}


						if(radar){
						
							/// 1
							if(defaultTiles[j].t.toString().substring(0,2)>=92){

								if(defaultTiles[j].t.toString()>=960&&defaultTiles[j].t.toString()<969){
									ctxMapOverMenu.fillStyle = "#ea0000";
								}else if(defaultTiles[j].t.toString()>969&&defaultTiles[j].t.toString()<=973){
									ctxMapOverMenu.fillStyle = "#a90000";

								}else if(defaultTiles[j].t.toString()==986){
									///path in the sand!
									ctxMapOverMenu.fillStyle = "#111100";
								}else if(defaultTiles[j].t.toString()==969){
								ctxMapOverMenu.fillStyle = "#b20000";

								}else{
									ctxMapOverMenu.fillStyle = "#000";
								}
								ctxMapOverMenu.fillRect(18+e*4+(shiftX/16), 16+i*4+(shiftY/16), 4.5, 4.5);
							}

							/// 2
							if(defaultTiles[j].t.toString().substring(0,1)==3){

								/// if 270 >>> loop inActive >>> match ID? repaint this too!

								if(defaultTiles[j].t.toString()==390){
									ctxMapOverMenu.fillStyle = "#000";
								}else if(defaultTiles[j].t.toString()==391){
									ctxMapOverMenu.fillStyle = "#000";
								}else if(defaultTiles[j].t.toString()==370){

									//// hidden doors slightly sharper <<<<  have to go through this type of door to first get radar!
																			/// and there might still be other type of breakable doors that go undetected (radar twist!, don't rely on your items only...)
									ctxMapOverMenu.fillStyle = "#aa0000";
								}else{
									ctxMapOverMenu.fillStyle = "#b20000";
								}
								
								ctxMapOverMenu.fillRect(18+e*4+(shiftX/16), 16+i*4+(shiftY/16), 4.5, 4.5);
							}

							/// 3 -> 5
							if(defaultTiles[j].t.toString().substring(0,1)>=4&&defaultTiles[j].t.toString()<674){

								/// if 270 >>> loop inActive >>> match ID? repaint this too!

								ctxMapOverMenu.fillStyle = "#773388";
								
								ctxMapOverMenu.fillRect(18+e*4+(shiftX/16), 16+i*4+(shiftY/16), 4.5, 4.5);
							}
							/// 7
							if(defaultTiles[j].t.toString().substring(0,1)==2){

								ctxMapOverMenu.fillStyle = "#111";							
								ctxMapOverMenu.fillRect(18+e*4+(shiftX/16), 16+i*4+(shiftY/16), 4.5, 4.5);

							}

							/// so 48(tileDiameter) / 3 = 16;  [18+e, 16+i  center it, since 3 is smaller and it starts drawing from top/left]
							///  otherwise  48/ 10 = 4.8;  & no need for centering  BUT IN THIS CASE >> MAKE MENU OVER BIGGER (so you can see more that what you already see in the screen)

						}// id radar

					}// IF PAUSED





					    ///////   ||||  |||  ||  //|    ||     ///   /////////  ///////  ///////  
					   ///    |  ||||| |||  ||  // |   ||/    // //     ///    //       //   ///    
					  ///     | |  ||||||  ||  //  |  ||//   //  //    ///    ///      //  ///      
					 /// ANIM tiles       ||  //   ||||///  //   //   ///    //////   //////       
				    /// 


					if(defaultTiles[j].t>=960&&defaultTiles[j].t<=986){

						if(xAnimCounter>=0&&xAnimCounter<5){
							xAnim=0;
							areaEdgeX=0;
						}else if(xAnimCounter>=5&&xAnimCounter<10){
							xAnim=tileDiameter;
							areaEdgeX=tileDiameter;
						}else if(xAnimCounter>=10&&xAnimCounter<15){
							xAnim=tileDiameter*2;
							areaEdgeX=tileDiameter*2;
						}else if(xAnimCounter>=15){
							xAnim=0;
							xAnimCounter=0;
							areaEdgeX=0;
							/// xAnimCounter++ >> so the anim-frame doesn't move until ALL tiles have been set
							/// (otherwise it animates like waterfall, pretty cool too)
						
						/// TRy to keep a limited amount of tiles being animated!! (or check speed on avg computer)
						}

					}else if(defaultTiles[j].t==987){

						if(xAnimSandCounter>=0&&xAnimSandCounter<6){
							xAnim=0;
							areaEdgeX=0;
						}else if(xAnimSandCounter>=6&&xAnimSandCounter<12){
							xAnim=tileDiameter;
							areaEdgeX=tileDiameter;
						}else if(xAnimSandCounter>=12&&xAnimSandCounter<18){
							xAnim=tileDiameter*2;
							areaEdgeX=tileDiameter*2;
						}else if(xAnimSandCounter>=18){
							xAnim=0;
							xAnimSandCounter=0;
							areaEdgeX=0;
							/// xAnimCounter++ >> so the anim-frame doesn't move until ALL tiles have been set
							/// (otherwise it animates like waterfall, pretty cool too)
						
						/// TRy to keep a limited amount of tiles being animated!! (or check speed on avg computer)
						}

					}else{
						xAnim=0; ///// back to ZERO so the other tiles, which aren't this animated one, don't shift
					}

					/// wrap all this in a function, and call with parameter(CURRENTAREA) to which it loads x or xx...

		   			//ex: 101   0,1 = 1|   0,2 = 10 |   1,3 = 01=1   |  1,2 = 0
					if(mapOverDraw[tileMapIndex].toString().substring(0,2)>=92){

						   ////  + xAnim >>>  ANIMATION

						   /// this is just to prove that you can differentiate within tiles that have same first substring, but different second... so you can pass different images pointing to the SAME SPRITE starting X for all 1s... (ex: diff types of defaultTiles), here you can plus it or whatever to suit more specific differences
						if(!inArea.inIt){   



							if(mapOverDraw[tileMapIndex]>=920&&mapOverDraw[tileMapIndex]<999){


								if(mapOverDraw[tileMapIndex]==961){
									srcY=tileDiameter;
								}else if(mapOverDraw[tileMapIndex]==962){
									srcY=tileDiameter*2;
								}else if(mapOverDraw[tileMapIndex]==963){
									srcY=tileDiameter*3;
								}else if(mapOverDraw[tileMapIndex]==964){
									srcY=tileDiameter*4;
								}else if(mapOverDraw[tileMapIndex]==965){
									srcY=tileDiameter*5;
								}else if(mapOverDraw[tileMapIndex]==966){
									srcY=tileDiameter*6;
								}else if(mapOverDraw[tileMapIndex]==967){
									srcY=tileDiameter*7;
								}else if(mapOverDraw[tileMapIndex]==968){
									srcY=tileDiameter*8;
								}


								if(mapOverDraw[tileMapIndex]==971){
									srcY=tileDiameter*2;
								}else if(mapOverDraw[tileMapIndex]==972){
									srcY=tileDiameter;
								}else if(mapOverDraw[tileMapIndex]==973){
									srcY=tileDiameter*3;
								}else if(mapOverDraw[tileMapIndex]==974){
									srcY=tileDiameter*4;
								}


								if(mapOverDraw[tileMapIndex]==981){
									srcY=tileDiameter*3;
								}else if(mapOverDraw[tileMapIndex]==982){
									srcY=tileDiameter*2;
								}else if(mapOverDraw[tileMapIndex]==983){
									srcY=tileDiameter;
								}else if(mapOverDraw[tileMapIndex]==984||mapOverDraw[tileMapIndex]==985){
									srcY=0;
									
								}


								ctxBg.drawImage(anim, srcX+xAnim, srcY+yyAnim, 64, 64, tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);

							}

						}else{//// else if  inArea

							if(mapOverDraw[tileMapIndex]==984||mapOverDraw[tileMapIndex]==985){
								srcY=0;
								ctxBg.drawImage(anim, srcX+xAnim, srcY+yyAnim, 64, 64, tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
							}else{
									//when not in Area, show black (at least for this outside animations: 920>999)
								ctxBg.drawImage(img, srcX, srcY, 64, 64, tileIndexX, tileIndexY, tileWidthHeight/*+variance*/, tileWidthHeight/*+variance*/);
							}
							
						}


					}else if(mapOverDraw[tileMapIndex]>=370&&mapOverDraw[tileMapIndex]<390){

						
						if(!inArea.inIt){
							ctxBg.drawImage(anim, srcX+xAnim, srcY+yyAnim, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
						}else{
							ctxBg.drawImage(img, srcX, 0, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight/*+variance*/, tileWidthHeight/*+variance*/);
						}	
						

						for (var ii = 0; ii < inActiveObstacle.length; ii++) {

							if(mapOverDraw[tileMapIndex]==inActiveObstacle[ii].ID&&inActiveObstacle[ii].tindex==tileMapIndex){

								if(inActiveObstacle[ii].timeLiving<5){
									inActiveObstacle[ii].timeLiving++;
								}

								//console.log(inActiveObstacle[ii].time);
								
								/// if IN or OUT.. if THIS or THAT   (other tiles.. say 280s... could be inArea.inIt!!)


								//// IF NOT CLOSING>>> time == null >>> need another timer: timeLiving
								if(inActiveObstacle[ii].ID==371){
									if(!inArea.inIt){
										
										if(inActiveObstacle[ii].timeLiving>=0&&inActiveObstacle[ii].timeLiving<5){
											ctxBg.drawImage(anim, srcX+tileDiameter, srcY, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
											
										}else if(inActiveObstacle[ii].timeLiving>=5){
											ctxBg.drawImage(anim, srcX+tileDiameter*2, srcY, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
											
										}else{
											///non broken/opened
											ctxBg.drawImage(anim, srcX, srcY, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
										}
									}else{
										//console.log("ENTRAMOS AL AREA");
										ctxBg.drawImage(img, 0, 0, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight/*+variance*/, tileWidthHeight/*+variance*/);
									}


								//// OR ELSE IF YES CLOSING>>> time == "set" >>> use it while obstacleInactive
								}else if(inActiveObstacle[ii].ID==370){
									if(!inArea.inIt){
									
										if(inActiveObstacle[ii].time<=100&&inActiveObstacle[ii].time>95){
											ctxBg.drawImage(anim, srcX, srcY, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
											
										}else if(inActiveObstacle[ii].timeLiving<=95&&inActiveObstacle[ii].time>90){
											ctxBg.drawImage(anim, srcX+tileDiameter, srcY, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
											
										}else if(inActiveObstacle[ii].time<=90&&inActiveObstacle[ii].time>10){
											///non broken/opened
											ctxBg.drawImage(anim, srcX+tileDiameter*2, srcY, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);

										}else if(inActiveObstacle[ii].time<=10&&inActiveObstacle[ii].time>5){
											ctxBg.drawImage(anim, srcX+tileDiameter, srcY, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
											
										}else if(inActiveObstacle[ii].time<=10){
											///non broken/opened
											ctxBg.drawImage(anim, srcX, srcY, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
										}
									}else{
										ctxBg.drawImage(img, 0, 0, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight/*+variance*/, tileWidthHeight/*+variance*/);
									}
								}
								
							}// if mapOverDraw[tileMapIndex]

						}// for inActiveObstacle


					}else if(mapOverDraw[tileMapIndex]==390){
						//
						//console.log(xAnimCounter);

						if(xAnimCounter>=0&&xAnimCounter<5){
							xAnim=0;
							areaEdgeX=0;
						}else if(xAnimCounter>=5&&xAnimCounter<10){
							xAnim=tileDiameter;
							areaEdgeX=tileDiameter;
						}else if(xAnimCounter>=10&&xAnimCounter<15){
							xAnim=tileDiameter*2;
							areaEdgeX=tileDiameter*2;
						}else if(xAnimCounter>=15){
							xAnim=0;
							xAnimCounter=0;
							areaEdgeX=0;
							/// xAnimCounter++ >> so the anim-frame doesn't move until ALL tiles have been set
							/// (otherwise it animates like waterfall, pretty cool too)
						
						/// TRy to keep a limited amount of tiles being animated!! (or check speed on avg computer)
						}
						//console.log(xAnim);

						if(!inArea.inIt){
							if(!poweroff){
								ctxBg.drawImage(anim, srcX+xAnim, srcY+yAnim, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
							}else{
								ctxBg.drawImage(anim, srcX, srcY+64, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
							}
							
						}else{
							ctxBg.drawImage(img, srcX, srcY, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
						}
						

					}else if(mapOverDraw[tileMapIndex]==349){

						
							if(inArea.inIt){
								if(!poweroff){
									ctxBg.drawImage(img, srcX, srcY, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
								}else{
									ctxBg.drawImage(img, srcX, srcY+64, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
								}
							
							}else{
								ctxBg.drawImage(img, srcX, srcY, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
							}	
						
					}else{ /// OTHER TILES

						ctxBg.drawImage(img, srcX+xAnim, srcY+yAnim, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight/*+variance*/, tileWidthHeight/*+variance*/);
		  
					}/// else... everything else

					
					

																								 
						///////   //    //  //////    ////////      /////////          
						//   //   //   //  //        //    //          ///          
						//   //   //  //   ///      ///////            ///    ///
						//   //   /////    //      //    //            ///  ///
						//////    ////     ////// ///   //             ///    //      
																		   ///                 
					// and then these down here on top of everything else    
					/// down here draws again on top those tiles that need to be OVER Player
				
						 /// Areas roof when outside
						if(mapOverDraw[tileMapIndex].toString().substring(0,1)==2||mapOverDraw[tileMapIndex].toString().substring(0,1)==6||mapOverDraw[tileMapIndex].toString().substring(0,1)==5||mapOverDraw[tileMapIndex].toString().substring(0,1)==4){  
			   /// have to leave == 250, ,  fixed, or else there's no way to add && <3 in this multiple if/else

				//img, srcX, srcY  and get 250 right in sprite 

						if(mapOverDraw[tileMapIndex]==230||mapOverDraw[tileMapIndex]==210){
							if(inArea.inIt){
									/// 40 is the width of the portion to be drawn from the sprite (actual width in the sprite)
								ctxOverlay.drawImage(img, srcX, srcY, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight/*+variance*/, tileWidthHeight/*+variance*/);
							}
						}


							if(!inArea.inIt && mapOverDraw[tileMapIndex]<428 || !inArea.inIt && mapOverDraw[tileMapIndex]>=456&& mapOverDraw[tileMapIndex]!=573 ){ 
							/// 40 is the width of the portion to be drawn from the sprite (actual width in the sprite)
								ctxOverlay.drawImage(img, srcX, srcY+yAnim, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight/*+variance*/, tileWidthHeight/*+variance*/);
							}
								
						}  




						////  this ones always over player
						if(mapOverDraw[tileMapIndex]==107||mapOverDraw[tileMapIndex]==109){   /// y menos de la mitad
					   
							/// 33 is the width of the portion to be drawn from the sprite (actual width in the sprite)
							ctxBg.drawImage(img, 64, 0, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);


							ctxOverlay.drawImage(img, srcX, srcY, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
								
						}    



						if(mapOverDraw[tileMapIndex]>=300&&mapOverDraw[tileMapIndex]<333){  
							
							if(!inArea.inIt){

								ctxOverlay.drawImage(img, srcX,srcY+yAnim, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
							}else{

								if(mapOverDraw[tileMapIndex]==314||mapOverDraw[tileMapIndex]==323){
									ctxOverlay.drawImage(img, srcX,srcY+yAnim, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
								}
							}
						
						} 

						if(mapOverDraw[tileMapIndex]==314){  
							if(inArea.inIt){
								ctxOverlay.drawImage(img, srcX,srcY+yAnim, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
							}	
						}else if(mapOverDraw[tileMapIndex]==333){
							if(inArea.inIt){
								ctxOverlay.drawImage(img, srcX,srcY+yAnim, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
							}
						}


						if(mapOverDraw[tileMapIndex]==336){  
							if(!inArea.inIt){
								ctxOverlay.drawImage(img, srcX,srcY+yAnim, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
							}	
						}


						if(mapOverDraw[tileMapIndex]==340){  
							if(!inArea.inIt){
								ctxOverlay.drawImage(img, 832,64, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
							}	
						}else if(mapOverDraw[tileMapIndex]==341){  
							if(!inArea.inIt){
								ctxOverlay.drawImage(img, 832,128, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
							}	
						}else if(mapOverDraw[tileMapIndex]==342){  
							if(!inArea.inIt){
								ctxOverlay.drawImage(img, 832,256, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
							}	
						}else if(mapOverDraw[tileMapIndex]==343){  
							if(!inArea.inIt){
								ctxOverlay.drawImage(img, 832,192, 64, 64,  tileIndexX, tileIndexY, tileWidthHeight, tileWidthHeight);
							}	
						}





			                    ////////  ||||||  ||||||  ||////     /////   
			                    //   //   ||||||  ||||||  ||  //   //  
			                    //  //    ||||||  ||||||  ||///    ///// 
			                    /////     ||||||  ||||||  ||  \\      //
			                    ////             	      //   \\|///// 
                                ///                      //
                                //                      //
					if(mapOverDraw[tileMapIndex].toString().substring(0,1)>=4&&mapOverDraw[tileMapIndex].toString()<674){


						for (var f=0; f<doors.length; f++) {
							//console.log("here(2)"+ currentArea);

												///# types of doors	(in-out|side-front|big-small)							   ///door-index so its done only once
															    //\														      //             (drawn from first tile of that group#ofDoors)
							/// INSIDE :4 (facing:front)       //  \
							if(mapOverDraw[tileMapIndex].toString()>=572&&mapOverDraw[tileMapIndex].toString()<602&&doors[f].id==mapOverDraw[tileMapIndex].toString()&&doors[f].index==tileMapIndex&&doors[f].c==4){
								//console.log("door# "+doors[f].timeToClose + " time to go");
								if(doors[f].doorStatus=="open"){
										
									///so NOW according to this: animate >>> easy
									if(doors[f].anim<448){
										///if this >> point to here, else, there... instead of +=10
										doors[f].anim+=128;
									}										
								}else{
									if(doors[f].anim>0){
										///if this >> point to here, else, there... instead of +=10
										doors[f].anim-=128;
									}
								}
									//console.log(doors[f].c+" "+doors[f].id);
								if(inArea.inIt &&doors[f].area ==currentArea){
						
									///SPECIFIC TO A FEW ONLY NUMBERS >>> for looks only << sand on floor that meets outside tiles
									if(mapOverDraw[tileMapIndex].toString()==572||mapOverDraw[tileMapIndex].toString()==578){
										ctxDoors.drawImage(doorsSprite, 768, 0, 128, 128, tileIndexX, tileIndexY, 128, 128);

										
										///now the doors, as it goes over
										ctxDoors.drawImage(doorsSprite, 0+doors[f].anim, 448, 128, 128, tileIndexX, tileIndexY, 128, 128);

										/// wall sides
										ctxDoors.drawImage(doorsSprite, 768, 128, 128, 128, tileIndexX, tileIndexY, 128, 128);

									}else if(mapOverDraw[tileMapIndex].toString()==573){
										ctxDoors.drawImage(doorsSprite, 896, 0, 128, 128, tileIndexX, tileIndexY, 128, 128);


										///now the doors, as it goes over
									ctxDoors.drawImage(doorsSprite, 0+doors[f].anim, 448, 128, 128, tileIndexX, tileIndexY, 128, 128);

									/// wall sides
										ctxDoors.drawImage(doorsSprite, 768, 128, 128, 128, tileIndexX, tileIndexY, 128, 128);

										ctxOverlay.drawImage(doorsSprite, 1024, 0, 128, 256, tileIndexX, tileIndexY-64, 128, 256);
									}

									

								}else if(!inArea.inIt){

									//(ESTAS SON LAS QUE SALEN PARA ABAJO)

									if(mapOverDraw[tileMapIndex].toString()==573){
										ctxDoors.drawImage(doorsSprite, 896, 0, 128, 128, tileIndexX, tileIndexY, 128, 128);

										/// DOOR here:
										ctxDoors.drawImage(doorsSprite, 0+doors[f].anim, 448, 128, 128, tileIndexX, tileIndexY, 128, 128);		

										/// wall sides
										ctxDoors.drawImage(doorsSprite, 896, 128, 128, 128, tileIndexX, tileIndexY, 128, 128);
	
									}
															
								}

							/// INSIDE :2 (front)	>>>>      HEY!!!  This could also be OUTSIDE!!				>>>>  make MORE SUBDIVISIONS
																					////////////////////////////////////////////////////////////////////////////////////////////
							}else if(mapOverDraw[tileMapIndex].toString()>=456&&mapOverDraw[tileMapIndex].toString()<484&&doors[f].id==mapOverDraw[tileMapIndex].toString()&&doors[f].index==tileMapIndex&&doors[f].c==2){

								
								if(doors[f].doorStatus=="open"){
										
									///so NOW according to this: animate >>> easy
									if(doors[f].anim<256){
										///if this >> point to here, else, there... instead of +=10
										doors[f].anim+=64;
									}											
								}else{
									if(doors[f].anim>0){
										///if this >> point to here, else, there... instead of +=10
										doors[f].anim-=64;
									}
								}
									//console.log(doors[f].c+" "+doors[f].id);
									//console.log(mapOverDraw[tileMapIndex].toString());
								if(inArea.inIt &&doors[f].area ==currentArea){

									ctxDoors.drawImage(doorsSprite, 0+doors[f].anim, 128, 64, 128, tileIndexX, tileIndexY, 64, 128);
									
									/// wall sides
									ctxDoors.drawImage(doorsSprite, 384, 128, 64, 128, tileIndexX, tileIndexY, 64, 128);
								}

							/// INSIDE/OUSIDE :2 (facing: sideways)	
							}else if(mapOverDraw[tileMapIndex].toString()<542&&mapOverDraw[tileMapIndex].toString()>=512&&doors[f].id==mapOverDraw[tileMapIndex].toString()&&doors[f].index==tileMapIndex&&doors[f].c==2){
								//console.log(currentArea);
								if(doors[f].doorStatus=="open"){
										
									///so NOW according to this: animate >>> easy
									if(doors[f].anim<448){
										///if this >> point to here, else, there... instead of +=10
										doors[f].anim+=128;
									}											
								}else{
									if(doors[f].anim>0){
										///if this >> point to here, else, there... instead of +=10
										doors[f].anim-=128;
									}	
								}

								if(doors[f].area==currentArea||currentArea=="default"||currentArea=="transition"){

									///doors[f].c==2   ////////////////////////////////////////////////////   ELSE
									ctxDoors.drawImage(doorsSprite, 0+doors[f].anim, 256, 128, 192, tileIndexX-32, tileIndexY-64, 128, 192);

								}
								if(doors[f].area==currentArea){

									
									ctxOverlay.drawImage(doorsSprite, 640, 256, 128, 192, tileIndexX-32, tileIndexY-64, 128, 192);
									
								}

							/// INSIDE/OUTSIDE :1 (side)
							}else if(mapOverDraw[tileMapIndex].toString()<428&&mapOverDraw[tileMapIndex].toString()>=400&&doors[f].id==mapOverDraw[tileMapIndex].toString()&&doors[f].index==tileMapIndex&&doors[f].c==1){
								//console.log(currentArea);
								if(doors[f].doorStatus=="open"){
										
									///so NOW according to this: animate >>> easy
									if(doors[f].anim<448){
										///if this >> point to here, else, there... instead of +=10
										doors[f].anim+=128;
									}											
								}else{
									if(doors[f].anim>0){
										///if this >> point to here, else, there... instead of +=10
										doors[f].anim-=128;
									}	
								}

								if(doors[f].area==currentArea||currentArea=="default"||currentArea=="transition"){

									///doors[f].c==2   ////////////////////////////////////////////////////   ELSE
									ctxDoors.drawImage(doorsSprite, 0+doors[f].anim, 0, 128, 128, tileIndexX-32, tileIndexY-64, 128, 128);

									
								}

								if(doors[f].area==currentArea){

									ctxOverlay.drawImage(doorsSprite, 640, 0, 128, 128, tileIndexX-32, tileIndexY-64, 128, 128);
								}

							/// OUTSIDE :1 (side)
							}else if(mapOverDraw[tileMapIndex].toString()>=428&&mapOverDraw[tileMapIndex].toString()<456&&doors[f].id==mapOverDraw[tileMapIndex].toString()&&doors[f].index==tileMapIndex&&doors[f].c==1){

								if(doors[f].doorStatus=="open"){
									

									///so NOW according to this: animate >>> easy
									if(doors[f].anim<448){
										///if this >> point to here, else, there... instead of +=10
										doors[f].anim+=128;

									}	
															
								}else{

									if(doors[f].anim>0){
										///if this >> point to here, else, there... instead of +=10
										doors[f].anim-=128;
									}
									
								}
								
								//console.log("AREA TRNSITION "+ currentArea);
								if(doors[f].area==currentArea||currentArea=="transition"){
									ctxDoors.drawImage(doorsSprite, 0+doors[f].anim, 0, 128, 128, tileIndexX-32, tileIndexY-64, 128, 128);

									ctxOverlay.drawImage(doorsSprite, 640, 0, 128, 128, tileIndexX-32, tileIndexY-64, 128, 128);
								}
							} // IF#

						}/// FOR  doors

					}///if map 3 or 4 (doors-range)

					////////////////////////////////////////////////////////
					/////////////////////////////////						E N D   D O O R S

				}///	if(mapOverDraw[tileMapIndex]==defaultTiles[j].t){
			}/////  FOR defaultTiles

			tileIndexX+= tileWidthHeight;
			tileMapIndex++;

		}// For roomTiles X
	
		tileIndexY+=tileWidthHeight;
		tileIndexX=newTileIndexX;

	}// For roomTiles Y


} /////   tilesOverDRAW
//()={}"ht:^//()={}"ht:^//()={}"ht:^//()={}"ht:^//()={}"ht:^//()={}"ht:^//()={}"ht:^//()={}"ht:^//()={}"ht:^//()={}"





			                    ///////// ||||||  ||||||  ||////          /////   ////// /////   //    //
			                    //   ///  ||||||  ||||||  ||  //         //  // //   // //      ////  //
			                    //  ///   ||||||  ||||||  ||///          ///// //////  ////    // /////
			                    //////    ||||||  ||||||  ||  \\              //      ////// //   ///
			                    ////             	      //  //			 //	    
                                //                        




function doorOpen(id, timer, tindex, fromBullet){


	/// also check those ids that wont open or won't close................

	for (var i=0; i< doorKeys.length; i++) {
		if(id==doorKeys[i].id){
			var haveKey =false;
			for (var h=0; h<player1.nonSelectItems.length; h++) {
				
				//return;
				if(player1.nonSelectItems[h].itemCategory==doorKeys[i].key){
					haveKey=true;
				}	
			}

			if(!haveKey){

				doorShutSFX.play();

				return;
			}
		}
	}


	for(var i=0; i < obstacles.length; i++){
		if(i>0){

			///open only those you hit (smatching # & index)
			if(id<390&&id==obstacles[i].ID&&obstacles[i].Tindex==tindex){ 

				/// Tindex checks that its a unique square (or it would open all doors with that ID) <<<<  breakable object-door has same ID.. diff system.

				obstacles[i].obstacleStatus="open"; 
				doorClose(id, tindex);
				

				//vs open ALL (those which share #)
			}else if(id>=390&&id==obstacles[i].ID){   ///////////////////   SI NO ESTA EN LA MISMA PIESA... TIENE QUE ESPERAR....

				for (var f=0; f<doors.length; f++) {

					if(doors[f].id==obstacles[i].ID){
						doors[f].doorStatus="open";
						doors[f].timeToClose=obstacles[i].timeToClose;
					}
				}

				obstacles[i].obstacleStatus="open"; 
				doorClose(id);
				if(id !=390){
					doorOpenSFX.play();
				}
				
			}
		}///if i   
	}// for obst length

}/// doorOpen



function doorClose(id, tindex){

	///pass values after for loop is done

	/// whether its a closing doow (with time) or not, 1 or 2
	var pushThis=0;

	/// how long from closing (for closing doors, type 1)
	var timeToClose=0;


	for(var i=0; i < obstacles.length; i++){
		if(i>0){
			/// id -> doorOpen(argument)


			if(typeof obstacles[i].timeToClose != "undefined" && obstacles[i].timeToClose >0){ 


				if(id<390&&id==obstacles[i].ID&&obstacles[i].Tindex==tindex&&pushThis==0){ 
					
					pushThis=1;
					timeToClose=obstacles[i].timeToClose;
					
				}else if(id>=390&&id==obstacles[i].ID&&pushThis==0){

					pushThis=1;
					timeToClose=obstacles[i].timeToClose;
				}

			}else if(obstacles[i].timeToClose == null&&pushThis==0){ 


				if(id<390&&id==obstacles[i].ID&&obstacles[i].Tindex==tindex&&pushThis==0){ 
					
					pushThis=2;
						
				}else if(id>=390&&id==obstacles[i].ID&&pushThis==0){

					pushThis=2;
				}
			}
		}///if i   
	}// for obst length


	if(pushThis==1){
		inActiveObstacle.push({ID:id, tindex:tindex, time:timeToClose, timeLiving:0});

		

	}else if(pushThis==2){
		inActiveObstacle.push({ID:id, tindex:tindex, time:null, timeLiving:0});

		
	}

}/// doorClose







///////   |||||\\\\  |||||\\\\  ||\ |\ /\         ////////    //  //
//   //   |||||\\\\  |||||\\\\  |||||\\\\         ///    //   //  //
//////    |||||\\\\  |||||\\\\  |||||\\\\         //          //////
///  //   |||||\\\\  |||||\\\\  |||/  \\\         //          //  //
///  ///  |||||\\\\  |||||\\\\  ||/    \\         ///    //   //  //
												  ////////


function changeRoom(whatRoom, whatID, newShiftX, newShiftY, type){ ///////////////////   WHAT AREA!

	clearCtx(ctxPlayer);

	//reset, since bullets left in other room won't be needed ever again
	bulletID=0;

	// buttons blocked so can't pause and go through door at the same time!!!!!!!!!!!!!
	blockInput=true;

	nextRoom =whatRoom;
	ID=whatID;

	//// only do this  IF player1.drawY > window.innerWidth/2){}
	shiftX=newShiftX;

	shiftY=newShiftY;   //////////  now, this shift has to be dependent on where this  PARTICULAR tile is located!!!
	//////////   
	// console.log("ahora "+shiftY);

	/// IF .... diff conditions for different type of doors.. (teleport vs)
	paused=true;
	pauseType=type;
	///// this should be a PARAMETER!!!  <<<<<<<<<<<
							////////////   so it can be change depending on when you call it!

	dash=false;

	roomChangeLoop();
}


var roomLooping=false;

var teleCount=0;
var flashChanged=false;


var roomClosing=true;

var roomLoopCloseCount=0;


var blackScreen=0;


function roomLoopClose(){
	
	roomLoopCloseCount++;
 
	clearCtx(ctxMenuOverOver);
	ctxMenuOverOver.fillText(bullets[player1.weaponSelected].current,170,40);

	for(var j=0; j<player1.items.length; j++){

		if(player1.items[j].itemCategory==player1.itemSelected){
			//console.log("ITEM SELECTED "+ this.itemSelected);
			if(typeof player1.items[j] !="undefined"&&player1.items.length>1){
				ctxMenuOverOver.fillText(player1.items[j].amount ,70,40);
			}
		}
	}

	clearCtx(ctxOverOverlay);
	isPlaying=false;

	ctxOverOverlay.fillStyle = "#000000";


	ctxOverOverlay.fillRect(0, 0, canvasWidth-50, (Math.round(screenHeight/2)-pauseCount));   

	ctxOverOverlay.fillRect(0, (screenHeight/2)+pauseCount, canvasWidth-50, (Math.round(screenHeight/2)-pauseCount));  

	// var pauseCountIncrease=Math.round(window.innerHeight)/(Math.round(window.innerHeight)/10);


	var pauseCountIncrease=Math.round(screenHeight)/(Math.round(screenHeight)/10);

	if(blackScreen<8){
		blackScreen++;
		//console.log(blackScreen);
	}else{
		pauseCount+=8;
	}

	if(pauseCount<=(Math.round(screenHeight/2))){

		requestAnimFrame(roomLoopClose);
	}else{
		roomClosing=false;
		roomChangeLoop();

		blackScreen=0;
	}
	
}/// END RoomLoop-Close <<<< BlackCurtains



function roomChangeLoop() {		


	
	if(typeof player1 !="undefined"){

		// no Shoting while changing room >> Avoid that frozen bullet if you happen to shoot before you move
	//////																					after changing rooms
		player1.shooting=false;

	}

	var memberShiftY;
	var memberShiftX;

			/// DIFFERENT CONDITIONS for each type of Transition
	if(pauseType=="normal"){//

		if(pauseCount<(Math.round(screenHeight/2))){
			roomLooping=true;

			if(!pausedRoomChangeLoop){
						// game stopped
				isPlaying = false;
						///	 player anim State reset 
						///	   (or else it may stop in the middle of anim, and then appear like that in the next room)
				player1.animationState(this.dead, this.direction, this.animRatePlayer, this.animRateShooting, this.moving);

				pausedRoomChangeLoop=true;  
			}

		}else{
			roomLooping=false;
		}

	}else if(pauseType=="teleport"){
		if(pauseCount<200){
			roomLooping=true;
			clearCtx(ctxMapOverMenu); /////////////   JAMMING SIGNAL
		}else{
			roomLooping=false;
			roomClosing=false;
		}
	}

			
	 ///if still paused, then this inside
	if(roomLooping){ 

		if(pauseType=="normal"){//
			ctxOverOverlay.fillStyle = "#000000";
			ctxOverOverlay.fillRect(0, 0, canvasWidth-50, 0+pauseCount);  

			ctxOverOverlay.fillRect(0, Math.round(screenHeight)-pauseCount, canvasWidth-50, 0+pauseCount);  

					// var pauseCountIncrease=Math.round(window.innerHeight)/(Math.round(window.innerHeight)/10);
			var pauseCountIncrease=Math.round(screenHeight)/(Math.round(screenHeight)/10);
			pauseCount+=8;

					//console.log("ERERERRER   "+pauseCount);

		}else if(pauseType=="teleport"){

			teleCount++;
					//console.log("TC "+teleCount);
			if(teleCount>=0&&teleCount<=5){
						//console.log(flash + "  is F");
						
				if(!flashChanged){

					if(flash==0){
						flash=1;
					}else if(flash==1){
						flash=2;
					}else{
						flash=0;
					}
					flashChanged=true;
				}

			}else if(teleCount>5){
				teleCount=0;

				flashChanged=false;
			}

			tileDiameter+=0.7;

			shiftY-=22;
			shiftX-=10;

			for (var g=0; g<items.length; g++) {
						//console.log(items[g].drawX);
						items[g].drawY-=22;
						items[g].drawX-=10;
						
						items[g].centerY-=22;
						items[g].centerX-=10;
					}

					//ctxOverOverlay.fillStyle = "#ff0000";
					// ctxOverOverlay.fillRect(0, 0, canvasWidth-50, 40+pauseCount);   

					// var pauseCountIncrease=Math.round(window.innerHeight)/(Math.round(window.innerHeight)/10);
					var pauseCountIncrease=Math.round(screenHeight)/(Math.round(screenHeight)/10);
					pauseCount+=4.3;

				}

				///roomChangeLoop();   // for gameCounter purposes
				requestAnimFrame(roomChangeLoop);
				
			}else{

				flash=0;

				tileDiameter = 64;
				clearCtx(ctxOverOverlay);

				// cool roomChange graphics are over, 
				///	now resolve the values at hand before resuming the game

				paused=false;
				
				pauseCount=0;
				//currentArea="default";

				obstacles = [];
				areas = [];
				doorsTiles = [];

				clearCtx(ctxBg);
				clearCtx(ctxDoors);
				clearCtx(ctxOverlay);

				memberShiftY = Math.abs(shiftY);
				memberShiftX = Math.abs(shiftX);

				/// check how many tiles per X/Y axis on the roomMap you are going to
									/// (so as to then calculate the ID location)
				checkTileNumbers(nextRoom);

				/// get doorTo Index in map Array
				var doorIndex=	whatRoomMap(nextRoom).indexOf(ID);

				/// Y axis:                                               \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

				/// divide this index by the amount of tiles per X axis,
				///	and round it to trim out the extra tiles (if not the first in the row)
				/// and now with the amount of rows from the top, we multiply by tileDiameter to get our location
				var doorIndexY = Math.round(doorIndex/roomNumberTilesX)*tileDiameter;
				
				var doorIndexX =(doorIndex%roomNumberTilesX)*tileDiameter;
				/// location which is to be compared against the current room Mpa's height
				var mapHeight = roomNumberTilesY * tileDiameter;
				var mapWidth = roomNumberTilesX * tileDiameter;


				if(doorIndexY>=canvasBg.clientHeight/2&&doorIndexY< mapHeight-(canvasBg.clientHeight/2)){

					shiftY=(doorIndexY- canvasBg.clientHeight/2)*-1;

				}else if(doorIndexY>= mapHeight-(canvasBg.clientHeight/2)){
					shiftY= (mapHeight- canvasBg.clientHeight)*-1;
				}else if(doorIndexY<=canvasBg.clientHeight/2){
					shiftY=0;
				}

				if(doorIndexX>=canvasBg.clientWidth/2&&doorIndexX< mapWidth-(canvasBg.clientWidth/2)){

					shiftX=(doorIndexX- canvasBg.clientWidth/2)*-1;

				}else if(doorIndexX>= mapWidth-(canvasBg.clientWidth/2)){
					shiftX= (mapWidth- canvasBg.clientWidth)*-1;

				}else if(doorIndexX<=canvasBg.clientWidth/2){
					shiftX=0;

				}

				pauseCount=0;

				currentRoom=nextRoom;

		for (var k = 0; k < areas.length; k++) {
			if( areas[k].ID==ID){

				currentArea=areas[k].n;

			}
		}

///////////////////////////////////////////////////////////////////////////////////////
	////////////
		///// 		DRAW NEW ROOM 
	
		roomDraw(nextRoom, currentArea, 0, tileDiameter, 0,0,"first", currentLevel); 

		///////	   and adjust both Player and items position (post-shift)
				
		var lastShiftY;
		var lastShiftX;
				///WHRER TO RE-DRAW PLAYER?
		var colRow=false;

				for (var k = 0; k < areas.length; k++) {
					  
					if(areas[k].ID==ID){//// AREAS hv to keep track of what ROW/COLUMN they are in, to calculate new shiftX,Y
						   						
						///set player position when new room is Drawn    
						player1.drawX=areas[k].column-10;  
						player1.drawY=areas[k].row-10;

						//I don't know what the fuck is going on here anymore...  but it works
						if(typeof lastShiftY!="undefined"){
							player1.drawY-=Math.abs(lastShiftY);
							
						}else{
							player1.drawY-=Math.abs(shiftY);
						
						}

						if(typeof lastShiftX!="undefined"){
						
							player1.drawX-=Math.abs(lastShiftX);
						}else{
			
							player1.drawX-=Math.abs(shiftX);
						}
						//console.log(lastShiftY);
						//console.log(shiftY);
						lastShiftY =shiftY;
						lastShiftX =shiftX;

						blockedDoorIndex.push(k);
						areas[k].isBlocked="blocked"
							   
					}//// areas[k].ID==ID
				}/// for areas

				/// I don't even remember hpw this works, but it does
				/// KEEPS ITEMS IN PLACE AFTER MOVING AROUND FROM ONE ROOM TO THE NEXT

				for(var k =0; k<items.length; k++){
					  ///// OJO WHAT ROOM!! currentRoom

				  ///ok, so that shiftY is being reset to zero, because of something to do with FirstDraw.. or whatever
				  // point is, need to remember it before it goes to zero, to minus it to the items...

						items[k].drawY -=Math.abs(shiftY)-Math.abs(memberShiftY);
						items[k].centerY -=Math.abs(shiftY)-Math.abs(memberShiftY); 

						items[k].drawX -=Math.abs(shiftX)-Math.abs(memberShiftX);
						items[k].centerX -=Math.abs(shiftX)-Math.abs(memberShiftX); 
				  
												 
				}// for ITEMS


				/// and we are done, loop finished, room Changed, now back to the game
				pausedRoomChangeLoop=false;

				// player1.speed=1;
				player1.direction="room-change";
				player1.checkArea();
				

		blockInput=false;
		latestKeys=[];
		superLastKey=null;

		pauseType="gamePause";

		doorBlock=false;

		bulletsFired=[];

		if(roomClosing){
					
			roomLoopClose();

		}
				
		roomClosing=true;
		roomLoopCloseCount=0;

				
		isPlaying = true;
				/// game Loop needs to be called again
		loop();
	}// end IF pauseCount>(window.innerHeight/2)

}/// END RoomChange-loop
		
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
///^%*(\\\\~H><<///^%*(\\\\~H><<///^%*(\\\\~H><<///^%*(\\\\~H><<///^%*(\\\\~H><<///^%*(\\\\~H><<///^%*(\\\\~H><<///^%*(\\\\~H><<///^%*(\\\\~H><<///^%*(\\\\~H><<///^%*(\\\\~H><<///^%*(\\\\~H><<///^%*(\\\\~H><<///^%*(\\










//ENEMIES:


//just like obstacles, must have top, bottom X,Y ...  and run through the same function << bullet & player obstacle/enemy detect


function Enemy(xx, yy, type) {

	this.drawX = xx;
	this.drawY = yy;
	//where in sprite
	this.enemyType = type;


	this.centerX = this.drawX + (this.width / 2);
	this.centerY = this.drawY + (this.height / 2);

	if(this.enemyType =='blob'){
		//blob

		//where in sprite
		this.srcX = 0;
		this.srcY = 0;



		//in sprite with & height	
		this.width = 128;  
		this.height = 128; 


		//starting moving values & speed
		this.speed = 0;
		this.moving = true; //can it move?

		this.animRate =0.6; 


		this.direction = "nowhere";  // for moving mechanics purposes
		this.facing="nowhere";  /// diff from direction, for shooting Animation/sprite-purposes

		//animation
		this.isDead = false;
		this.deathType = "none";

		this.life=10;
	}


}/// FUNC Enemy









Enemy.prototype.draw = function () {

	ctxPlayer.drawImage(imgMonster, this.srcX, this.srcY, 128, 128, this.drawX+shiftX, this.drawY+shiftY, this.width, this.height);

	// Red rectangle
ctxPlayer.beginPath();
ctxPlayer.lineWidth = "2";
ctxPlayer.strokeStyle = "red";

	ctxPlayer.rect(this.leftX, this.topY, this.width, this.height);
	ctxPlayer.stroke();

		this.leftX = this.drawX+shiftX;
	this.rightX = this.leftX + this.width;
	this.topY = this.drawY+shiftY;
	this.bottomY = this.topY + this.height;
}; // END Player-Draw



Enemy.prototype.update = function () {


	if(this.life<=0){
		this.isDead=true;
	}

	this.checkMoving(this.direction, this.moving);
	this.animationState(this.dead, this.direction, this.animRate, this.moving);

};// END Enemy UPDATE


blobCounter=0;
oldBlobCounter=0;

Enemy.prototype.checkMoving = function (direction, moving) {

	//console.log(blobCounter);

	if(this.enemyType=="blob"){

		blobCounter++;

		if(this.moving==true&&blobCounter>15){
			
			var randomBlobMovement = Math.floor(Math.random() * (1000 - 100) + 100) / 100;
			
						
			if(randomBlobMovement>7.25){
				//console.log(randomBlobMovement);
				this.direction="right";
				
			}else if(randomBlobMovement>5&&randomBlobMovement<=7.25){
				//console.log(randomBlobMovement);
				this.direction="left";
				
			}else if(randomBlobMovement>2.5&&randomBlobMovement<=5){
				//console.log(randomBlobMovement);
				this.direction="up";
				
			}else if(randomBlobMovement>0&&randomBlobMovement<=2.5){
				//console.log(randomBlobMovement);
				this.direction="down";
				
			}


			//console.log(this.direction);
			blobCounter=0;
			
		}

		if(this.direction=="right"){
			this.drawX+=4;
		}else if(this.direction=="left"){
			this.drawX-=4;
		}else if(this.direction=="up"){
			this.drawY+=4;
		}else if(this.direction=="down"){
			this.drawY-=4;
		}


	}///end of BLOB








};


var animEnemyCount=0;

Enemy.prototype.animationState  = function (dead, direction, animRate, moving) {

	if(this.direction!="room-change"){
		animEnemyCount += animRate; //// OTHER ANIM RATE@!!!!!! (not bound to weapon)

		if(animEnemyCount>0&&animEnemyCount<1){
			this.srcX=0;
		}else if(animEnemyCount>=1&&animEnemyCount<2){
			this.srcX=128;
		}else if(animEnemyCount>=2){
			this.srcX=256;
			animEnemyCount=0;
		}

	}

};

































































































////////////\\	    [] 				 	 []]   []          		[]	    ////
////|\\\||///\\\ 	[] 					[[]]   []         	    []    //
////|\\\|||////\\ 	[]				   [[[]]   []       /|||  	[]  //
////|\\\|||/////\   []				  [[[]]]   []     //	    []//
////|\\\|||//////   []			     [[[[]]]   []   //        	[]/
////|\\||||/////    []		        [[[[]]]]   []  //          	[]
////||||||/////     [] 		  	   [[[[[]]]]   []//         	[]
/////////////       []			  [[[[[]]]]]   []/           	[]
//////              []		     [[[[[[]]]]]   []   /\\\\\\     []
/////               []		    [[[[[[[]]]]]   []           	[]
////			 	[]    	   [[[[[[[]]]]]]   []   	        []
////			    []  	  [[[[[[[]]]]]]]   []           	[]
////                [][][][][[[[[[[[[]]]]]]]   []    \\\\\\\    []




var itemDecrementCount=0;
var releaseCounterCount=0;


function Player(type) {
	//where in sprite
	this.srcX = 1664;
	this.srcY = 256;

	this.upperSrcX = 640;
	this.upperSrcY=256;


	//where in tileMap
	this.drawX = 400;
	this.drawY = 200;

	//in sprite with & height	
	this.width = 128;  
	this.height = 128; 


	//starting moving values & speed
	this.speed = 0;
	this.moving = true; //can it move?

	this.animRatePlayer =0.6; 


	this.direction = "nowhere";  // for moving mechanics purposes
	this.facing="nowhere";  /// diff from direction, for shooting Animation/sprite-purposes

	//animation
	this.isDead = false;
	this.deathType = "none";
	this.deathCount = 0;

	//special player characteristics  if/elses
	this.playerType = type;

	this.weapons = []; /////////////// every weapon keeps count of its own ammo, 
	this.weaponSelected = 1;
	this.itemSelected=0;

	this.items = [];
	this.guns = [];

	this.nonSelectItems = [];

	this.shooting=false;
	this.shootingDirection="down";

	this.usingItem=false;
	//this.shootingDirection="down";

	this.outtaBullets=false;

	this.shootCounter = 0;
	this.oldShootCounter = 0;

	/// this should probably be another dimension in array bullets[], since it depends on weapon Selected
	this.weaponSpeedRate;/// > = slower,  0 =  contraLaser  

	this.animRateShooting; 

	this.life=20; //also inside playerType if/elses
	this.lifeTotal=100;

	this.filling=false;
	this.lifeTo=0;
	////  this(all) starts with 0,  then each diff type gets + more or less.. like Diablo, 

	this.tile=0;
	///////
	///
	//   DIFFERENT QUALITIES LIKE speed, power, strength, intelligence.. hp, mp,  etc.....

	this.damageCount = 0;
	this.damageType = "none";
	this.damageAngle = "none";

}/// FUNC Player



/////////         
//|\\/////                             //\\
//|\\//////       ///    \\  ///////  //  \\              ||||||||  ||||||||
//|\\//////       ///    \\  ///  //  //   \\      ///\     ||      |||
//|\//////        //     \\  ///////  //    \\    //  \\    ||      |||
////////          //     \\  ///      //    //   //\\\\\\   ||      |||\\\
////              //     \\  ///      //   //   //     \\\  ||      |||
///               ///////\\  //       //////   //      \\\\ ||      ||||||||
///   



var gotBoots=false;

var gameCounterTeleport =0;

var poweroffCheck=false;



Player.prototype.update = function () {


	if(this.life<=0){
		this.isDead=true;


	}

	if(this.filling){

		if(this.lifeTo>this.life&& this.life < this.lifeTotal){
			this.life++;
			//console.log(this.life);
			healthRefillSFX.play();
		}else{
			filling=false;
			this.lifeTo=0;
		}
	}

	//console.log("teleport area??  "+currentSubArea);

	if(dash){
		dashCount++;
	}else{
		dashCount=0;
	}

if(!paused){
	gameCounterTeleport++;

	if(gameCounterTeleport<15){
		ctxOverOverlay.fillStyle = "#b8f818";
	}else if(gameCounterTeleport>=15&&gameCounterTeleport<24){
				
		ctxOverOverlay.fillStyle = "black";
	}else if(gameCounterTeleport>=24){
		gameCounterTeleport=0; /// rinse & repeat	
	}
}

	if(tele&&!paused&&currentSubArea=="teleportArea"){

				// console.log(player1.nonSelectItems[n].itemCategory);	
		blockInput=true;  
		this.direction="nowhere";
		this.speed=1;// por alguna razon resuelve el bug de caer en otra "area"						
		changeRoom("room-1", 674, shiftX, shiftY, "teleport"); // "teleporting" type of roomChange
		tele=false;	
							
		
	}



	if(!this.isDead){

		if(currentSubArea=="teleportArea"){
			//console.log("teleport area??  "+currentSubArea);
			ctxOverOverlay.fillRect(870, 110, 12, 12);
		}else{
			ctxOverOverlay.clearRect(870, 110, 12, 12);
		}
							
	}




	if(currentSubArea=="water"||currentSubArea=="deep-water"||currentSubArea=="red-lava"||currentSubArea == "quicksand"){
		if(!slowDown){
			if(this.speed>0){
				if(!dash){
					this.speed=6; 
					this.animRatePlayer=0.4;
				}else if(dash&&dashCount<100){
						
					this.speed=12;	
					this.animRatePlayer=0.6;		   	
				}else if(dash&&dashCount>100){
					dash=false;
						//console.log(dashCount+ " over 14");
					this.speed=6; 
					this.animRatePlayer=0.4;	
				}
			}
		}
	}else if(currentSubArea == "deep-sand"){
		if(!slowDown){
			if(this.speed>0){
				if(!dash){
					this.speed=2; 
					this.animRatePlayer=0.2;
				}else if(dash&&dashCount<100){
						
					this.speed=6;	
					this.animRatePlayer=0.3;		   	
				}else if(dash&&dashCount>100){
					dash=false;
						//console.log(dashCount+ " over 14");
					this.speed=2; 
					this.animRatePlayer=0.2;	
				}
			}
		}
	}else if(currentSubArea == "rocks"){
		if(!slowDown){
			if(this.speed>0){
				if(!dash){
					if(!gotBoots){
						this.speed=2; 
						this.animRatePlayer=0.2;
					}else{
						this.speed=12;	
						this.animRatePlayer=0.6;	
					}
					
				}else if(dash&&dashCount<100){
						
					this.speed=6;	
					this.animRatePlayer=0.3;		   	
				}else if(dash&&dashCount>100){
					dash=false;
					if(!gotBoots){
						this.speed=2; 
						this.animRatePlayer=0.2;
					}else{
						this.speed=12;	
						this.animRatePlayer=0.6;	
					}	
				}
			}
		}
	}else{
		if(!slowDown){

			if(!dash){
				this.speed=12; 
				this.animRatePlayer=0.6;
			}else if(dash&&dashCount<100){
					
				this.speed=6;	
				this.animRatePlayer=0.8;		   	
			}else if(dash&&dashCount>100){
				dash=false;
					//console.log(dashCount+ " over 14");
				this.speed=12; 
				this.animRatePlayer=0.6;	
			}
				
			
		}
	}

	doorBlock=false;
	

	clearCtx(ctxMenuOverOver);

	///on Update as it changes
	this.centerX = (this.drawX + (this.width / 2));
	this.centerY = (this.drawY + (this.height / 2));
	
/////////////////////////////////////////////////////////////////   H O W   M A N Y   I T E M S
	ctxMenuOverOver.font="20px Georgia";
	ctxMenuOverOver.fillStyle="blue";

	ctxMenuOverOver.fillText(bullets[player1.weaponSelected].current,170,40);

	for(var j=0; j<this.items.length; j++){

		//console.log("TYPE? "+this.items[j].itemCategory);

		if(this.items[j].itemCategory==this.itemSelected){
			//console.log("ITEM SELECTED "+ this.itemSelected);
			if(typeof this.items[j] !="undefined"&&player1.items.length>1){
				ctxMenuOverOver.fillText(this.items[j].amount ,70,40);
			}
		}
	}

	///
	//////   DOWN HERE    example of obstacle that dissapears after ITEM
	///////
	/// traditional way : Through item     
	for(var j=0; j<this.nonSelectItems.length; j++){

		// console.log("TYPE? "+this.nonSelectItems[j].itemCategory);

		if(this.nonSelectItems[j].itemCategory==2&&!gotBoots){
			//doorOpen(390);
			gotBoots=true;

			//doorClose(390);/// GO DOWN >> poweroff
			//// MAKE Electric field, and open when standing on tileX
		}

	}

	/// new way:trhough "WallSwitch"
	if(!poweroffCheck){
		if(poweroff){

			doorOpen(390);

			poweroffSFX.play();

			poweroffCheck=true;
		}	
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////

	this.checkMoving(this.direction, this.moving);//  a bit faster when called right after keyPress

	this.animationState(this.dead, this.direction, this.animRatePlayer, this.animRateShooting, this.moving);
	this.checkArea();



	//console.log("STILL DASH?? " +dash);
	if(!dash){
		if(this.weaponSelected==1){
			this.animRateShooting = 0.6;
			this.weaponSpeedRate=10;
		}else if(this.weaponSelected==2){
			this.animRateShooting = 0.18;
			this.weaponSpeedRate=30;
		}

	}else{
		if(this.weaponSelected==1){
			this.animRateShooting = 0.8;
			this.weaponSpeedRate=5;
		}else if(this.weaponSelected==2){
			this.animRateShooting = 0.5;
			this.weaponSpeedRate=18;
		}
	}


	if(this.direction!="nowhere"){
		this.shootingDirection=this.direction;
	}else{
		this.shootingDirection=this.facing;
	}


	this.shootCounter++;
		

	if(this.shooting){     
						
		if(this.oldShootCounter<this.shootCounter-this.weaponSpeedRate){

			for(var i = 0; i<player1.guns.length; i++){
				if(this.weaponSelected==(i+1)){
					bullets[i+1].current-=1;
						
					this.oldShootCounter=this.shootCounter;
					if(bullets[i+1].current<=0){
						bullets[i+1].current=0;
						this.outtaBullets=true;
					}else{
						this.outtaBullets=false;
					}
				}
			}

			var weaponX=0;
			var weaponY=0;
			var bulletType;
				
			if(!this.outtaBullets){

				if(typeof this.shootingDirection == "undefined"){
					this.shootingDirection="down";
				}
				//console.log("first shot  " +this.shootingDirection);

				/// this IF help with the "frozen-bullet" problem.. although not seen lately
				if(this.facing != "nowhere"){

					////this.centerX HAS TO VARY (+ || -) DEPENDING ON WHERE PLAYER1 IS FACING
					///									& even depending on weapon

				
					if(this.facing=="down"){
						weaponY=4;
					}else if(this.facing=="up"){
						weaponY=-4;
					}else if(this.facing=="right"){
						weaponX=4;
					}else if(this.facing=="left"){
						weaponX=-4;
					}else if(this.facing=="right-up"){
						weaponX=4;
						weaponY=-4;
					}else if(this.facing=="right-down"){
						weaponX=4;
						weaponY=4;
					}else if(this.facing=="left-up"){
						weaponX=-4;
						weaponY=-4;
					}else if(this.facing=="left-down"){
						weaponX=-4;
						weaponY=4;
					}
					
					if(this.weaponSelected==1){ 
						bulletType="normal";
						weapon1SFX.play();
					}else{
						bulletType="weird";
						weapon2SFX.play();
					}

					/// maybe NOT all weapons >> BOMBS >>> place ExplosionPoint first >> then micro bullets func..
					if(!doorBlock){

													
    					

						bulletsFired.push( new activeBullet(bulletID, undefined, undefined,this.drawX+weaponX+30,this.drawY+weaponY+30, [],[], 48, 48,  this.weaponSelected, this.playerType, this.shootingDirection, true, undefined, bulletType, 0, 0, false));
											

						bulletID++;
					}
				}
			}// if(!this.outtaBullets)
				
		}// if weapon speed rate allows

	}/// if shooting

	
	if(this.usingItem){

		//console.log("WAT ITEM " + this.itemSelected);
		itemDecrementCount++;
		// console.log(itemDecrementCount);
		// console.log("USINGgggg "+this.itemSelected);	
		for(var i=0; i < this.items.length; i++){
			//console.log(this.items[i].itemCategory);
			if(this.items[i].itemCategory==this.itemSelected){
				if(itemDecrementCount==1){

					
					if(this.itemSelected==10){
							this.lifeTo=this.life+10;
							this.filling=true;
					}

					if(this.items[i].amount>1){


						/// WHAT ITEMS DO  !!
						if(this.itemSelected==10){
							this.lifeTo=this.life+10;
							this.filling=true;


						}else if(this.itemSelected==11){
							dash=true;
						}


						this.items[i].amount--;
						
						
					}else if(this.items[i].amount==1){

						
						//console.log("USING "+this.itemSelected);
						if(this.itemSelected==10){
							this.lifeTo=this.life+10;
							this.filling=true;
					
						}else if(this.itemSelected==11){
							dash=true;
						}

						this.items.splice(i,1);
						// send back VAR so this.usingItem is flase >>> force to press again 
						if(itemRow==this.items.length-1&&this.items.length>1){
							itemRow-=1;
						}
						
						selecto();
						this.usingItem=false;

					}else{


						this.items.splice(i,1);
						// send back VAR so this.usingItem is flase >>> force to press again 
						if(itemRow==this.items.length-1&&this.items.length>1){
							itemRow-=1;
						}
						
						selecto();
						this.usingItem=false;


						/// Or else, could leave them on (faded) w ammount=0. (like in zelda>> bombs)
						/// in that case comment out this else and >> this.items[i].amount>1  --->    >0
					}
					
				}else if(itemDecrementCount>1&&itemDecrementCount<30){

					itemDecrementCount

				}else if(itemDecrementCount>=30){
					if(this.items[i].amount>1){

						/// WHAT ITEMS DO  !!
						if(this.itemSelected==10){
							this.lifeTo=this.life+10;
							this.filling=true;
						}else if(this.itemSelected==11){
							dash=true;
						}

						this.items[i].amount--;
						
						
					}else if(this.items[i].amount==1){


						if(this.itemSelected==10){
							this.lifeTo=this.life+10;
							this.filling=true;
						}else if(this.itemSelected==11){
							dash=true;
						}

						

						this.items.splice(i,1);
						// send back VAR so this.usingItem is flase >>> force to press again 
						if(itemRow==this.items.length-1&&this.items.length>1){
							itemRow-=1;
						}
						
						selecto();
						this.usingItem=false;

					}else{
						this.items.splice(i,1);
						// send back VAR so this.usingItem is flase >>> force to press again 
						if(itemRow==this.items.length-1&&this.items.length>1){
							itemRow-=1;
						}
						
						selecto();
						this.usingItem=false;

						/// Or else, could leave them on (faded) w ammount=0. (like in zelda>> bombs)
						/// in that case comment out this else and >> this.items[i].amount>1  --->    >0
					}

					itemDecrementCount=2;

				}

			}
		}
	}

	//for friction purposes
	if(releaseCounter){ 
		releaseCounterCount++;
	}

};// END Player UPDATE






/////////         \\
//|\\/////        \\\\
//|\\//////       ////\     ///////   ////   
//|\\//////       ///  \   ///  //   /////   //// \\\\  
//|\//////        //|  /  ///////   //////   \\\   \\\
////////          /////  ///   /   /// ///   \\\\ ////
////              ////  ///    /  ///  ///   
///               //
///           


var inDeepWater=0;
var inDeepSand=0;
var animRipple=0;
var animRippleC=0;

var lavaDamageCount=0;
var lavaDamageCount2=0;
var lavaOut=true;
var lavaOnce=false;


var snorkel =false;

var radar = false;


Player.prototype.draw = function () {

///// srcX, Y >> lower body
	
//console.log("GUN SEL"+this.gunSelected); ///  ACCORDING TO THIS WE GO DOWN Y AXIS  inSpritethis.srcY+50, 50, 50, 50
		//////////////////////  then in the future OTHER SPRITES for the suits/armor you find
	
	/// WEAPON SELECTS!!!  & things happen, things change
	if(!snorkel){
		for(var j=0; j<player1.nonSelectItems.length; j++){
			if(player1.nonSelectItems[j].itemCategory==4){
				snorkel=true;
			}

			if(player1.nonSelectItems[j].itemCategory==5){
				radar=true;
			}
		}
	}


	if(currentSubArea == "red-lava"){
		
		lavaOnce=true;
		
		this.damageType="lava";
		if(lavaDamageCount>=0&&lavaDamageCount<4){// other DAMAGE can take longer (for flicker-invulnerability to go away)
			lavaDamageCount++;
		}else{
			lavaDamageCount=0;	
			this.life--;
		}
	}

	if(currentSubArea == "deep-water"){
		if(!snorkel){
			inDeepWater++;
		}		
		

		if(inDeepWater>20){
			
			this.life=0;
			inDeepWater=0;	
		}	
	}else{
		inDeepWater=0;
	}

	if(currentSubArea == "deep-sand"){
				
		inDeepSand++;

		if(inDeepSand>60){
			
			this.life=0;
			inDeepSand=0;	

			this.damageType="sand";
		}	
	}else{
		inDeepSand=0;
	}
		
	if(lavaOnce&&lavaOut){
		lavaDamageCount=1;	
		lavaOut=false;
	}else if(lavaOnce&&!lavaOut){
		if(lavaDamageCount>0&&lavaDamageCount<16){// flicker takes longer to go away when coming out of lava
			lavaDamageCount++;
		}else{
			lavaDamageCount=0;	
			lavaOut=true;
			lavaOnce=false;
		}
	}
		
	if(pauseType!="teleport"&&!this.isDead){

		if((lavaDamageCount*100)%40==0||lavaDamageCount==0){/// add || NORMALdamagCount
			/// LEGS
			if(currentSubArea != "water"&&currentSubArea != "deep-water"&&currentSubArea != "red-lava"&&currentSubArea != "quicksand"&&currentSubArea != "deep-sand"){
				ctxPlayer.drawImage(imgPlayer2, this.srcX, this.srcY, 128, 128, this.drawX, this.drawY, this.width, this.height);
			}
			//console.log(" L D C " +lavaDamageCount);
		
			/// BODY ripple
			if(currentSubArea == "water" || currentSubArea == "deep-water" && this.life>0){

				animRippleC++;
				if(animRippleC>0&&animRippleC<=6){
					animRipple=0;
				}else if(animRippleC>6&&animRippleC<=12){
					animRipple=128;
				}else if(animRippleC>12&&animRippleC<=18){
					animRipple=256;
				}else if(animRippleC>18){
					animRippleC=0;
				}

				ctxPlayer.drawImage(imgPlayer2, 0, animRipple, 128, 128, this.drawX, this.drawY, this.width, this.height);	
			}

			/// BODY
			if(currentSubArea != "deep-water"){

				if(this.shooting){      ///// changing upperSrc Anim according to shooting
					ctxPlayer.drawImage(imgPlayer2, this.upperSrcX, this.upperSrcY, 128, 128, this.drawX, this.drawY, this.width, this.height);
				}else{                     //// shifted sprite (srcX, Y) for upperBody parts
					ctxPlayer.drawImage(imgPlayer2, this.upperSrcX, this.srcY, 128, 128, this.drawX, this.drawY, this.width, this.height);                 //// take off +3, that just to show its been drawn on top
												////            +3 actually + length of sprite (legs/upperbody)
				}
			}
		}/// IF DAMAGE COUNTS

	}else if(this.isDead){

		if(currentSubArea != "water"&&currentSubArea != "deep-water"&&currentSubArea != "red-lava"&&currentSubArea != "quicksand"&&currentSubArea != "deep-sand"){
			ctxPlayer.drawImage(imgPlayer2, this.srcX, this.srcY, 128, 128, this.drawX, this.drawY, this.width, this.height);
		}

		ctxPlayer.drawImage(imgPlayer2, this.upperSrcX, this.srcY, 128, 128, this.drawX, this.drawY, this.width, this.height);
		

	}
}; // END Player-Draw





/////////
//|\\/////
//|\\//////      /////           
//|\\//////     ///  |  |||  ||  ||  //|   |
//|\//////     ///   | |  ||||  ||  // |  ||
////////      ///    ||    ||  ||  //  ||||/
////         ///     |     |  ||  //      //
///
///   



Player.prototype.animationState = function (dead, direction, animRatePlayer, animRateShooting, moving) {

	// //DIFFERENT ANIMATIONS WITH DIFF WEAPON
	// 	//// keep track of what weapon is selected and move whole srcY of the sprite one down (where player is holding corresponging gun

												/// dgCount goes to 24

	if(!this.isDead){
	//console.log("SDSD" +this.direction)
	if(this.direction!="nowhere"&&this.direction!="room-change"){
		animCount += animRatePlayer; //// OTHER ANIM RATE@!!!!!! (not bound to weapon)

		if(animCount>0&&animCount<1){
			this.srcY=256;
		}else if(animCount>=1&&animCount<2){
			this.srcY=384;
		}else if(animCount>=2&&animCount<3){
			this.srcY=512;
		}else if(animCount>=3&&animCount<4){
			this.srcY=384;
		}else if(animCount>=4&&animCount<5){
			this.srcY=256;
		}else if(animCount>=5&&animCount<6){
			this.srcY=128;
		}else if(animCount>=6&&animCount<7){
			this.srcY=0;
		}else{
			animCount=0;
		}


	}


	/// just  W A L KI N G
	if(this.direction=="up"&&!this.shooting){
		this.upperSrcX = 128;
		this.srcX = 1152;
	}else if(this.direction=="down"&&!this.shooting){
		this.upperSrcX = 640;
		this.srcX = 1664;						
	}else if(this.direction=="right"&&!this.shooting){
		this.upperSrcX = 384;
		this.srcX = 1408;							
	}else if(this.direction=="left"&&!this.shooting){
		this.upperSrcX = 896;
		this.srcX = 1920;							
	}else if(this.direction=="right-up"&&!this.shooting){
		this.upperSrcX = 256;
		this.srcX = 1280;	
	}else if(this.direction=="right-down"&&!this.shooting){
		this.upperSrcX = 512;
		this.srcX = 1536;								
	}else if(this.direction=="left-up"&&!this.shooting){
		this.upperSrcX = 1024;
		this.srcX = 2048;								
	}else if(this.direction=="left-down"&&!this.shooting){
		this.upperSrcX = 768;
		this.srcX = 1792;								
	}else if(this.direction=="nowhere"&& this.moving){

		this.srcY=256;

		if(this.facing=="down"){
			this.upperSrcX = 640;
			this.srcX = 1664;	
		}else if(this.facing=="up"){
			this.upperSrcX = 128;	
			this.srcX = 1152;	
		}else if(this.facing=="right"){
			this.upperSrcX = 384;
			this.srcX = 1408;							
		}else if(this.facing=="left"){
			this.upperSrcX = 896;
			this.srcX = 1920;							
		}else if(this.facing=="right-up"){
			this.upperSrcX = 256;
			this.srcX = 1280;
		}else if(this.facing=="right-down"){
			this.upperSrcX = 512;
			this.srcX = 1536;
		}else if(this.facing=="left-up"){
			this.upperSrcX = 1024;	
			this.srcX = 2048;					
		}else if(this.facing=="left-down"){
			this.upperSrcX = 768;
			this.srcX = 1792;							
		}	


	}// else if not moving



	/// S H O T I N G  (upper body)
	if(this.shooting && this.direction!="room-change"){

		animShootingCount += animRateShooting;
		   
		   if(animShootingCount>0&&animShootingCount<2){
				  this.upperSrcY = 256;
			}else if(animShootingCount>=2&&animShootingCount<4){
				this.upperSrcY = 384;
			}else if(animShootingCount>=4&&animShootingCount<5){
				this.upperSrcY = 512;
				
			}else{
				animShootingCount =0;
			}


		
		if(this.direction=="nowhere"){


			if(this.facing=="down"){
				this.srcX = 3712;
				this.upperSrcX = 2688;
			}else if(this.facing=="up"){
				this.srcX = 3200;
				this.upperSrcX = 2176;
			}else if(this.facing=="right"){
				this.srcX = 3456;
				this.upperSrcX = 2432;
			}else if(this.facing=="left"){
				this.srcX = 3968;
				this.upperSrcX = 2944;
			}else if(this.facing=="right-up"){
				this.srcX = 3328;
				this.upperSrcX = 2304;
			}else if(this.facing=="right-down"){
				this.srcX = 3584;
				this.upperSrcX = 2560;
			}else if(this.facing=="left-up"){
				this.srcX = 4096;	
				this.upperSrcX = 3072;					
			}else if(this.facing=="left-down"){
				this.srcX = 3712;	
				this.upperSrcX = 2816;						
			}

		}else{
			if(this.direction=="down"){
				this.srcX = 1664;	
				this.upperSrcX = 2688;
			}else if(this.direction=="up"){	
				this.srcX = 1152;	
				this.upperSrcX = 2176;
			}else if(this.direction=="right"){
				this.srcX = 1408;	
				this.upperSrcX = 2432;						
			}else if(this.direction=="left"){
				this.srcX = 1920;	
				this.upperSrcX = 2944;						
			}else if(this.direction=="right-up"){
				this.srcX = 1280;
				this.upperSrcX = 2304;
			}else if(this.direction=="right-down"){
				this.srcX = 1536;
				this.upperSrcX = 2560;
			}else if(this.direction=="left-up"){
				this.srcX = 2048;	
				this.upperSrcX = 3072;						
			}else if(this.direction=="left-down"){
				this.srcX =  1792;	
				this.upperSrcX = 2816;									
			}
		}



	}
	

	/// PUSH BACK   >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ERROR
																	//  ERROR
																	 // ERROR
																	//  ERROR :::::::::         PUSHING PLAYER THROUGH WALL !!!!!!!!!!!!!!!!!!!!!!

																	/// calculate surrounding walls before pushing!
	if(this.damageType=="electrical"&&this.damageCount<18){
				
		if(this.damageAngle=="down"){
			this.drawY-=16;
		}else if(this.damageAngle=="up"){
			this.drawY+=16;
		}else if(this.damageAngle=="right"){
			this.drawX-=16;
		}else if(this.damageAngle=="left"){
			this.drawX+=16;
		}else if(this.damageAngle=="left-down"){
			this.drawX+=16;
			this.drawY-=16;
		}else if(this.damageAngle=="left-up"){
			this.drawX+=16;
			this.drawY+=16;
		}else if(this.damageAngle=="right-down"){
			this.drawX-=16;
			this.drawY-=16;
		}else if(this.damageAngle=="right-up"){
			this.drawX-=16;
			this.drawY+=16;
		}

	}

	// ANIM
	if(this.damageType=="electrical"&&this.damageCount>0&&this.damageCount<4){
		this.srcY=640;
	}else if(this.damageType=="electrical"&&this.damageCount>=4&&this.damageCount<8){
		this.srcY=876;
	}else if(this.damageType=="electrical"&&this.damageCount>=8&&this.damageCount<12){
		this.srcY=768;
	}else if(this.damageType=="electrical"&&this.damageCount>=12&&this.damageCount<16){
		this.srcY=876;
	}else if(this.damageType=="electrical"&&this.damageCount>=16&&this.damageCount<20){
		this.srcY=768;
	}else if(this.damageType=="electrical"&&this.damageCount>=20&&this.damageCount<24){
		this.srcY=876;
	}else if(this.damageType=="electrical"&&this.damageCount>=24&&this.damageCount<28){
		this.srcY=768;
	}


	}else{
		
	
		if(this.deathType=="none"){
			this.deathType=this.damageType;
		}

		
		if(this.deathType=="sand"){
			///carbonizacion anim...
		}else if(this.deathType=="lava"){
			///carbonizacion anim...
		}else if(this.deathType!="none"&& this.deathType!="sand" && this.deathType !="lava"){

			console.log(this.deathType);
			/// && on all death types.. according to the Angle.. where track of the animation it goes
			///								nad on this one, where is the player pushed back (just like above in damageAngle)
			this.deathCount++;

			if(this.deathCount>0 && this.deathCount<4){
				this.srcY=640;

			}else if(this.deathCount>4 && this.deathCount<8){
				this.srcY=768;
			}else if(this.deathCount>=8){
				this.srcY=876;
				this.deathCount=0;
				this.deathType="none";
			}
			//console.log(this.damageAngle);
		}
	}

};






/////////
//|\\/////
//|\\//////      /////// ///////   ||||||||  ///   ///   //////  
//|\\//////     ///  /////  ///   ||||||||   ||    //   //      
//|\//////     ///         ///   ////////    ||   //   /////   
////////      ///         ///   ////////     || //    //    
////         ///         ///   ////////      |/      ////////
///
///    




///Player(movement-related)  glob vars

var newDrawX, 
	newDrawY;

var crash = false;
var areasCrash = false;

var crashDir;


Player.prototype.checkMoving = function (direction, moving) {

	// this.direction="up";
	// console.log("alo?" + this.direction);
	////////////////IF SCREEN BIGGER THAN CANVAS
	if(canvasBg.width<window.innerWidth){
		var boxLimit_XL = canvasBg.width/8*3.3,    /// window.inner... or canvas.with depending on what the canvas size is
			boxLimit_XR = canvasBg.width/8*4.7,
			boxLimit_YT = canvasBg.height/8*3.3,
			boxLimit_YB = canvasBg.height/8*4.7; // canvasBg or any other canvas >> should all be the same

	}else{
		//// ELSE
		var boxLimit_XL = (window.innerWidth/16)*7,    /// window.inner... or canvas.with depending on what the canvas size is
			boxLimit_XR = (window.innerWidth/16)*9,
			boxLimit_YT = (window.innerHeight/8)*3,
			boxLimit_YB = (window.innerHeight/8)*5;
	}

	var    sprtLimit_XL = 100, 
	sprtLimit_XR = canvasWidth-100,
	sprtLimit_YT = 100,
	sprtLimit_YB = canvasHeight-100;


	////////////////////////////////
	////
	//     if not too close to room boundaries || not in center-screen-moving-areas >> you move, but the draw X,Y changes for everything else instead
	//console.log(crash);
	if(!this.checkCrash()&&!this.isDead){ 

		this.moving=true;



	}else {

		//////if direction same as crash -> false. 
		this.moving=false;
		crash=false;
		//console.log("choamo");
	}

	///// denuevo  ACORDARSE ESTO TIENE QUE SER SEGUN PLAYERDRAWX, Y Y AFUERA DE ESTE CHECKEO DE MOVIMIENTO  (sino constante todo el rato hermano)

			if(slowDown){

				if(player1.direction!="room-change"){
				   this.direction=slowDownDirection; 
				   if(player1.speed>0){
				   	 this.speed-=2;
				   }    
				  
				}
				   //onsole.log(player1.direction)   
				if(paused){
					player1.direction="nowhere";
					//console.log("PAUSED");
				}
			}
				
			

			if(this.speed==0||player1.checkCrash()){
				this.direction="nowhere";

				slowDownDirection="noSlowDown";
				releaseCounterCount=0;
				slowDown=false;
			}



	if(this.moving){



	var newCenterX = Math.round(newDrawX + (this.width / 2)),
		newCenterY = Math.round(newDrawY + (this.height / 2));
		///
		///// if within limits >, <=, >, <=


		newDrawX = this.drawX;
		newDrawY = this.drawY;




		
//////////////      ///      ///////////////////
//////////////      ///  //  ///////////////////
//////////////      ///     ////////////////////
//////////////      ///  ///////////////////////
///////////////    ////  ///////////////////////
///////////////////////  ///////////////////////
////////////////////////////////////////////////

//console.log(latestKeys[0]);


		if(this.direction=="up"){

			if(newCenterY<boxLimit_YT&&canvasHeight+shiftY<canvasHeight-this.speed){
				shiftY+=this.speed;
				clearCtx(ctxMapOverMenu);
				////////////////////////////////   DRAG SHIT

				for(var i =0; i<obstacles.length; i++){
					obstacles[i].topY += this.speed;
					obstacles[i].bottomY += this.speed;
				}


				for(var j =0; j<areas.length; j++){
					areas[j].topY += this.speed;
					areas[j].bottomY += this.speed;
				}
				
				//////  Items have center instead of bottom because thaat's  the point from which they get picked up
				for(var k =0; k<items.length; k++){
					items[k].drawY += this.speed;
					items[k].centerY += this.speed;    

				} 

				for(var l =0; l<bulletsFired.length; l++){
					bulletsFired[l].drawY += this.speed;
					bulletsFired[l].centerY += this.speed;    

				} 

			}else{
				this.drawY = this.drawY-this.speed;
			}

/////////    //////   /////    ////  ////  /////
/////////     ////    /////    ////  ///   /////
/////////     ////    /////    ////  //    /////
/////////     ////    /////    ////  /  /  /////
/////////    /////   //////    ////    //  /////
////////////////////////////////////////////////


		}else if(this.direction=="down"){



			//console.log(canvasHeight+shiftY);
			if(newCenterY>boxLimit_YB&&canvasHeight-canvasBg.height>=Math.abs(shiftY)+this.speed){
				shiftY-=this.speed;
 				clearCtx(ctxMapOverMenu);
				for(var i =0; i<obstacles.length; i++){
					obstacles[i].topY -= this.speed;
					obstacles[i].bottomY -= this.speed;
				}

				for(var j =0; j<areas.length; j++){
					areas[j].topY -= this.speed;
					areas[j].bottomY -= this.speed;

				}  

				for(var k =0; k<items.length; k++){
					items[k].drawY -= this.speed;
					items[k].centerY -= this.speed;    

				}  

				for(var l =0; l<bulletsFired.length; l++){
					bulletsFired[l].drawY -= this.speed;
					bulletsFired[l].centerY -= this.speed;    

				}  
				//console.log(areas[0].topY);         

			}else{
				this.drawY = this.drawY+this.speed;
			}

///				GO ON WITH THE ITEMS RE-DRAW.....................................................................
//////
		}else if(this.direction=="right"){

			/// yep yep 
			if(newCenterX>boxLimit_XR&&canvasWidth>((shiftX*-1)+canvasBg.width+this.speed)){
				shiftX-=this.speed;
				clearCtx(ctxMapOverMenu);
				for(var i =0; i<obstacles.length; i++){
					obstacles[i].leftX -= this.speed;
					obstacles[i].rightX -= this.speed;
				}

				for(var j =0; j<areas.length; j++){
					areas[j].leftX -= this.speed;
					areas[j].rightX -= this.speed;
				}
			  //alert(newObs[0].leftX);
			  	for(var k =0; k<items.length; k++){
					items[k].drawX -= this.speed;
					items[k].centerX -= this.speed;    

				} 

				for(var l =0; l<bulletsFired.length; l++){
					bulletsFired[l].drawX -= this.speed;
					bulletsFired[l].centerX -= this.speed;    

				}  

			}else{

				this.drawX = this.drawX+this.speed;

			}            

		}else if(this.direction=="left"){

			if(newCenterX<boxLimit_XL&&canvasWidth+shiftX<canvasWidth-this.speed){
				shiftX+=this.speed;
				clearCtx(ctxMapOverMenu);
				for(var i =0; i<obstacles.length; i++){
					obstacles[i].leftX += this.speed;
					obstacles[i].rightX += this.speed;
				}

				for(var j =0; j<areas.length; j++){
					areas[j].leftX += this.speed;
					areas[j].rightX += this.speed;
				}

				for(var k =0; k<items.length; k++){
					items[k].drawX += this.speed;
					items[k].centerX += this.speed;    

				} 

				for(var l =0; l<bulletsFired.length; l++){
					bulletsFired[l].drawX += this.speed;
					bulletsFired[l].centerX += this.speed;    

				}  

			}else{
				this.drawX = this.drawX-this.speed;
			}





		}else if(this.direction=="right-down"){


			if(crashDir=="right"){
				/// GOING DOWN!!
				if(newCenterY>boxLimit_YB&&canvasHeight-canvasBg.height>=Math.abs(shiftY)+this.speed){
					shiftY-=this.speed;
 					clearCtx(ctxMapOverMenu);
					for(var i =0; i<obstacles.length; i++){
						obstacles[i].topY -= this.speed;
						obstacles[i].bottomY -= this.speed;
					}

					for(var j =0; j<areas.length; j++){
						areas[j].topY -= this.speed;
						areas[j].bottomY -= this.speed;

					}  

					for(var k =0; k<items.length; k++){
						items[k].drawY -= this.speed;
						items[k].centerY -= this.speed;    

					}  

					for(var l =0; l<bulletsFired.length; l++){
					bulletsFired[l].drawY -= this.speed;
					bulletsFired[l].centerY -= this.speed;    

				}  
				//console.log(areas[0].topY);         

				}else{
					this.drawY = this.drawY+this.speed;
				}
			}else if(crashDir=="down"){
				/// GOING RIGHT!!

				if(newCenterX>boxLimit_XR&&canvasWidth>((shiftX*-1)+canvasBg.width+this.speed)){
				shiftX-=this.speed;
				clearCtx(ctxMapOverMenu);
					for(var i =0; i<obstacles.length; i++){
						obstacles[i].leftX -= this.speed;
						obstacles[i].rightX -= this.speed;
					}

					for(var j =0; j<areas.length; j++){
						areas[j].leftX -= this.speed;
						areas[j].rightX -= this.speed;
					}
				  //alert(newObs[0].leftX);
				  	for(var k =0; k<items.length; k++){
						items[k].drawX -= this.speed;
						items[k].centerX -= this.speed;    

					} 

					for(var l =0; l<bulletsFired.length; l++){
					bulletsFired[l].drawX -= this.speed;
					bulletsFired[l].centerX -= this.speed;    

				}  


				}else{

					this.drawX = this.drawX+this.speed;

				} 

				// FINALLY>> GOING RIGHT-DOWN
			}else {
				if(newCenterX>boxLimit_XR&&canvasWidth>((shiftX*-1)+canvasBg.width+this.speed)){
					shiftX-=this.speed;
					clearCtx(ctxMapOverMenu);
					for(var i =0; i<obstacles.length; i++){
						obstacles[i].leftX -= this.speed;
						obstacles[i].rightX -= this.speed;
					}

					for(var j =0; j<areas.length; j++){
						areas[j].leftX -= this.speed;
						areas[j].rightX -= this.speed;
					}


					for(var k =0; k<items.length; k++){
						items[k].drawX -= this.speed;
						items[k].centerX -= this.speed;    

					} 

					for(var l =0; l<bulletsFired.length; l++){
					bulletsFired[l].drawX -= this.speed;
					bulletsFired[l].centerX -= this.speed;    

				}  



				}else{

					this.drawX = this.drawX+this.speed;

				}

				if(newCenterY>boxLimit_YB&&canvasHeight-canvasBg.height>=Math.abs(shiftY)+this.speed){
					shiftY-=this.speed;
	 				clearCtx(ctxMapOverMenu);
					for(var i =0; i<obstacles.length; i++){
						obstacles[i].topY -= this.speed;
						obstacles[i].bottomY -= this.speed;
					}

					for(var j =0; j<areas.length; j++){
						areas[j].topY -= this.speed;
						areas[j].bottomY -= this.speed;

					}
					for(var k =0; k<items.length; k++){
						items[k].drawY -= this.speed;
						items[k].centerY -= this.speed;    

					}  

					for(var l =0; l<bulletsFired.length; l++){
					bulletsFired[l].drawY -= this.speed;
					bulletsFired[l].centerY -= this.speed;    

				}  

				}else{
					this.drawY = this.drawY+this.speed;
				}

			}







///////////////////////////////////////////////////////////////////////////////////////////////////////////////


		} else if(this.direction=="left-down"){




			if(crashDir=="left"){
				/// GOING DOWN!!
				if(newCenterY>boxLimit_YB&&canvasHeight-canvasBg.height>=Math.abs(shiftY)+this.speed){
					shiftY-=this.speed;
	 				clearCtx(ctxMapOverMenu);
					for(var i =0; i<obstacles.length; i++){
						obstacles[i].topY -= this.speed;
						obstacles[i].bottomY -= this.speed;
					}

					for(var j =0; j<areas.length; j++){
						areas[j].topY -= this.speed;
						areas[j].bottomY -= this.speed;

					}
					for(var k =0; k<items.length; k++){
						items[k].drawY -= this.speed;
						items[k].centerY -= this.speed;    

					}

					for(var l =0; l<bulletsFired.length; l++){
					bulletsFired[l].drawY -= this.speed;
					bulletsFired[l].centerY -= this.speed;    

				}  

				}else{
					this.drawY = this.drawY+this.speed;
				}
			}else if(crashDir=="down"){
				/// GOING RIGHT!!

				if(newCenterX<boxLimit_XL&&canvasWidth+shiftX<canvasWidth-this.speed){
					shiftX+=this.speed;
					clearCtx(ctxMapOverMenu);		
					for(var i =0; i<obstacles.length; i++){
						obstacles[i].leftX += this.speed;
						obstacles[i].rightX += this.speed;
					}

					for(var j =0; j<areas.length; j++){
						areas[j].leftX += this.speed;
						areas[j].rightX += this.speed;
					}

					for(var k =0; k<items.length; k++){
						items[k].drawX += this.speed;
						items[k].centerX += this.speed;    

					} 

					for(var l =0; l<bulletsFired.length; l++){
					bulletsFired[l].drawX += this.speed;
					bulletsFired[l].centerX += this.speed;    

				}  
				}else{
					this.drawX = this.drawX-this.speed;
				}

				// FINALLY>> GOING RIGHT-DOWN
			}else {
				
				if(newCenterX<boxLimit_XL&&canvasWidth+shiftX<canvasWidth-this.speed){
					shiftX+=this.speed;
					clearCtx(ctxMapOverMenu);	
					for(var i =0; i<obstacles.length; i++){
						obstacles[i].leftX += this.speed;
						obstacles[i].rightX += this.speed;
					}

					for(var j =0; j<areas.length; j++){
						areas[j].leftX += this.speed;
						areas[j].rightX += this.speed;
					}

					for(var k =0; k<items.length; k++){
						items[k].drawX += this.speed;
						items[k].centerX += this.speed;    

					} 

					for(var l =0; l<bulletsFired.length; l++){
					bulletsFired[l].drawX += this.speed;
					bulletsFired[l].centerX += this.speed;    

				}  

				}else{
					this.drawX = this.drawX-this.speed;
				}

				if(newCenterY>boxLimit_YB&&canvasHeight-canvasBg.height>=Math.abs(shiftY)+this.speed){
					shiftY-=this.speed;
	 				clearCtx(ctxMapOverMenu);
					for(var i =0; i<obstacles.length; i++){
						obstacles[i].topY -= this.speed;
						obstacles[i].bottomY -= this.speed;
					}

					for(var j =0; j<areas.length; j++){
						areas[j].topY -= this.speed;
						areas[j].bottomY -= this.speed;

					}
					for(var k =0; k<items.length; k++){
						items[k].drawY -= this.speed;
						items[k].centerY -= this.speed;    

					}

					for(var l =0; l<bulletsFired.length; l++){
					bulletsFired[l].drawY -= this.speed;
					bulletsFired[l].centerY -= this.speed;    

				}  

				}else{
					this.drawY = this.drawY+this.speed;
				}

			}

			//////////////////////////////////////////////////////////////////////////////////////////////////////









		}else if(this.direction=="left-up"){



			if(crashDir=="left"){
				/// GOING DOWN!!
				if(newCenterY<boxLimit_YT&&canvasHeight+shiftY<canvasHeight-this.speed){
					shiftY+=this.speed;
					clearCtx(ctxMapOverMenu);
					////////////////////////////////   DRAG SHIT

					for(var i =0; i<obstacles.length; i++){
						obstacles[i].topY += this.speed;
						obstacles[i].bottomY += this.speed;
					}


					for(var j =0; j<areas.length; j++){
						areas[j].topY += this.speed;
						areas[j].bottomY += this.speed;
					}
					
					//////  Items have center instead of bottom because thaat's  the point from which they get picked up
					for(var k =0; k<items.length; k++){
						items[k].drawY += this.speed;
						items[k].centerY += this.speed;    

					}

					for(var l =0; l<bulletsFired.length; l++){
					bulletsFired[l].drawY += this.speed;
					bulletsFired[l].centerY += this.speed;    

				}  

				}else{
					this.drawY = this.drawY-this.speed;
				}
			}else if(crashDir=="up"){
				/// GOING RIGHT!!

				if(newCenterX<boxLimit_XL&&canvasWidth+shiftX<canvasWidth-this.speed){
					shiftX+=this.speed;
					clearCtx(ctxMapOverMenu);
					for(var i =0; i<obstacles.length; i++){
						obstacles[i].leftX += this.speed;
						obstacles[i].rightX += this.speed;
					}

					for(var j =0; j<areas.length; j++){
						areas[j].leftX += this.speed;
						areas[j].rightX += this.speed;
					}
					for(var k =0; k<items.length; k++){
						items[k].drawX += this.speed;
						items[k].centerX += this.speed;    

					} 
					for(var l =0; l<bulletsFired.length; l++){
					bulletsFired[l].drawX += this.speed;
					bulletsFired[l].centerX += this.speed;    

				}  
				}else{
					this.drawX = this.drawX-this.speed;
				}


				// FINALLY>> GOING RIGHT-DOWN
			}else {
				if(newCenterX<boxLimit_XL&&canvasWidth+shiftX<canvasWidth-this.speed){
					shiftX+=this.speed;
					clearCtx(ctxMapOverMenu);
					for(var i =0; i<obstacles.length; i++){
						obstacles[i].leftX += this.speed;
						obstacles[i].rightX += this.speed;
					}

					for(var j =0; j<areas.length; j++){
						areas[j].leftX += this.speed;
						areas[j].rightX += this.speed;
					}
					for(var k =0; k<items.length; k++){
						items[k].drawX += this.speed;
						items[k].centerX += this.speed;    

					} 
					for(var l =0; l<bulletsFired.length; l++){
					bulletsFired[l].drawX += this.speed;
					bulletsFired[l].centerX += this.speed;    

				}  
				}else{
					this.drawX = this.drawX-this.speed;
				}


				if(newCenterY<boxLimit_YT&&canvasHeight+shiftY<canvasHeight-this.speed){
					shiftY+=this.speed;
					clearCtx(ctxMapOverMenu);
					////////////////////////////////   DRAG SHIT

					for(var i =0; i<obstacles.length; i++){
						obstacles[i].topY += this.speed;
						obstacles[i].bottomY += this.speed;
					}


					for(var j =0; j<areas.length; j++){
						areas[j].topY += this.speed;
						areas[j].bottomY += this.speed;
					}
					
					//////  Items have center instead of bottom because thaat's  the point from which they get picked up
					for(var k =0; k<items.length; k++){
						items[k].drawY += this.speed;
						items[k].centerY += this.speed;    

					}

					for(var l =0; l<bulletsFired.length; l++){
					bulletsFired[l].drawY += this.speed;
					bulletsFired[l].centerY += this.speed;    

				}  

				}else{
					this.drawY = this.drawY-this.speed;
				}

			}










		}else if(this.direction=="right-up"){




			if(crashDir=="right"){
				/// GOING DOWN!!
				if(newCenterY<boxLimit_YT&&canvasHeight+shiftY<canvasHeight-this.speed){
					shiftY+=this.speed;
					clearCtx(ctxMapOverMenu);
					////////////////////////////////   DRAG SHIT

					for(var i =0; i<obstacles.length; i++){
						obstacles[i].topY += this.speed;
						obstacles[i].bottomY += this.speed;
					}


					for(var j =0; j<areas.length; j++){
						areas[j].topY += this.speed;
						areas[j].bottomY += this.speed;
					}
					
					//////  Items have center instead of bottom because thaat's  the point from which they get picked up
					for(var k =0; k<items.length; k++){
						items[k].drawY += this.speed;
						items[k].centerY += this.speed;    

					} 

					for(var l =0; l<bulletsFired.length; l++){
					bulletsFired[l].drawY += this.speed;
					bulletsFired[l].centerY += this.speed;    

				}  

				}else{
					this.drawY = this.drawY-this.speed;
				}
			}else if(crashDir=="up"){
				/// GOING RIGHT!!

				if(newCenterX>boxLimit_XR&&canvasWidth>((shiftX*-1)+canvasBg.width+this.speed)){
					shiftX-=this.speed;
					clearCtx(ctxMapOverMenu);
					for(var i =0; i<obstacles.length; i++){
						obstacles[i].leftX -= this.speed;
						obstacles[i].rightX -= this.speed;
					}

					for(var j =0; j<areas.length; j++){
						areas[j].leftX -= this.speed;
						areas[j].rightX -= this.speed;
					}
				  //alert(newObs[0].leftX);
				  	for(var k =0; k<items.length; k++){
						items[k].drawX -= this.speed;
						items[k].centerX -= this.speed;    

					} 

					for(var l =0; l<bulletsFired.length; l++){
					bulletsFired[l].drawX -= this.speed;
					bulletsFired[l].centerX -= this.speed;    

				}  

				}else{

					this.drawX = this.drawX+this.speed;

				}   


				// FINALLY>> GOING RIGHT-DOWN
			}else {
				if(newCenterX>boxLimit_XR&&canvasWidth>((shiftX*-1)+canvasBg.width+this.speed)){
					shiftX-=this.speed;
					clearCtx(ctxMapOverMenu);
					for(var i =0; i<obstacles.length; i++){
						obstacles[i].leftX -= this.speed;
						obstacles[i].rightX -= this.speed;
					}

					for(var j =0; j<areas.length; j++){
						areas[j].leftX -= this.speed;
						areas[j].rightX -= this.speed;
					}
				  //alert(newObs[0].leftX);
				  	for(var k =0; k<items.length; k++){
						items[k].drawX -= this.speed;
						items[k].centerX -= this.speed;    

					} 

					for(var l =0; l<bulletsFired.length; l++){
					bulletsFired[l].drawX -= this.speed;
					bulletsFired[l].centerX -= this.speed;    

				}  

				}else{

					this.drawX = this.drawX+this.speed;

				}   

				if(newCenterY<boxLimit_YT&&canvasHeight+shiftY<canvasHeight-this.speed){
					shiftY+=this.speed;
					clearCtx(ctxMapOverMenu);
					////////////////////////////////   DRAG SHIT

					for(var i =0; i<obstacles.length; i++){
						obstacles[i].topY += this.speed;
						obstacles[i].bottomY += this.speed;
					}


					for(var j =0; j<areas.length; j++){
						areas[j].topY += this.speed;
						areas[j].bottomY += this.speed;
					}
					
					//////  Items have center instead of bottom because thaat's  the point from which they get picked up
					for(var k =0; k<items.length; k++){
						items[k].drawY += this.speed;
						items[k].centerY += this.speed;    

					}

					for(var l =0; l<bulletsFired.length; l++){
					bulletsFired[l].drawY += this.speed;
					bulletsFired[l].centerY += this.speed;    

				}   

				}else{
					this.drawY = this.drawY-this.speed;
				}

			}


		}

		// RESET after moving Player, so if  there isn't an obstacle its diagonal-way anymore
		//                                                   	     it should allow to move diagonal again
		crashDir="mmm"; /// any random value will do
	}
		/////// THIS delmitates the Central-Field-of-Influence || Movement boundaries, regarding Player&Screen movement >>> determines when the latter is to be dragged 
		// ctxOverlay.strokeStyle = "#FF0000";
		// ctxOverlay.strokeRect(boxLimit_XL, boxLimit_YT, boxLimit_XR-boxLimit_XL, boxLimit_YB-boxLimit_YT);
}




/////////
//|\\/////
//|\\//////     ///////   ||||||||||  ///|      //////  //   //
//|\\//////    ///       ||||| ||||  //  |     //      //   //
//|\//////    ///       |||||||||| ///||||    /////   // ////
////////     ///       |      ||  //     |     ////  //   //
////        ///////////       |  ||      ||///////  //   //
///
///     




Player.prototype.checkCrash = function () {   

	var newCenterX = Math.round(newDrawX + (this.width / 2)),
		newCenterY = Math.round(newDrawY + (this.height / 2));

	var player = this;

	function doorCrash(obstacleIndex, source){
									// source >> whether from PlayerCrash or Bullet

		if(obstacles[obstacleIndex].isDoor=="door"){        
			doorBlock=true;
		  
			if(obstacles[obstacleIndex].ID!=370&&obstacles[obstacleIndex].ID!=371&&obstacles[obstacleIndex].ID!=390&&source!="bullet"){
				//console.log("FKFKFKKFF "+obstacles[obstacleIndex].ID);
				doorOpen(obstacles[obstacleIndex].ID, obstacles[obstacleIndex].timeToClose, obstacles[obstacleIndex].Tindex);
			}
		    	
		}

		//console.log(obstacles[obstacleIndex].ID);

		if(obstacles[obstacleIndex].ID==349){
			poweroff = true;
			//console.log(poweroff);
		}

		if(player.damageCount==0){
			if(obstacles[obstacleIndex].ID==390){

				function getAngle(dir){
					var angle = dir;
					return angle;
				}

				player.damageAngle = getAngle(player.direction);

				///player.damageCount set...
				player.damageCount++;
				player.damageType="electrical";

				player.life-=2; 
				
				player.facing="nowhere";
				player.direction="nowhere";
				player.moving=false;

				blockInput=true;


				console.log(player.direction);

				elecDamageSFX.play();
				
			}
		}

	}

	/// player.damageCount continues...
	if(player.damageCount>0 && player.damageCount <4){
		player.damageCount++;


	}else if(player.damageCount>=4 && player.damageCount <28){
		player.damageCount++;
	}else if(player.damageCount==28){
		player.damageCount=0;

		blockInput=false;
		player.damageType = "none";

		player.facing=player.damageAngle; /// <<<<<<<<< SOOO  Sometimes you get pushed and your "facing changes" << and itwon't remember 
																		////         because you can either grab old facing(before change)or after, 
																		/// unless you wanna make a var and follow that shift during the damage... ....	
		player.direction="nowhere";

		player.shootingDirection=player.facing;
	}

















	///Loop through enemies
	for (var i = 0; i < enemies.length; i++) {

		// console.log(enemies[i].topY);
		// console.log(enemies[i].bottomY);
		// console.log(enemies[i].rightX);

			if(this.direction=="right"){
			

				///in other words: as long as you are standing in the block before the one you would be at if going right
				if(newCenterY>=enemies[i].topY&&newCenterY<enemies[i].bottomY&&newCenterX<=enemies[i].leftX&&newCenterX>enemies[i].leftX-tileDiameter) {

					//but don't stop me just yet, only if not doing so would put me on the other side 
					if(newCenterX+this.speed>=enemies[i].leftX-(this.speed+1)){

						console.log("crahsed");
						crash = true; 
						
					}
				}
			}  
			if(this.direction=="left"){

				if(newCenterY<=enemies[i].bottomY&&newCenterY>enemies[i].topY&&newCenterX>=enemies[i].rightX&&newCenterX<enemies[i].rightX+tileDiameter) {
					
					if(newCenterX-this.speed<=enemies[i].rightX+(this.speed+1)){

						    crash = true;
							
							console.log("crahsed");
					}
				}
			}   
			if(this.direction=="up"){

				if(newCenterX>=enemies[i].leftX&&newCenterX<enemies[i].rightX&&newCenterY>=enemies[i].bottomY&&newCenterY<enemies[i].bottomY+tileDiameter) {

					if(newCenterY-this.speed<=enemies[i].bottomY+(this.speed+1)){
							crash = true; 
							console.log("crahsed");
					}         
				}
			}   
			if(this.direction=="down"){

				if(newCenterX>enemies[i].leftX&&newCenterX<=enemies[i].rightX&&newCenterY<=enemies[i].topY&&newCenterY>enemies[i].topY-tileDiameter) {

					if(newCenterY+this.speed>=enemies[i].topY-(this.speed+1)){
							crash = true;  
							console.log("crahsed");
					}
				}
			}   


////////////////////////////////////////
//////////////////////////////	         d   I   A   G   O   N   A   L    S
//////////////////////////////////


			if(this.direction=="right-down"){ 


				if(newCenterY>=enemies[i].topY&&newCenterY<enemies[i].bottomY&&newCenterX<=enemies[i].leftX&&newCenterX>enemies[i].leftX-tileDiameter) {

					//but don't stop me just yet, i've just entered the square, now wait for me to be at the other side
					if(newCenterX+this.speed>=enemies[i].leftX-(this.speed+1)){
						// crash = true;  
						// doorCrash(i);
						if(crashDir!="down"){
							crashDir="right";
						}else{
							crash = true;
							console.log("crahsed");
						}
					}
				}


				if(newCenterX>enemies[i].leftX&&newCenterX<=enemies[i].rightX&&newCenterY<=enemies[i].topY&&newCenterY>enemies[i].topY-tileDiameter) {

					if(newCenterY+this.speed>=enemies[i].topY-(this.speed+1)){
						// crash = true;
						// doorCrash(i);
						if(crashDir!="right"){
							crashDir="down";
						}else{
							crash = true;
							console.log("crahsed");
						}
						
					}
				}
				//////   ADD AN EXPLICITELY diagonal check.....
				////  AND only on this one >>> 
						// crash = true;
						// doorCrash(i);

				if(newCenterY<=enemies[i].topY&&newCenterX<=enemies[i].leftX) {

					//but don't stop me just yet, i've just entered the square, now wait for me to be at the other side
					//console.log("WHAT"+player1.direction);
					if(newCenterX+this.speed>=enemies[i].leftX-(this.speed+1)&&newCenterY+this.speed>=enemies[i].topY-(this.speed+1)){
						if(crashDir!="right"&&crashDir!="down"){
							crash = true;
							console.log("crahsed");
						}

					}
				}

			} /////  if(this.direction=="right-down"){  



/////
///////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

			if(this.direction=="left-down"){ 

				 if(newCenterY<=enemies[i].bottomY&&newCenterY>enemies[i].topY&&newCenterX>=enemies[i].rightX&&newCenterX<enemies[i].rightX+tileDiameter) {
					
					if(newCenterX-this.speed<=enemies[i].rightX+(this.speed+1)){
						if(crashDir!="down"){
							crashDir="left";
						}else{
							crash = true;
							console.log("crahsed");
						}
					}
				}

				if(newCenterX>enemies[i].leftX&&newCenterX<=enemies[i].rightX&&newCenterY<=enemies[i].topY&&newCenterY>enemies[i].topY-tileDiameter) {

					if(newCenterY+this.speed>=enemies[i].topY-(this.speed+1)){
						if(crashDir!="left"){
							crashDir="down";
						}else{
							crash = true;
							console.log("crahsed");
						}
					}
				}



				if(newCenterY<=enemies[i].topY&&newCenterX>=enemies[i].rightX) {

					//but don't stop me just yet, i've just entered the square, now wait for me to be at the other side
					//console.log(crashDir);
					if(newCenterX-this.speed<=enemies[i].rightX+(this.speed+1)&&newCenterY+this.speed>=enemies[i].topY-(this.speed+1)){
						if(crashDir!="left"&&crashDir!="down"){
							crash = true;
							console.log("crahsed");
							//crashDir="right-down";
						}

						// crashDir="right";
					}
				}

			}

	}/// for loop enemies


























	///Loop through Obstacles
	for (var i = 0; i < obstacles.length; i++) {

		if( obstacles[i].obstacleStatus=="closed"){ 

			if(this.direction=="right"){
			
				///in other words: as long as you are standing in the block before the one you would be at if going right
				if(newCenterY>=obstacles[i].topY&&newCenterY<obstacles[i].bottomY&&newCenterX<=obstacles[i].leftX&&newCenterX>obstacles[i].leftX-tileDiameter) {

					//but don't stop me just yet, only if not doing so would put me on the other side 
					if(newCenterX+this.speed>=obstacles[i].leftX-(this.speed+1)){

						crash = true; 
						//if it's a door, you may open it   
						doorCrash(i);
					}
				}
			}  
			if(this.direction=="left"){

				if(newCenterY<=obstacles[i].bottomY&&newCenterY>obstacles[i].topY&&newCenterX>=obstacles[i].rightX&&newCenterX<obstacles[i].rightX+tileDiameter) {
					
					if(newCenterX-this.speed<=obstacles[i].rightX+(this.speed+1)){

						    crash = true;
							doorCrash(i);
					}
				}
			}   
			if(this.direction=="up"){

				if(newCenterX>=obstacles[i].leftX&&newCenterX<obstacles[i].rightX&&newCenterY>=obstacles[i].bottomY&&newCenterY<obstacles[i].bottomY+tileDiameter) {

					if(newCenterY-this.speed<=obstacles[i].bottomY+(this.speed+1)){
							crash = true; 
							doorCrash(i);
					}         
				}
			}   
			if(this.direction=="down"){

				if(newCenterX>obstacles[i].leftX&&newCenterX<=obstacles[i].rightX&&newCenterY<=obstacles[i].topY&&newCenterY>obstacles[i].topY-tileDiameter) {

					if(newCenterY+this.speed>=obstacles[i].topY-(this.speed+1)){
							crash = true;  
							doorCrash(i);
					}
				}
			}   


////////////////////////////////////////
//////////////////////////////	         d   I   A   G   O   N   A   L    S
//////////////////////////////////


			if(this.direction=="right-down"){ 


				if(newCenterY>=obstacles[i].topY&&newCenterY<obstacles[i].bottomY&&newCenterX<=obstacles[i].leftX&&newCenterX>obstacles[i].leftX-tileDiameter) {

					//but don't stop me just yet, i've just entered the square, now wait for me to be at the other side
					if(newCenterX+this.speed>=obstacles[i].leftX-(this.speed+1)){
						// crash = true;  
						// doorCrash(i);
						if(crashDir!="down"){
							crashDir="right";
						}else{
							crash = true;
							doorCrash(i);
						}
					}
				}


				if(newCenterX>obstacles[i].leftX&&newCenterX<=obstacles[i].rightX&&newCenterY<=obstacles[i].topY&&newCenterY>obstacles[i].topY-tileDiameter) {

					if(newCenterY+this.speed>=obstacles[i].topY-(this.speed+1)){
						// crash = true;
						// doorCrash(i);
						if(crashDir!="right"){
							crashDir="down";
						}else{
							crash = true;
							doorCrash(i);
						}
						
					}
				}
				//////   ADD AN EXPLICITELY diagonal check.....
				////  AND only on this one >>> 
						// crash = true;
						// doorCrash(i);

				if(newCenterY<=obstacles[i].topY&&newCenterX<=obstacles[i].leftX) {

					//but don't stop me just yet, i've just entered the square, now wait for me to be at the other side
					//console.log("WHAT"+player1.direction);
					if(newCenterX+this.speed>=obstacles[i].leftX-(this.speed+1)&&newCenterY+this.speed>=obstacles[i].topY-(this.speed+1)){
						if(crashDir!="right"&&crashDir!="down"){
							crash = true;
							doorCrash(i);
						}

					}
				}

			} /////  if(this.direction=="right-down"){  



/////
///////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

			if(this.direction=="left-down"){ 

				 if(newCenterY<=obstacles[i].bottomY&&newCenterY>obstacles[i].topY&&newCenterX>=obstacles[i].rightX&&newCenterX<obstacles[i].rightX+tileDiameter) {
					
					if(newCenterX-this.speed<=obstacles[i].rightX+(this.speed+1)){
						if(crashDir!="down"){
							crashDir="left";
						}else{
							crash = true;
							doorCrash(i);
						}
					}
				}

				if(newCenterX>obstacles[i].leftX&&newCenterX<=obstacles[i].rightX&&newCenterY<=obstacles[i].topY&&newCenterY>obstacles[i].topY-tileDiameter) {

					if(newCenterY+this.speed>=obstacles[i].topY-(this.speed+1)){
						if(crashDir!="left"){
							crashDir="down";
						}else{
							crash = true;
							doorCrash(i);
						}
					}
				}



				if(newCenterY<=obstacles[i].topY&&newCenterX>=obstacles[i].rightX) {

					//but don't stop me just yet, i've just entered the square, now wait for me to be at the other side
					//console.log(crashDir);
					if(newCenterX-this.speed<=obstacles[i].rightX+(this.speed+1)&&newCenterY+this.speed>=obstacles[i].topY-(this.speed+1)){
						if(crashDir!="left"&&crashDir!="down"){
							crash = true;
							doorCrash(i);
							//crashDir="right-down";
						}

						// crashDir="right";
					}
				}

			}


/////
///////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


			if(this.direction=="left-up"){ 

				if(newCenterY<=obstacles[i].bottomY&&newCenterY>obstacles[i].topY&&newCenterX>=obstacles[i].rightX&&newCenterX<obstacles[i].rightX+tileDiameter) {
					
					if(newCenterX-this.speed<=obstacles[i].rightX+(this.speed+1)){
						if(crashDir!="up"){
							crashDir="left";
						}else{
							crash = true;
							doorCrash(i);
						}
					}
				}

				if(newCenterX>=obstacles[i].leftX&&newCenterX<obstacles[i].rightX&&newCenterY>=obstacles[i].bottomY&&newCenterY<obstacles[i].bottomY+tileDiameter) {

					if(newCenterY-this.speed<=obstacles[i].bottomY+(this.speed+1)){
						if(crashDir!="left"){
							crashDir="up";
						}else{
							crash = true;
							doorCrash(i);
						}
					}         
				}


				if(newCenterY>=obstacles[i].bottomY&&newCenterX>=obstacles[i].rightX) {

					//but don't stop me just yet, i've just entered the square, now wait for me to be at the other side
					//console.log(crashDir);
					if(newCenterX-this.speed<=obstacles[i].rightX+(this.speed+1)&&newCenterY-this.speed<=obstacles[i].bottomY+(this.speed+1)){
						if(crashDir!="left"&&crashDir!="up"){
							crash = true;
							doorCrash(i);
							//crashDir="right-down";
						}

						// crashDir="right";
					}
				}


			}



/////
///////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



			if(this.direction=="right-up"){ 

				if(newCenterX>=obstacles[i].leftX&&newCenterX<obstacles[i].rightX&&newCenterY>=obstacles[i].bottomY&&newCenterY<obstacles[i].bottomY+tileDiameter) {

					if(newCenterY-this.speed<=obstacles[i].bottomY+(this.speed+1)){
						if(crashDir!="right"){
							crashDir="up";
						}else{
							crash = true;
							doorCrash(i);
						}
					}         
				}

					///in other words: as long as you are standing in the block before what would be the next one when going right
					if(newCenterY>=obstacles[i].topY&&newCenterY<obstacles[i].bottomY&&newCenterX<=obstacles[i].leftX&&newCenterX>obstacles[i].leftX-tileDiameter) {

						//but don't stop me just yet, i've just entered the square, now wait for me to be at the other side
						if(newCenterX+this.speed>=obstacles[i].leftX-(this.speed+1)){
							if(crashDir!="up"){
								crashDir="right";
							}else{
								crash = true;
								doorCrash(i);
							}
						
						}
					}
				

				if(newCenterY>=obstacles[i].bottomY&&newCenterX<=obstacles[i].leftX) {

					//but don't stop me just yet, i've just entered the square, now wait for me to be at the other side
					//console.log(crashDir);
					if(newCenterX+this.speed>=obstacles[i].leftX-(this.speed+1)&&newCenterY-this.speed<=obstacles[i].bottomY+(this.speed+1)){
						if(crashDir!="right"&&crashDir!="up"){
							crash = true;
							doorCrash(i);
							//crashDir="right-down";
						}

						// crashDir="right";
					}
				}

			}/// END this.direction->right-up
/////
///////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		}/// IF OBSTACLE ACTIVE

	}/// for loop Obstacles


	if (crash) {
		return true;
	} else {
		return false;
	}

};/// END Player-check-Crash





/////////
//|\\/////
//|\\//////       ///////   ||||||||||  //|||  ///
//|\\//////      ///    |  ||||| ||||  //     ////
//|\//////      ///     | |||||||||| ///|||  ///// 
////////       ///      ||      ||  //      //////
////          ///       |      ||  ||||||| ///////
///
///          
				   
				   

////   IF AREA   DOOR-to-other-room >>>>>>>>>>>>>>>>  changeRoom(CORRESPONDING ROOM TO THIS DOOR)


Player.prototype.checkArea = function (){
//console.log("PLAYER S " +player1.speed);

	function doorTo(areasIndex){


		//console.log(areas[i].num);

		//console.log("WHAT AREASINDEX  " + areasIndex);
//// ROOM TO !!!!
		if(areas[areasIndex].isDoor=="door"&&areas[i].doorTO!=674/*&&areas[i].doorTO!=740*/){   /// 510(and others) <<< TELEPORT LANDING
													/// Behave as doors(for transporting player to new location purposes), but are not intended to be used again
																																				///	 >> starting points at diff stages
			if(areas[areasIndex].isBlocked!="blocked"){

				blockInput=true;
	
				player1.facing="nowhere";
				player1.direction="nowhere";

				changeRoom(areas[i].roomTo, areas[i].doorTO, shiftX, shiftY, "normal");/////  room-2 >> determined by door"To" (9[2]11), then ID (92[11])
				///room-2 =>>> roomTO
			}    

		}else{

			for(var h=0; h<blockedDoorIndex.length; h++){

				 if(typeof areas[blockedDoorIndex[h]]!="undefined"&& typeof areas[blockedDoorIndex[h]]!=null){  ///// typeof?
						   areas[blockedDoorIndex[h]].isBlocked="unblocked";
						   //console.log("BLOCK "+blockedDoorIndex[h]);
				}
			}
		}
		//console.log("player position Ynow" +(parseInt(newDrawY)-parseInt(shiftY)));
	}

	function transitionArea(){
		if(currentArea=="transition"&&currentLevel!=2){
			
			currentLevel=2;
			roomDraw(currentRoom, currentArea, 0, tileDiameter, 0, 0, "first", currentLevel);

		}else if(currentArea!="transition"&&currentLevel!=1){
			 //console.log(currentArea);
			currentLevel=1;

			roomDraw(currentRoom, currentArea, 0, tileDiameter, 0, 0, "first", currentLevel);
		}
	}

	var newCenterX = Math.round(newDrawX + (this.width / 2)),
		newCenterY = Math.round(newDrawY + (this.height / 2));

	for (var i = 0; i < areas.length; i++) {

		if(this.direction=="right"){
		
			if(newCenterX<areas[i].rightX&&newCenterX>=areas[i].leftX&&newCenterY<=areas[i].bottomY&&newCenterY>areas[i].topY) {
				
				currentArea=areas[i].n; 
				currentSubArea=areas[i].n2;
				//console.log("AREA :"+areas[i].n+", SUB-area: "+areas[i].n2);

				this.tile=areas[i].num;
				//console.log(this.tile);

				///Door to other room (& blocking mechanism)
				doorTo(i);

				if(areas[i].n!="default"&&areas[i].n!="transition"&&areas[i].n!="water"&&areas[i].n!="deep-water"){
					inArea.inIt=true;
					//alert("area");
					inArea.whatArea=areas[i].n;
				 }else{
				   
					inArea.inIt=false;
					inArea.whatArea=areas[i].n;
				}
				///second level on same room
				transitionArea();
			}
		}  
		
		if(this.direction=="left"){

			if(newCenterX<=areas[i].rightX&&newCenterX>areas[i].leftX&&newCenterY<areas[i].bottomY&&newCenterY>=areas[i].topY) {
				
				currentArea=areas[i].n;
				currentSubArea=areas[i].n2;

				this.tile=areas[i].num;
				///Door to other room (& blocking mechanism)
				doorTo(i);

				if(areas[i].n!="default"&&areas[i].n!="transition"&&areas[i].n!="water"&&areas[i].n!="deep-water"){
					inArea.inIt=true;
					// alert("area");
					 inArea.whatArea=areas[i].n;
				 }else{
					inArea.inIt=false;
					 inArea.whatArea=areas[i].n;
				}
				transitionArea();
			}
		}   

		if(this.direction=="up"){
			//console.log(areasCrash);      
			if(newCenterY<=areas[i].bottomY&&newCenterY>areas[i].topY&&newCenterX>=areas[i].leftX&&newCenterX<areas[i].rightX) {

					currentArea=areas[i].n;
					currentSubArea=areas[i].n2;

					this.tile=areas[i].num;
					doorTo(i);

					if(areas[i].n!="default"&&areas[i].n!="transition"&&areas[i].n!="water"&&areas[i].n!="deep-water"){
						inArea.inIt=true;
						// alert("area");
						 inArea.whatArea=areas[i].n;
					}else{
						inArea.inIt=false;
						 inArea.whatArea=areas[i].n;
					}
				transitionArea();
			}
		}   
		if(this.direction=="down"){

			if(newCenterY<areas[i].bottomY&&newCenterY>=areas[i].topY&&newCenterX>areas[i].leftX&&newCenterX<=areas[i].rightX) {
					currentArea=areas[i].n;
					currentSubArea=areas[i].n2;

					this.tile=areas[i].num;
					doorTo(i);

				if(areas[i].n!="default"&&areas[i].n!="transition"&&areas[i].n!="water"&&areas[i].n!="deep-water"){
					inArea.inIt=true;
					// alert("area");
					 inArea.whatArea=areas[i].n;
				}else{
					inArea.inIt=false;
					 inArea.whatArea=areas[i].n;
				}
				transitionArea();
			}
		}   

		if(this.direction=="right-down"){

			if(newCenterX<areas[i].rightX&&newCenterX>=areas[i].leftX&&newCenterY<=areas[i].bottomY&&newCenterY>areas[i].topY||newCenterY<areas[i].bottomY&&newCenterY>=areas[i].topY&&newCenterX>areas[i].leftX&&newCenterX<=areas[i].rightX) {

					currentArea=areas[i].n;
					currentSubArea=areas[i].n2;

					this.tile=areas[i].num;
					doorTo(i);

				if(areas[i].n!="default"&&areas[i].n!="transition"&&areas[i].n!="water"&&areas[i].n!="deep-water"){
					inArea.inIt=true;
					 inArea.whatArea=areas[i].n;
				}else{
					inArea.inIt=false;
					 inArea.whatArea=areas[i].n;
				}
				transitionArea();
			}
		} 

		if(this.direction=="left-down"){

			if(newCenterX<=areas[i].rightX&&newCenterX>areas[i].leftX&&newCenterY<areas[i].bottomY&&newCenterY>=areas[i].topY||newCenterY<areas[i].bottomY&&newCenterY>=areas[i].topY&&newCenterX>areas[i].leftX&&newCenterX<=areas[i].rightX) {
					currentArea=areas[i].n;
					currentSubArea=areas[i].n2;

					this.tile=areas[i].num;
					///Door to other room (& blocking mechanism)
					doorTo(i);

				if(areas[i].n!="default"&&areas[i].n!="transition"&&areas[i].n!="water"&&areas[i].n!="deep-water"){
					inArea.inIt=true;
					 inArea.whatArea=areas[i].n;
				}else{
					inArea.inIt=false;
					 inArea.whatArea=areas[i].n;
				}
				///second level on same room
				transitionArea();
			}
		}

		if(this.direction=="left-up"){

			if(newCenterX<=areas[i].rightX&&newCenterX>areas[i].leftX&&newCenterY<areas[i].bottomY&&newCenterY>=areas[i].topY||newCenterY<=areas[i].bottomY&&newCenterY>areas[i].topY&&newCenterX>=areas[i].leftX&&newCenterX<areas[i].rightX) {

					currentArea=areas[i].n;
					currentSubArea=areas[i].n2;

					this.tile=areas[i].num;
					///Door to other room (& blocking mechanism)
					doorTo(i);

				if(areas[i].n!="default"&&areas[i].n!="transition"&&areas[i].n!="water"&&areas[i].n!="deep-water"){
					inArea.inIt=true;
					 inArea.whatArea=areas[i].n;
				}else{
					inArea.inIt=false;
					 inArea.whatArea=areas[i].n;
				}
				///second level on same room
				transitionArea();
			}

		}
		if(this.direction=="right-up"){

			if(newCenterX<areas[i].rightX&&newCenterX>=areas[i].leftX&&newCenterY<=areas[i].bottomY&&newCenterY>areas[i].topY||newCenterY<=areas[i].bottomY&&newCenterY>areas[i].topY&&newCenterX>=areas[i].leftX&&newCenterX<areas[i].rightX) {
				
					currentArea=areas[i].n;
					currentSubArea=areas[i].n2;

					this.tile=areas[i].num;
					///Door to other room (& blocking mechanism)
					doorTo(i);

				if(areas[i].n!="default"&&areas[i].n!="transition"&&areas[i].n!="water"&&areas[i].n!="deep-water"){
					inArea.inIt=true;
					 inArea.whatArea=areas[i].n;
				}else{
					inArea.inIt=false;
					 inArea.whatArea=areas[i].n;
				}
				///second level on same room
				transitionArea();
			}
		}/// dir right




		/// and t think this took me a day to figure out...
		/// forcing movement to detect area would fuck things up, but not forcing it would have the wonrg drawing intead....  and this solves it. Checks without any (moving) direction set
		if(this.direction=="room-change"){
		
			//console.log("VAMOS!")
			if(newCenterX<areas[i].rightX&&newCenterX>=areas[i].leftX&&newCenterY<=areas[i].bottomY&&newCenterY>areas[i].topY) {
				
				currentArea=areas[i].n; 
				currentSubArea=areas[i].n2;

				this.tile=areas[i].num;
				///Door to other room (& blocking mechanism)

				//console.log(areas[i].roomTo);

				if(areas[i].n!="default"&&areas[i].n!="transition"&&areas[i].n!="water"&&areas[i].n!="deep-water"){
					inArea.inIt=true;
					//alert("area");
					inArea.whatArea=areas[i].n;
				 }else{
				   
					inArea.inIt=false;
					inArea.whatArea=areas[i].n;
				}
				///second level on same room
				transitionArea();
			}

			//this.speed=1;
		} /// dir room-change

	}// for Areas

};///END Player-check-Areas








//////////////////////////////////////||
 /////		    ////                //||    //     ///////\
 /////		   ///  //             // ||   //|   ////
 /////		  ///  //             //  ||  //||    ////
 /////		 //// ////////		 //   || // ||     ////////\
 /////		//// ///		    //    ||//  ||          \/// 
 /////     ///// ///           //           ||          //// 
 /////    ///// ////\         //            ||       //////
//////// ////// ///////////////             ||///////////






//////////////////////////////////////  have another arguemtn for big and small, which applies when ammo != null
///////////////
function Item(xx, yy, itemType, itemCategory, selec, caught, branch, room) {   
															//// CURRENTROOM!!!!!! for drawing purposes

	/// itemType=> item/gun/ammo/life <<>>>  itemCategory => different types of each of those

	// srcX|Y automated on Update

	//where in tileMap
	this.drawX = xx;
	this.drawY = yy;
	//in sprite with & height
	this.width = tileDiameter;
	this.height =  tileDiameter;
	this.centerX = this.drawX + (this.width / 2);
	this.centerY = this.drawY + (this.height / 2);

	this.itemType = itemType;
	this.itemCategory  =itemCategory;   //// 0 to 9 (+10 = special)     branch 0 = weak, branch 1, stronger.. etc.
								///         if selec (use) >> if ammoType == 1 >> (loop gunsMenu, if gunMenuType[i] == 1) >> gunsMenu.bullets += X
								 //                            if ammoType == 10 >>  all gunMenu.bullets + X.... (or some mmore than others)    

	//this.lifeType = life; //// NOT NEEDED... LIFE CAN BE ITEMS THAT DO LIFE.... (very special)  >> the rest like Marathon
	//////////////                      special  stations scattered around the place which increase your life (method)

	this.select=selec;
	this.isCaught=caught;

	this.inRoom=room;
}


Item.prototype.update = function () {

	tileIndexX=0;
	tileIndexY=0;

	this.pickUp();



	if(this.itemType=="gun"){
		this.srcY=0;

		if(this.itemCategory==1){
			this.srcX=0;
		}else if(this.itemCategory==2){
			this.srcX=192;
		}

	}else if(this.itemType=="life"){
		this.srcY=256;

		if(this.itemCategory==0){
			this.srcX=0;
		}else if(this.itemCategory==1){
			this.srcX=0;
		}

	}else if(this.itemType=="ammo"){
		

		if(this.itemCategory.toString().substring(0,1)==1){
	
			if(this.itemCategory==1){
				this.srcY=64;
				this.srcX=0;
			}else if(this.itemCategory==11){
				this.srcY=128;
				this.srcX=0;
			}else if(this.itemCategory==111){
				this.srcY=128;
				this.srcX=64;
			}

		}else if(this.itemCategory.toString().substring(0,1)==2){
			if(this.itemCategory==2){
				this.srcY=64;
				this.srcX=192;
			}else if(this.itemCategory==22){
				this.srcY=128;
				this.srcX=192;
			}else if(this.itemCategory==222){
				this.srcY=128;
				this.srcX=256;
			}
		} 

	}else if(this.itemType=="item"){

		if(this.itemCategory>=0&&this.itemCategory<10){  
			
			// if(this.itemCategory==0){
			// 	this.srcY=384;
			// 	this.srcX=0;
			// }else 

			if(this.itemCategory==1){
				this.srcY=448;
				this.srcX=0;
			}else if(this.itemCategory==2){
				this.srcY=320;
				this.srcX=0;
			}else if(this.itemCategory==3){
				this.srcY=320;
				this.srcX=64;
			}else if(this.itemCategory==4){
				this.srcY=320;
				this.srcX=128;
			}else if(this.itemCategory==5){
				this.srcY=320;
				this.srcX=192; 
			}
		}else if(this.itemCategory>=10&&this.itemCategory<20){
			this.srcY=192;
			if(this.itemCategory==10){
				this.srcX=0;
			}else if(this.itemCategory==11){
				this.srcX=64;
			}
			
		}else if(this.itemCategory>=20&&this.itemCategory<100){
			this.srcX=64;
		}else if(this.itemCategory>=100){
			this.srcY=384;
			this.srcX=0;
		}
	}
};



var menuItemAlreadyPainted=false;
var menuGunAlreadyPainted=false;



Item.prototype.draw = function () {

	daMenu.draw();

	var newCenterX = Math.round(this.drawX  + (this.width / 2)), /// this.drawX will have to be changed to (newItemDrawX when I start moving it.. maybe
	newCenterY = Math.round(this.drawY + (this.height / 2));
																													  
	if(!this.isCaught&&flash==false){

	//alert(this.inRoom);
		
			///  draw only the ones in that area
			if(!inArea.inIt||currentArea=="transition"){  
			 ///////   unles there's also areas in level2
				//// then transition-areas, and area-areas  would have to be separated..


				if(currentRoom==this.inRoom){
			////////////////////////////////////////                   48, 48 ==>>  tileDiameter changes >> this is  ACTUAL W/H IN SPRITE
					if(this.itemType!="gun"){
						ctxEntities.drawImage(itemsPickSprite, this.srcX, this.srcY, 64, 64,  this.drawX, this.drawY, tileDiameter, tileDiameter);
					}else {
						ctxEntities.drawImage(itemsPickSprite, this.srcX, this.srcY, 64, 64, this.drawX, this.drawY, tileDiameter, tileDiameter);
					}
					/// BUT IF GUN >>> weaponSprite!!! tal cual
				}
			}else{

				for (var i = 0; i<areas.length; i++) {

					if(newCenterX<areas[i].rightX&&newCenterX>=areas[i].leftX&&newCenterY<=areas[i].bottomY&&newCenterY>areas[i].topY){
						if(areas[i].n!="default"&&areas[i].n!="transition"){

							// if areas[i].n == inArea.THE-EXACT-AREA 

							/// DRAW  this only
							//alert(inArea.whatArea);

							if(inArea.whatArea == areas[i].n){
								if(currentRoom==this.inRoom){
									if(this.itemType=="gun"){
										ctxEntities.drawImage(itemsPickSprite, this.srcX, this.srcY, 64, 64, this.drawX, this.drawY, this.width, this.height);
									}else {
										ctxEntities.drawImage(itemsPickSprite, this.srcX, this.srcY, 64, 64,  this.drawX, this.drawY, tileDiameter, tileDiameter);
									}
								}
							}

						}///  if(areas[i].n!="default"&&areas[i].n!="transition"){	
					}/// if YOU in this Area
				}// FOR Areas

			}//// if/ELSE  YOU NOT inArea

		}// IF   not-Caught

};



Item.prototype.pickUp = function(){

	//console.log(player1.items.length);
	var newCenterX = Math.round(newDrawX + (player1.width / 2)),
		newCenterY = Math.round(newDrawY + (player1.height / 2));
 

var itemAdd=false;
var noItemAdd=false;
var itemToIncrement;

var gunAdd=false;
var noGunAdd=false;

player1.items[0]={srcX:this.srcX, srcY:this.srcY, width:this.width, height:this.height, selec:this.selec, itemType:null, itemCategory:0,amount:0};


player1.guns[0]={srcX:570, srcY:605, width:45, height:45, selec:true, itemType:"gun", itemCategory:1,amount:0};



/////////////////
////  for some reason that I forgot, I need to set the first mnenu-items/weapon's  values here. 

///  it doesn't mattter since the first weapon in the game will always be 0. The problem comes when that's not the case.
//console.log("GUNS "+player1.guns.length);
if(newCenterX>this.centerX-this.width/2&&newCenterX<this.centerX+this.width/2&&newCenterY>this.centerY-this.height/2&&newCenterY<this.centerY+this.height/2){

	if(player1.items.length<3){
		menuCount=20;
		daMenu.draw();
	}


	if(currentRoom==this.inRoom){
		if(!this.isCaught){

			this.isCaught=true;

			/// here sort whether player1.items has already got one item of this type...
				if(this.itemType=="item"){



					for(var j=0; j<player1.items.length; j++){
						if(player1.items.length==1){
							itemAdd=true;
							//console.log("number "+ player1.items[j].itemCategory + "  amount "+ player1.items[j].amount);
						}else if(player1.items.length>1){
						  
							if(this.itemCategory!=player1.items[j].itemCategory&&j!=0){
							   itemAdd=true;
								//console.log("number "+ player1.items[j].itemCategory + "  amount "+ player1.items[j].amount);

							}else if(this.itemCategory==player1.items[j].itemCategory&&j!=0) {
							
								//console.log("ITEM #!! "+this.itemCategory);

							  	noItemAdd=true;   
								itemToIncrement=player1.items[j].itemCategory;  
							}
						}
						
					}

					menuTrack=0;
						 
				  
					//console.log(this.itemType.toUpperCase());

					///diff stuff happens when grabbing diff category of "iTEMS"
					 
				}else if(this.itemType=="gun"){
					menuTrack=1;
			  
					//console.log("GUN");
					 
				}else if(this.itemType=="ammo"){
					menuTrack=1;
	 	
	 				//// 
	 				console.log("CUANTOS NUMEROS "+this.itemCategory.toString().substring(0,1));

	 				//// This means weapon 0 (== 00, 000)  can't have ammo <<<  punch||knife||whatever
	 				var itemN = this.itemCategory.toString().substring(0,1);

	 								/////  depends on weapon!! (ammo big small varies from one weapon to the next)
	 				if(this.itemCategory.toString().length==3){
	 					bullets[itemN].current+=100;
	 				}else if(this.itemCategory.toString().length==2){
	 					bullets[itemN].current+=50;
	 				}else{
	 					bullets[itemN].current+=20;	
	 				}
					

					if(bullets[itemN].current>bullets[itemN].max){
						bullets[itemN].current=bullets[itemN].max;
					}

				}else if(this.itemType=="life"){   /// life || BIG life >> ammo || BIG ammo
						/// big or small given by itemCategory (type: "ammo", number: 1|2|3..<<  small|big|full pack)

				
					if(player1.life+20<=player1.lifeTotal){
						if(this.itemCategory==0){
							player1.lifeTo=player1.life+20;
							player1.filling=true;
						}else if(this.itemCategory==1){
							player1.lifeTo=player1.life+40;
							player1.filling=true;
						}
						//player1.life+=20;/// OR ELSE AS MUCH AS TO FILL HEALTH UP

					}
					
					
				}

				////  ... if not, push into a newly sortted array to tidily show items in menu
				/////  .. if yes, then 


				if(itemAdd&&!noItemAdd){  

					if(this.select==true){
						// itemRow=0;
						if(player1.items.length<=1){
							player1.items[0]={srcX:this.srcX, srcY:this.srcY, width:this.width, height:this.height, selec:this.selec, rowSelec:null, itemType:this.itemType, itemCategory:this.itemCategory, amount:1};   
			
						}

			//// ADD PARAM >>>>    SELECTABLE/NON-SELECTABLE
						pickingItemSFX.play();

						player1.items.push({srcX:this.srcX, srcY:this.srcY, width:this.width, height:this.height, selec:this.selec, rowSelec:null, itemType:this.itemType, itemCategory:this.itemCategory, amount:1});   

						selecto();

						pickingItem=true;

  					}else{

  						if(this.itemCategory==1){
  							orbSFX.play();
  						}else if(this.itemCategory==0){
  							keySFX.play();
  						}else {
  							nonSelectSFX.play();
  						}

  						player1.nonSelectItems.push({srcX:this.srcX, srcY:this.srcY, width:this.width, height:this.height, selec:this.selec, rowSelec:null, itemType:this.itemType, itemCategory:this.itemCategory, amount:1}); 
  					}

				}else if(noItemAdd&&itemToIncrement!="undefined"){

					    ////////////  maybe set a limit to this amount (like secret of Mana's magic 4....)
					

				
					for(var j=0; j<player1.items.length; j++){
						if(player1.items[j].itemCategory==this.itemCategory){

							pickingItemSFX.play();

							player1.items[j].amount++;
						}

					}
				}

				noItemAdd=false;
				itemAdd=false;
			   



			///////////   GUN PICK-UP    
				//////
				if(this.itemType=="gun"&&this.inRoom==currentRoom){
					for(var j=0; j<player1.guns.length; j++){

						if(this.itemType=="gun"){

							
							  
								if(this.itemCategory!=player1.guns[j].itemCategory){
								    gunAdd=true;
									
								}else if(this.itemCategory==player1.guns[j].itemCategory) {
									noGunAdd=true;  
								}
							
						}
					}
				}                
				////  ... if not, push into a newly sortted array to tidily show items in menu
				/////  .. if yes, then remember the player1.items.INDEX so as to increment its amount

				if(gunAdd&&!noGunAdd){
					
					if(player1.guns.length<=1){
						//console.log("TYPE "+player1.guns[0].gunType);
					   player1.guns[0]={srcX:this.srcX, srcY:this.srcY, width:this.width, height:this.height, selec:this.selec, rowSelec:null, itemType:this.itemType, itemCategory:this.itemCategory, bullets:0};


					   //console.log("TYPE "+player1.guns[0].gunType);
					}

					////  according to item number  >>srcX:____ gunSprite
					player1.guns.push({srcX:this.srcX, srcY:this.srcY, width:this.width, height:this.height, selec:this.selec, rowSelec:null,  itemType:this.itemType, itemCategory:this.itemCategory, bullets:0}); 
					selecto();
					
					//// FORCE select on new weapon
					weaponGrabSFX.play();


					pickingGun=true;
	
					if(bullets[this.itemCategory].current>bullets[this.itemCategory].max){
						bullets[this.itemCategory].current=bullets[this.itemCategory].max;
					}
								// console.log("BULL "+player1.guns[i+1].bullets);
								// depending on weapon, first pick could come with a few bullets...
							
						

					if((gunRow+1)<player1.guns.length){
						gunRow+=1;
					}
					//console.log(gunRow);
      
				}

				noGunAdd=false;
				gunAdd=false;
       


		    }//// IF this caught
	    }/// if this in room

		//console.log("DE ESTE "+player1.items[1].itemType+"HAY " +player1.items[1].amount); 

	}/// IF  newCenterX == itemCoordinates

};// END Items





               // ///////////////////                     // ///////////////////
              //  //              //////                 //  /               //////
              // /////////////////  //////               // /////////////////  //////
              // ///////////////// /  /////              // ///////////////// /  ///// 
              // //////||//   \/////  //////             // //////||//   \/////  //////
              // ////         /////////////              // ////         /////////////
              // ////        /////////////               // ////        /////////////
              // //////////////////////                  // //////////////////////   
               /////////////////////                      /////////////////////



							         

function activeBullet(id, x,y, xx, yy, allX, allY, w,h, weapon, player, direction, active, speed, type, distance, anim, bulletAnim) {   

								//// player => whoever shot the bullet, in case this ever supports multiplayer
	//where in sprite
	this.id=id;
	this.srcX = x;
	this.srcY = y;
	//where in tileMap
	this.drawX = xx;
	this.drawY = yy;
	//in sprite with & height
	this.width = w;
	this.height =  h;

	this.weapon = weapon; 
	this.owner = player;  
	this.direction = direction;  
	this.active=active;

	///dependent on type
	this.speed=speed;

	this.type=type;

	this.distanceTravelled=distance;

	this.allX=allX;
	this.allY=allY;

	this.animBullet=anim;

	this.bulletAnimated=bulletAnim;
}

var shootLong =false;

activeBullet.prototype.update = function () {



	for (var i=0; i< bulletsFired.length; i++) {

		if(bulletsFired[i].weapon==1){

			

			bulletsFired[i].allX.push(bulletsFired[i].drawX);
			bulletsFired[i].allY.push(bulletsFired[i].drawY);

		}

		if(bulletsFired[i].weapon==1){
			bulletsFired[i].speed = 20;
			bulletsFired[i].srcY=0;
		}else if(bulletsFired[i].weapon==2){
			bulletsFired[i].srcY=48;
			bulletsFired[i].speed = 10;
		}else if(bulletsFired[i].weapon==22){
			bulletsFired[i].srcY=96;
			bulletsFired[i].speed = 2.2;
		}
	}

	this.centerX = (this.drawX + (this.width / 2));
	this.centerY = (this.drawY + (this.height / 2));

	
	/// PARAM on bullet << TYPE <<< DIFF BEHAVIOUR below, for different type
	/// if this type...
	///			 other types will keep drawX|Y the same, but increase height|width parallel to Player (contraLaser)
	//																		      or perpendicular (ondas)
	//											and down on ctxBullet will have their own .fillRect instead
	//
	//				maybe  drawX|Y == player drawX|Y and adjusts itelf while holding B button (ultimateLaser)
	///
	//              other types will replicate itself in several (slightly tilted) directions (contraSpread)
	///
	///     other types release a series of mini bullets (short distance, full circle) around its crash point
	//												(based on distance of original bullet, or actual crash point)
	//											of course these mini bullets have their "minu-bullet" type
	//	
	//  some type of bullet have distance limits!!! 
	//							  >> flame thrower:  if this.type == (flameT type)
	//													this.distCounter++
	//												if distCounter >= X 
	//											bullet height|width doesn't exceed this point
	//													or if (shotgun type)
	//									   bullet inActiveObstacle(like crash) >> Func(mini-loop) release minu-bullets 	

	if(this.active){
		
			if(this.direction=="down"){
				this.drawY+=this.speed;
			}else if(this.direction=="up"){
				this.drawY-=this.speed;
			}else if(this.direction=="left"){
				this.drawX-=this.speed;
			}else if(this.direction=="right"){
				this.drawX+=this.speed;
			}else if(this.direction=="right-up"){
				this.drawX+=this.speed;
				this.drawY-=this.speed;
			}else if(this.direction=="left-up"){
				this.drawX-=this.speed;
				this.drawY-=this.speed;
			}else if(this.direction=="right-down"){
				this.drawX+=this.speed;
				this.drawY+=this.speed;
			}else if(this.direction=="left-down"){
				this.drawX-=this.speed;
				this.drawY+=this.speed;
			}

	}
	if(!shootLong){
		for(var j=0; j<player1.nonSelectItems.length; j++){
			if(player1.nonSelectItems[j].itemCategory==3){
				shootLong=true;
			}
		}
	}

	this.distanceTravelled++;
	//console.log("HOW FAR bull " +this.distanceTravelled);
	if(this.weapon==1&&this.distanceTravelled>10&&!shootLong){
		this.active=false;
	}else if(this.weapon==2&&this.distanceTravelled>20){
		this.active=false;

		weaponExplosion(bulletID, this.drawX, this.drawY, this.playerType);

	}else if(this.weapon==22&&this.distanceTravelled>14){
		this.active=false;

	}

	if(this.checkcrash().crashB){
		//console.log(this.checkcrashB().id);
		if(this.id==this.checkcrash().id){
			this.active=false;

			if(this.weapon==2){
				weaponExplosion(bulletID, this.drawX, this.drawY, this.playerType);
			}

			

			



			/// Y DE ACA ESTALLAN LAS MINI BALAS >> explosion!  << if weapon ==2
		}
	}/// if this.checkcrash().crashB
	
	function weaponExplosion(id, dX, dY, pType){

		//
		//// EXPLOSION upon crashing >> mini bullets in all direction <<< explosion Sprite
		//
		bulletsFired.push( new activeBullet(id, undefined, undefined, dX, dY, [],[], 64, 64,  22, pType, "left", true, undefined, "explosion", 0, 0, false));
		bulletsFired.push( new activeBullet(id, undefined, undefined, dX, dY, [],[], 64, 64,  22, pType, "right", true, undefined, "explosion", 0, 0, false));
		bulletsFired.push( new activeBullet(id, undefined, undefined, dX, dY, [],[], 64, 64,  22, pType, "up", true, undefined, "explosion", 0, 0, false));
		bulletsFired.push( new activeBullet(id, undefined, undefined, dX, dY, [],[], 64, 64,  22, pType, "down", true, undefined, "explosion", 0, 0, false));
		bulletsFired.push( new activeBullet(id, undefined, undefined, dX, dY, [],[], 64, 64,  22, pType, "left-down", true, undefined, "explosion", 0, 0, false));
		bulletsFired.push( new activeBullet(id, undefined, undefined, dX, dY, [],[], 64, 64,  22, pType, "right-up", true, undefined, "explosion", 0, 0, false));
		bulletsFired.push( new activeBullet(id, undefined, undefined, dX, dY, [],[], 64, 64,  22, pType, "left-up", true, undefined, "explosion", 0, 0, false));
		bulletsFired.push( new activeBullet(id, undefined, undefined, dX, dY, [],[], 64, 64,  22, pType, "right-down", true, undefined, "explosion", 0, 0, false));
		bulletsFired.push( new activeBullet(id, undefined, undefined, dX, dY, [],[], 64, 64,  22, pType, "nowhere", true, undefined, "explosion", 0, 0, false));
						/// nowhere keeps 1 in the middle.. so it looks more like an actual explosion
																			// (outward from the center s)			
		bulletID++;
		weapon2explodeSFX.play();			
	}

};



var animBulletX=0;


activeBullet.prototype.draw = function () {

	/// for loop all bullets...
	//console.log(this.weapon);  //// according to this where to point the Sprite

	this.animBullet++;

	

	for (var i=0; i< bulletsFired.length; i++) {

		setBulletX();
		function setBulletX(){
			//console.log(bulletsFired[i].animBullet==1 +"WWWWWA?");

			if(bulletsFired[i].animBullet==1){

				if(bulletsFired[i].id==bulletsFired[i].id){
					if(bulletsFired[i].weapon==1){
						if(bulletsFired[i].direction=="down"||bulletsFired[i].direction=="up"){
							bulletsFired[i].srcX=0;
							
						}else if(bulletsFired[i].direction=="left"||bulletsFired[i].direction=="right"){
							bulletsFired[i].srcX=144;
						}else if(bulletsFired[i].direction=="right-down"||bulletsFired[i].direction=="left-up"){
							bulletsFired[i].srcX=288;
						}else if(bulletsFired[i].direction=="left-down"||bulletsFired[i].direction=="right-up"){
							bulletsFired[i].srcX=432;
						}
					}else{					
							bulletsFired[i].srcX=0;	
					}
				}
			}

		}

		if(bulletsFired[i].weapon==1||bulletsFired[i].weapon==2){

			if(bulletsFired[i].animBullet>0&&bulletsFired[i].animBullet<=2){
				if(bulletsFired[i].id==bulletsFired[i].id){
					
					if(!bulletsFired[i].bulletAnimated){
						bulletsFired[i].srcX+=0;
						bulletsFired[i].bulletAnimated=true;
					}
				}	

			}else if(bulletsFired[i].animBullet>2&&bulletsFired[i].animBullet<=4){
				if(bulletsFired[i].id==bulletsFired[i].id){
					
					
					if(bulletsFired[i].bulletAnimated){
						
						bulletsFired[i].srcX+=48;
						bulletsFired[i].bulletAnimated=false;
					}
				}	

			}else if(this.animBullet>4&&this.animBullet<=6){
				if(bulletsFired[i].id==bulletsFired[i].id){
					
					
					if(!bulletsFired[i].bulletAnimated){

						bulletsFired[i].srcX+=48;
						bulletsFired[i].bulletAnimated=true;
					}
				}	

			}else if(bulletsFired[i].animBullet>6){
				bulletsFired[i].animBullet=1;
				setBulletX();
			}

		}else if(bulletsFired[i].weapon==22){


			if(bulletsFired[i].animBullet>0&&bulletsFired[i].animBullet<=2){
				if(bulletsFired[i].id==bulletsFired[i].id){
					
					if(!bulletsFired[i].bulletAnimated){
						bulletsFired[i].srcX+=0;
						bulletsFired[i].bulletAnimated=true;
					}
				}	

			}else if(bulletsFired[i].animBullet>2&&bulletsFired[i].animBullet<=4){
				if(bulletsFired[i].id==bulletsFired[i].id){
					
					
					if(bulletsFired[i].bulletAnimated){
						
						bulletsFired[i].srcX+=48;
						bulletsFired[i].bulletAnimated=false;
					}
				}	

			}else if(this.animBullet>4&&this.animBullet<=6){
				if(bulletsFired[i].id==bulletsFired[i].id){
					
					
					if(!bulletsFired[i].bulletAnimated){

						bulletsFired[i].srcX+=48;
						bulletsFired[i].bulletAnimated=true;
					}
				}	

			}else if(this.animBullet>6&&this.animBullet<=9){
				if(bulletsFired[i].id==bulletsFired[i].id){
					
					
					if(bulletsFired[i].bulletAnimated){

						bulletsFired[i].srcX+=48;
						bulletsFired[i].bulletAnimated=false;
					}
				}	

			}else if(this.animBullet>9&&this.animBullet<=12){
				if(bulletsFired[i].id==bulletsFired[i].id){
					
					
					if(!bulletsFired[i].bulletAnimated){

						bulletsFired[i].srcX+=48;
						bulletsFired[i].bulletAnimated=true;
					}
				}	

			}else if(bulletsFired[i].animBullet>12){
				if(bulletsFired[i].id==bulletsFired[i].id){
					
					
					if(bulletsFired[i].bulletAnimated){

						bulletsFired[i].srcX+=48;
						bulletsFired[i].bulletAnimated=false;
					}
				}
			}
		}


		ctxBullets.drawImage(imgBullets, bulletsFired[i].srcX, bulletsFired[i].srcY, bulletsFired[i].width, bulletsFired[i].height, bulletsFired[i].drawX, bulletsFired[i].drawY, bulletsFired[i].width, bulletsFired[i].height);


	}// FOR bulletsFired.length
	//console.log(this.owner);
};




/// bullet checkcrashB!!
activeBullet.prototype.checkcrash = function () {
	var crashB= false;
//  diff weapons have diff limits!!!!!!   >> flame thrower: crashB against air
	var id;

	function doorCrash(obstacleIndex, source){
									// source >> whether from PlayerCrash or Bullet

		

		if(obstacles[obstacleIndex].isDoor=="door"){        
			doorBlock=true;

			if(obstacles[obstacleIndex].ID==370&&source=="bullet"||obstacles[obstacleIndex].ID==370&&source=="bigbullet"||obstacles[obstacleIndex].ID==371&&source=="bigbullet"){

				doorOpen(obstacles[obstacleIndex].ID, obstacles[obstacleIndex].timeToClose, obstacles[obstacleIndex].Tindex, true);

				blockDestroySFX.play();
					
					
			}else if(obstacles[obstacleIndex].ID!=370&&obstacles[obstacleIndex].ID!=371&&obstacles[obstacleIndex].ID!=390&&source!="bullet"&&source!="bigbullet"){
			
				doorOpen(obstacles[obstacleIndex].ID, obstacles[obstacleIndex].timeToClose, obstacles[obstacleIndex].Tindex);
			}
		}
	}


	for (var i = 0; i < obstacles.length; i++) {

		if( obstacles[i].obstacleStatus=="closed"){ 

			if(obstacles[i].ID!=390){

				if(this.direction=="right"){

					//// repeat this if/else on enemies centerX|Y -+

					///in other words: as long as bullet in the block before the one you would be at if going right
					if(this.centerY>=obstacles[i].topY&&this.centerY<obstacles[i].bottomY&&this.centerX<=obstacles[i].leftX&&this.centerX>obstacles[i].leftX-tileDiameter) { ///// 10 => bullet diameter

						//but don't stop me just yet, only if not doing so would put me on the other side 
						if(this.centerX+this.speed>=obstacles[i].leftX-(this.speed+1)){

							crashB = true; 
							id=this.id;
							
							
							if(this.weapon==22){
								doorCrash(i, "bigbullet"); 
								this.active=false;
							}else if(this.weapon==1){
								doorCrash(i, "bullet"); 
								this.active=false;
							}
							 
						}
					}
				}  /// dir


				if(this.direction=="left"){

					if(this.centerY<=obstacles[i].bottomY&&this.centerY>obstacles[i].topY&&this.centerX>=obstacles[i].rightX&&this.centerX<obstacles[i].rightX+tileDiameter){
						
						if(this.centerX-this.speed<=obstacles[i].rightX+(this.speed+1)){

							crashB = true;
							id=this.id;

							//console.log(this.weapon);

							if(this.weapon==22){
								doorCrash(i, "bigbullet"); 
								this.active=false;
							}else if(this.weapon==1){
								doorCrash(i, "bullet"); 
								this.active=false;
							}
						}
					}
				} 


				if(this.direction=="up"){

					if(this.centerX>=obstacles[i].leftX&&this.centerX<obstacles[i].rightX&&this.centerY>=obstacles[i].bottomY&&this.centerY<obstacles[i].bottomY+tileDiameter) {

						if(this.centerY-this.speed<=obstacles[i].bottomY+(this.speed+1)){
								crashB = true; 
								id=this.id;

								if(this.weapon==22){
								doorCrash(i, "bigbullet"); 
								this.active=false;
							}else if(this.weapon==1){
								doorCrash(i, "bullet"); 
								this.active=false;
							}
						}         
					}
				}   
				if(this.direction=="down"){

					if(this.centerX>obstacles[i].leftX&&this.centerX<=obstacles[i].rightX&&this.centerY<=obstacles[i].topY&&this.centerY>obstacles[i].topY-tileDiameter) {

						if(this.centerY+this.speed>=obstacles[i].topY-(this.speed+1)){
								crashB = true;  
								id=this.id;
							if(this.weapon==22){
								doorCrash(i, "bigbullet"); 
								this.active=false;
							}else if(this.weapon==1){
								doorCrash(i, "bullet"); 
								this.active=false;
							}
								
						}
					}
				}   


			////////////////////////////////////////
			//////////////////////////////	         d   I   A   G   O   N   A   L    S
			//////////////////////////////////


				if(this.direction=="right-down"){ 


					if(this.centerY>=obstacles[i].topY&&this.centerY<obstacles[i].bottomY&&this.centerX<=obstacles[i].leftX&&this.centerX>obstacles[i].leftX-tileDiameter) {

						//but don't stop me just yet, i've just entered the square, now wait for me to be at the other side
						if(this.centerX+this.speed>=obstacles[i].leftX-(this.speed+1)){
							// crashB = true;  
							// doorcrashB(i);
							
								crashB = true;
								id=this.id;

							if(this.weapon==22){
								doorCrash(i, "bigbullet"); 
								this.active=false;
							}else if(this.weapon==1){
								doorCrash(i, "bullet"); 
								this.active=false;
							} 
							
						}
					}


					if(this.centerX>obstacles[i].leftX&&this.centerX<=obstacles[i].rightX&&this.centerY<=obstacles[i].topY&&this.centerY>obstacles[i].topY-tileDiameter) {

						if(this.centerY+this.speed>=obstacles[i].topY-(this.speed+1)){
							// crashB = true;
							// doorcrashB(i);
					
								crashB = true;
								id=this.id;

								if(this.weapon==22){
								doorCrash(i, "bigbullet"); 
								this.active=false;
							}else if(this.weapon==1){
								doorCrash(i, "bullet"); 
								this.active=false;
							}
							
							
						}
					}
					//////   ADD AN EXPLICITELY diagonal check.....
					////  AND only on this one >>> 
							// crashB = true;
							// doorcrashB(i);

					if(this.centerY<=obstacles[i].topY&&this.centerX<=obstacles[i].leftX) {

						//but don't stop me just yet, i've just entered the square, now wait for me to be at the other side
						//console.log("WHAT"+player1.direction);
						if(this.centerX+this.speed>=obstacles[i].leftX-(this.speed+1)&&this.centerY+this.speed>=obstacles[i].topY-(this.speed+1)){
							
								crashB = true;
								id=this.id;

								if(this.weapon==22){
								doorCrash(i, "bigbullet"); 
								this.active=false;
							}else if(this.weapon==1){
								doorCrash(i, "bullet"); 
								this.active=false;
							}
							

						}
					}

				} /////  if(this.direction=="right-down"){  

			/////
			///////
			//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

				if(this.direction=="left-down"){ 

					 if(this.centerY<=obstacles[i].bottomY&&this.centerY>obstacles[i].topY&&this.centerX>=obstacles[i].rightX&&this.centerX<obstacles[i].rightX+tileDiameter) {
						
						if(this.centerX-this.speed<=obstacles[i].rightX+(this.speed+1)){
						
								crashB = true;
								id=this.id;

							if(this.weapon==22){
								doorCrash(i, "bigbullet"); 
								this.active=false;
							}else if(this.weapon==1){
								doorCrash(i, "bullet"); 
								this.active=false;
							}
							
						}
					}

					if(this.centerX>obstacles[i].leftX&&this.centerX<=obstacles[i].rightX&&this.centerY<=obstacles[i].topY&&this.centerY>obstacles[i].topY-tileDiameter) {

						if(this.centerY+this.speed>=obstacles[i].topY-(this.speed+1)){
						
								crashB = true;
								id=this.id;

								if(this.weapon==22){
								doorCrash(i, "bigbullet"); 
								this.active=false;
							}else if(this.weapon==1){
								doorCrash(i, "bullet"); 
								this.active=false;
							} 
							
						}
					}



					if(this.centerY<=obstacles[i].topY&&this.centerX>=obstacles[i].rightX) {

						//but don't stop me just yet, i've just entered the square, now wait for me to be at the other side
						//console.log(crashBDir);
						if(this.centerX-this.speed<=obstacles[i].rightX+(this.speed+1)&&this.centerY+this.speed>=obstacles[i].topY-(this.speed+1)){
							
								crashB = true;
								id=this.id;

								if(this.weapon==22){
								doorCrash(i, "bigbullet"); 
								this.active=false;
							}else if(this.weapon==1){
								doorCrash(i, "bullet"); 
								this.active=false;
							} 
								//crashBDir="right-down";
				

							// crashBDir="right";
						}
					}

				}


			/////
			///////
			//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


				if(this.direction=="left-up"){ 

					if(this.centerY<=obstacles[i].bottomY&&this.centerY>obstacles[i].topY&&this.centerX>=obstacles[i].rightX&&this.centerX<obstacles[i].rightX+8) {
						
						if(this.centerX-this.speed<=obstacles[i].rightX+(this.speed+1)){
							
								crashB = true;
								id=this.id;

								if(this.weapon==22){
								doorCrash(i, "bigbullet"); 
								this.active=false;
							}else if(this.weapon==1){
								doorCrash(i, "bullet"); 
								this.active=false;
							}
							
						}
					}

					if(this.centerX>=obstacles[i].leftX&&this.centerX<obstacles[i].rightX&&this.centerY>=obstacles[i].bottomY&&this.centerY<obstacles[i].bottomY+8) {

						if(this.centerY-this.speed<=obstacles[i].bottomY+(this.speed+1)){
							
								crashB = true;
								id=this.id;

								if(this.weapon==22){
								doorCrash(i, "bigbullet"); 
								this.active=false;
							}else if(this.weapon==1){
								doorCrash(i, "bullet"); 
								this.active=false;
							} 
							
						}         
					}


					if(this.centerY>=obstacles[i].bottomY&&this.centerX>=obstacles[i].rightX) {

						//but don't stop me just yet, i've just entered the square, now wait for me to be at the other side
						//console.log(crashBDir);
						if(this.centerX-this.speed<=obstacles[i].rightX+(this.speed+1)&&this.centerY-this.speed<=obstacles[i].bottomY+(this.speed+1)){
						
								crashB = true;
								id=this.id;

								if(this.weapon==22){
								doorCrash(i, "bigbullet"); 
								this.active=false;
							}else if(this.weapon==1){
								doorCrash(i, "bullet"); 
								this.active=false;
							}
								//crashBDir="right-down";
							

							// crashBDir="right";
						}
					}


				}


				if(this.direction=="right-up"){ 

					if(this.centerX>=obstacles[i].leftX&&this.centerX<obstacles[i].rightX&&this.centerY>=obstacles[i].bottomY&&this.centerY<obstacles[i].bottomY+tileDiameter) {

						if(this.centerY-this.speed<=obstacles[i].bottomY+(this.speed+1)){
					
								crashB = true;
								id=this.id;

								if(this.weapon==22){
								doorCrash(i, "bigbullet"); 
								this.active=false;
							}else if(this.weapon==1){
								doorCrash(i, "bullet"); 
								this.active=false;
							}
							
						}         
					}

						///in other words: as long as you are standing in the block before what would be the next one when going right
					if(this.centerY>=obstacles[i].topY&&this.centerY<obstacles[i].bottomY&&this.centerX<=obstacles[i].leftX&&this.centerX>obstacles[i].leftX-tileDiameter) {

							//but don't stop me just yet, i've just entered the square, now wait for me to be at the other side
							if(this.centerX+this.speed>=obstacles[i].leftX-(this.speed+1)){
							
									crashB = true;
									id=this.id;
							if(this.weapon==22){
								doorCrash(i, "bigbullet"); 
								this.active=false;
							}else if(this.weapon==1){
								doorCrash(i, "bullet"); 
								this.active=false;
							}
								
							
							}
						}
					

					if(this.centerY>=obstacles[i].bottomY&&this.centerX<=obstacles[i].leftX) {

						//but don't stop me just yet, i've just entered the square, now wait for me to be at the other side
						//console.log(crashBDir);
						if(this.centerX+this.speed>=obstacles[i].leftX-(this.speed+1)&&this.centerY-this.speed<=obstacles[i].bottomY+(this.speed+1)){
					
								crashB = true;
								id=this.id;

								if(this.weapon==22){
								doorCrash(i, "bigbullet"); 
								this.active=false;
							}else if(this.weapon==1){
								doorCrash(i, "bullet"); 
								this.active=false;
							} 

						}
					}

				}/// last direction

			}// if ! 290
		}/// if active
	}/// for Obst


	if (crashB) {
		return {crashB:true, id:id};
	} else {
		return {crashB:false, id:id};
	}	

}// END Bullet-Check-Crash
